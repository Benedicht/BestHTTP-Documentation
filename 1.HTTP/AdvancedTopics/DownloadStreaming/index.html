<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Tivadar GyÃ¶rgy Nagy">
    <link rel="canonical" href="http://u3d.as/5sb/1.HTTP/AdvancedTopics/DownloadStreaming/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Download Streaming - Best HTTP/2 Documentation</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
	<link rel="stylesheet" href="../../../css/prism.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
	<script src="../../../js/prism.js"></script>
	
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Download Streaming", url: "#_top", children: [
              {title: "Streaming into a file", url: "#streaming-into-a-file" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script> 
</head>

<body class="line-numbers match-braces" >
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../ErrorHandling/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../ErrorHandling/" class="btn btn-xs btn-link">
        ErrorHandling
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../DownloadProgress/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../DownloadProgress/" class="btn btn-xs btn-link">
        Download Progress Tracking
      </a>
    </div>
    
  </div>

    

    <h1 id="download-streaming">Download Streaming</h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not available under the WebGL runtime. See <a href="../../../platforms/">platforms and limitations section for more details</a></p>
</div>
<p>For larger responses it's not advised to keep the whole entity in memory. To be able process downloaded data as soon as received the plugin provides the <code>OnStreamingData</code> callback. </p>
<pre><code class="language-csharp">var request = new HTTPRequest(new Uri(&quot;...&quot;), OnRequestFinished);
request.OnStreamingData += OnDataDownloaded;

bool OnDataDownloaded(HTTPRequest request, HTTPResponse response, byte[] dataFragment, int dataFragmentLength)
{
    // Use downloaded data

    return true;
}
</code></pre>

<p>The callback's parameters are the following:</p>
<ul>
<li><strong>request</strong>: the original <code>HTTPRequest</code> object</li>
<li><strong>response</strong>: the <code>HTTPResponse</code> object the data belongs to. Through this object all already received information can be accessed (status code, headers, etc.)</li>
<li><strong>dataFragment</strong>: the actual downloaded bytes. Because the plugin reuses byte arrays, its length can be larger than the downloaded data, so instead of <code>dataFragment.Length</code> the <code>dataFragmentLength</code> parameter must be used!</li>
<li><strong>dataFragmentLength</strong>: the real downloaded byte count of the dataFragment parameter. Use this parameter instead of <code>dataFragment.Length</code>!</li>
</ul>
<p>The callback also must return <code>true</code> or <code>false</code> depending on whether the plugin can reuse the <code>dataFragment</code> buffer or not. For more details see the <a href="../../../7.GlobalTopics/BufferPool/">BufferPool documentation</a>.
So in case the dataFragment's reference is kept by user code, the callback must return false:</p>
<pre><code class="language-csharp">var request = new HTTPRequest(new Uri(&quot;...&quot;), OnRequestFinished);
request.OnStreamingData += OnDataDownloaded;

List&lt;Data&gt; dataToProcess = new List&lt;Data&gt;();
bool OnDataDownloaded(HTTPRequest request, HTTPResponse response, byte[] dataFragment, int dataFragmentLength)
{
    // dataFragment is saved to process it later
    dataToProcess.Add(new Data { 
        buffer = dataFragment, 
        length = dataFragmentLength 
    });

    // so the callback must return false, otherwise the plugin would reuse the byte[] overwriting the data in it
    return false;
}

struct Data
{
    public byte[] buffer;
    public int length;
}
</code></pre>

<p>Size of the <code>dataFragment</code> (== <code>dataFragmentLength</code>) depends on various factors:</p>
<ol>
<li>Value of the <code>StreamFragmentSize</code> property. The plugin tries to keep the fragments' size around <code>StreamFragmentSize</code>, but the BufferPool can return a larger chunks of memory.</li>
<li>If <code>StreamChunksImmediately</code> is <code>true</code>, then no buffering will be done. In case of chunked content-encoding the size of the fragment is the chunk length. In case there's a content-length header, the plugin fills up an at least <code>HTTPResponse.MinBufferSize</code>d buffer for the next fragment.</li>
</ol>
<p>Because there's a time window between producing dataFragments and consuming them in an <code>OnStreamingData</code> callback, to prevent consuming too much memory there's a hard limit on the queued dataFragments. When this hard limit is reached the reader thread stops producing new fragments and resumes as soon as there's free slots in the queue. This hard limit can be changed through the <code>MaxFragmentQueueLength</code> property. So, the maximum amount of memory the plugin will consme for streaming is about (<code>MaxFragmentQueueLength</code> * <code>StreamFragmentSize</code>).<br>
With HTTP/2, the reading thread doesn't know the semantics of the frames it reads from the stream, so it can't limit what and how many frames/data it reads (it would also block the reading of other frames too). To limit a HTTP/2 stream and/or the whole HTTP/2 connection <a href="../../../7.GlobalTopics/HTTP2/"><code>HTTPManager.HTTP2Settings</code></a>' <code>InitialStreamWindowSize</code> and <code>InitialConnectionWindowSize</code> can be used.</p>
<h2 id="streaming-into-a-file">Streaming into a file</h2>
<p>In the following example the <code>FileStream</code> is created on-demand and its reference is stored in the request's Tag property to reuse the instance instead of reopening the file every time.</p>
<pre><code class="language-csharp">var request = new HTTPRequest(new Uri(url), OnRequestFinished);

request.OnStreamingData += OnData;

request.Send();

private bool OnData(HTTPRequest req, HTTPResponse resp, byte[] dataFragment, int dataFragmentLength)
{
    if (resp.IsSuccess)
    {
        var fs = req.Tag as System.IO.FileStream;
        if (fs == null)
            req.Tag = fs = new System.IO.FileStream(&quot;fileName&quot;, System.IO.FileMode.Create);

        fs.Write(dataFragment, 0, dataFragmentLength);
    }

    // Return true if dataFragment is processed so the plugin can recycle it
    return true;
}

private void OnRequestFinished(HTTPRequest req, HTTPResponse resp)
{
    var fs = req.Tag as System.IO.FileStream;
    if (fs != null)
        fs.Dispose();

    switch (req.State)
    {
        // The request finished without any problem.
        case HTTPRequestStates.Finished:
            if (resp.IsSuccess)
            {
                Debug.Log(&quot;Done!&quot;);
            }
            else
            {
                Debug.LogWarning(string.Format(&quot;Request finished Successfully, but the server sent an error. Status Code: {0}-{1} Message: {2}&quot;,
                                                resp.StatusCode,
                                                resp.Message,
                                                resp.DataAsText));
            }
            break;

        default:
                // There were an error while downloading the content.
                // The incomplete file should be deleted.
                System.IO.File.Delete(&quot;filename&quot;);
            break;
    }
}
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../ErrorHandling/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../ErrorHandling/" class="btn btn-xs btn-link">
        ErrorHandling
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../DownloadProgress/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../DownloadProgress/" class="btn btn-xs btn-link">
        Download Progress Tracking
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>