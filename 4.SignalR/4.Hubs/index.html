<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Tivadar György Nagy">
    <link rel="canonical" href="http://u3d.as/5sb/4.SignalR/4.Hubs/">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Hubs - Best HTTP/2 Documentation</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
	<link rel="stylesheet" href="../../css/prism.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
	<script src="../../js/prism.js"></script>
	
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Hubs", url: "#_top", children: [
              {title: "Accessing hubs", url: "#accessing-hubs" },
              {title: "Register server callable methods", url: "#register-server-callable-methods" },
              {title: "Call server-side methods", url: "#call-server-side-methods" },
              {title: "Using the Hub class as a base class to inherit from", url: "#using-the-hub-class-as-a-base-class-to-inherit-from" },
              {title: "Authentication", url: "#authentication" },
              {title: "Writing custom Json encoders", url: "#writing-custom-json-encoders" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body class="line-numbers match-braces" >
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../5.EventSource/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../5.EventSource/" class="btn btn-xs btn-link">
        Server-Sent Events (EventSource)
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../3.Sending/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../3.Sending/" class="btn btn-xs btn-link">
        Sending non-Hub messages
      </a>
    </div>
    
  </div>

    

    <h1 id="hubs">Hubs</h1>
<p>In order to define methods on the client that a Hub can call from the server, and to invoke methods on a Hub at the server, Hubs must be added to the Connection object. This can be done by adding the hub names or hub instances to the Connection constructor, demonstrated in the <em>Connection Class</em> section.</p>
<h2 id="accessing-hubs">Accessing hubs</h2>
<p>Hub instances can be accessed through the Connection object by index, or by name.</p>
<pre><code class="language-csharp">Hub hub = signalRConnection[0];
Hub hub = signalRConnection[&quot;hubName&quot;];
</code></pre>

<h2 id="register-server-callable-methods">Register server callable methods</h2>
<p>To handle server callable method calls, we have to call the On function of a hub:</p>
<pre><code class="language-csharp">// Register method implementation
signalRConnection[&quot;hubName&quot;].On(&quot;joined&quot;, Joined);

// &quot;Joined&quot; method implementation on the client
void Joined(Hub hub, MethodCallMessage msg)
{
  Debug.Log(string.Format(&quot;{0} joined at {1}&quot;, msg.Arguments[0], msg.Arguments[1]));
}
</code></pre>

<p>The MethodCallMessage is a server sent object that contains the following properties:</p>
<ul>
<li><strong>Hub</strong>: A string containing the hub name that the method have to call on.</li>
<li><strong>Method</strong>: A string that contains the method name.</li>
<li><strong>Arguments</strong>: An array of objects that contains the arguments of the method call. It can be an empty array.</li>
<li><strong>State</strong>: A dictionary containing additional custom data.</li>
</ul>
<p>The plugin will use the Hub and Method properties to route the message to the right hub and event handler. The function that handles the method call have to use only the Arguments and State properties.</p>
<h2 id="call-server-side-methods">Call server-side methods</h2>
<p>Calling server-side methods can be done by call a Hub’s Call function. The call function overloaded to be able to fulfill every needs. The Call functions are non-blocking functions, they will <strong>not</strong> block until the server sends back any message about the call.</p>
<p>The overloads are the following:</p>
<ul>
<li><strong>Call(string method, params object[] args)</strong>: This can be used to call a server-side function in a fire-and-forget style. We will not receive back any messages about the method call’s success or failure. This function can be called without any ‘args’ arguments, to call a parameterless method.</li>
</ul>
<pre><code class="language-csharp">// Call a server-side function without any parameters
signalRConnection[&quot;hubName&quot;].Call(&quot;Ping&quot;);

// Call a server-side function with two string parameters: &quot;param1&quot; and &quot;param2&quot;
signalRConnection[&quot;hubName&quot;].Call(&quot;Message&quot;, &quot;param1&quot;, &quot;param2&quot;);
</code></pre>

<ul>
<li><strong>Call(string method, OnMethodResultDelegate onResult, params object[] args)</strong>: This function can be used as the previous one, but a function can be passed as the second parameter that will be called when the server-side function successfully invoked.</li>
</ul>
<pre><code class="language-csharp">signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone);

void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result)
{
  Debug.Log(&quot;GetValue executed on the server. Return value of the function:&quot; + result.ReturnValue.ToString());
}
</code></pre>

<p>This callback function receives the Hub that called this function, the original ClientMessage message that sent to the server and the ResultMessage instance sent by the server as a result of the method call. A ResultMessage object contains a ReturnValue and a State properties.</p>
<p>If the method’s return type is void, the ReturnValue is null.</p>
<ul>
<li><strong>Call(string method, OnMethodResultDelegate onResult, OnMethodFailedDelegate onError, params object[] args)</strong>: This function can be used to specify a callback that will be called when the method fails to run on the server. Failures can be happen because of a non-found method, wrong parameters, or unhandled exceptions in the method call.</li>
</ul>
<pre><code class="language-csharp">signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed);

void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error)
{
  Debug.Log(&quot;GetValue failed. Error message from the server: &quot; + error.ErrorMessage);
}
</code></pre>

<p>A FailureMessage contains the following properties:</p>
<ul>
<li>
<ul>
<li><strong>IsHubError</strong>: True if it is a Hub error.</li>
<li><strong>ErrorMessage</strong>: A brief message about the error itself.</li>
<li><strong>StackTrace</strong>: If detailed error reporting is turned on on the server then it contains the stack trace of the error.</li>
<li><strong>AdditionalData</strong>: If it’s not null, then it contains additional information about the error.</li>
</ul>
</li>
<li>
<p><strong>Call(string method, OnMethodResultDelegate onResult, OnMethodFailedDelegate onError, OnMethodProgressDelegate onProgress, params object[] args</strong>): This function can be used to add an additional progress message handler to the server-side method call. For long running jobs the server can send progress messages to the client.</p>
</li>
</ul>
<pre><code class="language-csharp">signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed, OnGetValueProgress);

void OnGetValueProgress(Hub hub, ClientMessage originalMessage,
ProgressMessage progress)
{
  Debug.Log(string.Format(&quot;GetValue progressed: {0}%&quot;, progress.Progress));
}
</code></pre>

<p>When a ResultMessage or FailureMessage received by the plugin, it will not serve the ProgressMessages that came after these messages.</p>
<h2 id="using-the-hub-class-as-a-base-class-to-inherit-from">Using the Hub class as a base class to inherit from</h2>
<p>The Hub class can be used as a base class to encapsulate hub functionality.</p>
<pre><code class="language-csharp">class SampleHub : Hub
{
 // Default constructor. Every hubs have to have a valid name.
 public SampleHub()
   :base(&quot;SampleHub&quot;)
 {
    // Register a server-callable function
    base.On(&quot;ClientFunction&quot;, ClientFunctionImplementation);
 }

 // Private function to implement server-callable function
 private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg)
 {
   // TODO: implement
 }

 // Wrapper function to call a server-side function.
 public void ServerFunction(string argument)
 {
    base.Call(&quot;ServerFunction&quot;, argument);
 }
}
</code></pre>

<p>This SampleHub can be instantiated and passed to the Connection’s constructor:</p>
<pre><code class="language-csharp">SampleHub sampleHub = new SampleHub();
Connection signalRConnection = new Connection(Uri, sampleHub);
</code></pre>

<h2 id="authentication">Authentication</h2>
<p>The Connection class has an AuthenticationProvider property that can be set to an object that  implements the IAuthenticationProvider interface.
The implementor has to implement the following property and functions:</p>
<ul>
<li><strong>bool IsPreAuthRequired</strong>:Property that returns true, if the authentication must run before any request is made to the server by the Connection class. Examples: a cookie authenticator must return false, as it has to send user credentials and receive back a cookie that must sent with the requests.</li>
<li><strong>StartAuthentication</strong>: A function that required only if the IsPreAuthRequired is true. Otherwise it doesn’t called.</li>
<li><strong>PrepareRequest</strong>: A function that is called with a request and a request type enum. This function can be used to prepare requests before they are sent to the server.</li>
<li><strong>OnAuthenticationSucceded</strong>: An event that must be called when the IsPreAuthRequired is true and the authentication process succeeded.</li>
<li><strong>OnAuthenticationFailed</strong>: An event that must be called when the IsPreAuthRequired is true and the authentication process failed.</li>
</ul>
<p>A very simple Header-based authenticator would look like this:</p>
<pre><code class="language-csharp">class HeaderAuthenticator : IAuthenticationProvider
{
   public string User { get; private set; }
   public string Roles { get; private set; }

   // No pre-auth step required for this type of authentication
   public bool IsPreAuthRequired { get { return false; } }

   // Not used event as IsPreAuthRequired is false
   public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded;

   // Not used event as IsPreAuthRequired is false
   public event OnAuthenticationFailedDelegate OnAuthenticationFailed;

   // Constructor to initialise the authenticator with username and roles.
   public HeaderAuthenticator(string  user, string roles)
   {
     this.User = user;
     this.Roles = roles;
   }

   // Not used as IsPreAuthRequired is false
   public void StartAuthentication()
   { }

   // Prepares the request by adding two headers to it
   public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type)
   {
     request.SetHeader(&quot;username&quot;, this.User);
     request.SetHeader(&quot;roles&quot;, this.Roles);
   }
}
</code></pre>

<h2 id="writing-custom-json-encoders">Writing custom Json encoders</h2>
<p>Like for the Socket.IO’s Manager class, the SignalR’s Connection class has a JsonEncoder property, and the static Connection.DefaultEncoder can be set too.
A JsonEncoder must implement the IJsonEncoder interface from the BestHTTP.SignalR.JsonEncoders namespace.
The package contains a sample LitJsonEncoder, that also used by some samples too.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../5.EventSource/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../5.EventSource/" class="btn btn-xs btn-link">
        Server-Sent Events (EventSource)
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../3.Sending/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../3.Sending/" class="btn btn-xs btn-link">
        Sending non-Hub messages
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>