<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Tivadar György Nagy">
    <link rel="canonical" href="http://u3d.as/5sb/3.Socket.IO/3.SendingEvents/">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Sending events - Best HTTP/2 Documentation</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
	<link rel="stylesheet" href="../../css/prism.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
	<script src="../../js/prism.js"></script>
	
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Sending events", url: "#_top", children: [
              {title: "Sending acknowledgement to the server", url: "#sending-acknowledgement-to-the-server" },
              {title: "Sending binary data", url: "#sending-binary-data" },
              {title: "Receiving binary data", url: "#receiving-binary-data" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body class="line-numbers match-braces" >
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../4.DefaultEncoder/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../4.DefaultEncoder/" class="btn btn-xs btn-link">
        Set the default Json encoder
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2.ReceivingEvents/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2.ReceivingEvents/" class="btn btn-xs btn-link">
        Subscribing and receiving events
      </a>
    </div>
    
  </div>

    

    <h1 id="sending-events">Sending events</h1>
<p>You can send an event with the Emit function. You have to pass the event name as the first parameter and optionally other parameters. These will be encoded to json and will be sent to the server. Optionally you can set a callback function that will be called when the server processes the event(you have to set up the server code properly to be able to send back a callback function. See the Socket.IO server side documentation for more information).</p>
<pre><code class="language-csharp">// Send a custom event to the server with two parameters
manager.Socket.Emit(&quot;message&quot;, &quot;userName&quot;, &quot;message&quot;);

// Send an event and define a callback function that will be called as an
// acknowledgement of this event
manager.Socket.Emit(&quot;custom event&quot;, OnAckCallback, &quot;param 1&quot;, &quot;param 2&quot;);

void OnAckCallback(Socket socket, Packet originalPacket, params object[] args)
{
    Debug.Log(&quot;OnAckCallback!&quot;);
}
</code></pre>

<h2 id="sending-acknowledgement-to-the-server">Sending acknowledgement to the server</h2>
<p>You can send back an acknowledgement to the server by calling the socket’s EmitAck function. You have to pass the original packet and any optional data:</p>
<pre><code class="language-csharp">manager[&quot;/customNamespace&quot;].On(&quot;customEvent&quot;, (socket, packet, args) =&gt;
{
    socket.EmitAck(packet, &quot;Event&quot;, &quot;Received&quot;, &quot;Successfully&quot;);
});
</code></pre>

<p><em>You can keep a reference to the packet, and call the EmitAck from somewhere else.</em></p>
<h2 id="sending-binary-data">Sending binary data</h2>
<p>There are two ways of sending binary(byte[]) data.</p>
<ul>
<li>By passing to the Emit function the plugin will scan the parameters and if it founds one, it will convert it to a binary attachment(as introduced in Socket.IO 1.0). This is the most efficient way, because it will not convert the byte array to a Base64 encoded string on client side, and back to binary on server side.</li>
</ul>
<pre><code class="language-csharp">byte[] data = new byte[10];
//...
manager.Socket.Emit(&quot;eventWithBinary&quot;, &quot;textual param&quot;, data);
</code></pre>

<ul>
<li>If the binary data is embedded in an object as a field or property the Json encoder must support the conversion. The default Json encoder can’t convert the embedded binary data to Json, you have to use a more advanced Json parser library (like <a href="https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347?aid=1101lfX8E">"JSON .NET For Unity"</a>)</li>
</ul>
<h2 id="receiving-binary-data">Receiving binary data</h2>
<p>In the Socket.IO server when binary data sent to the client it will replace the data with a Json object({'_placeholder':true,'num':xyz}) and will send the binary data in another packet. On client side these packets will be collected and will be merged into one packet. The binary data will be in the packet’s Attachments property.
Here you will have some options too to use this packet:</p>
<ul>
<li>In your event-handler you can access all binary data through the packet’s Attachments property.</li>
</ul>
<pre><code class="language-csharp">Socket.On(&quot;frame&quot;, OnFrame);

void OnFrame(Socket socket, Packet packet, params object[] args)
{
    texture.LoadImage(packet.Attachments[0]);
}
</code></pre>

<ul>
<li>The second option is almost the same as the previous, with a little improvement: we will not decode the sent Json string to c# objects. We can do it because we know that the server sent only the binary data, no other information came with this event. So we will let the plugin know that do not decode the payload:</li>
</ul>
<pre><code class="language-csharp">// Subscribe to the &quot;frame&quot; event, and set the autoDecodePayload flag to false
Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false);

void OnFrame(Socket socket, Packet packet, params object[] args)
{
    // Use the Attachments property as before
    texture.LoadImage(packet.Attachments[0]);
}
</code></pre>

<p>The <code>autoDecodePayload</code> parameter is <code>true</code> by default.</p>
<ul>
<li>We can replace back the "{'_placeholder':true,'num':xyz}" string to the index of the attachment in the Attachments list.</li>
</ul>
<pre><code class="language-csharp">Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false);

void OnFrame(Socket socket, Packet packet, params object[] args)
{
    // Replace the Json object with the index
    packet.ReconstructAttachmentAsIndex();

    // now, decode the Payload to an object[]
    args = packet.Decode(socket.Manager.Encoder);

    // args now contains only an index number (probably 0)
    byte[] data = packet.Attachments[Convert.ToInt32(args[0])];

    texture.LoadImage(data);
}
</code></pre>

<ul>
<li>We can replace the "{'_placeholder':true,'num':xyz}" string with the binary data from the Attachments converted to a Base64 encoded string. Advanced Json parsers can convert it to byte arrays when they have to set it to an object’s field or property.</li>
</ul>
<pre><code class="language-csharp">Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false);

void OnFrame(Socket socket, Packet packet, params object[] args)
{
    // Replace the Json object with the Base64 encoded string
    packet.ReconstructAttachmentAsBase64();

    // now, decode the Payload to an object[]
    args = packet.Decode(socket.Manager.Encoder);

    // args now contains a Base64 encoded string
    byte[] data = Convert.FromBase64String(args[0] as string);

    texture.LoadImage(data);
}
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../4.DefaultEncoder/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../4.DefaultEncoder/" class="btn btn-xs btn-link">
        Set the default Json encoder
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2.ReceivingEvents/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2.ReceivingEvents/" class="btn btn-xs btn-link">
        Subscribing and receiving events
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>