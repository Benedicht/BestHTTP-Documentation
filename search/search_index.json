{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction BestHTTP/2 is a HTTP/1.1 and HTTP/2 implementation that supports almost all Unity mobile and standalone platforms (see supported platforms ). My goal was to create an easy to use, but still powerful plugin to Unity to take advantage of the potential in HTTP/1.1 and later in HTTP/2. For HTTP requests, the Getting Started Quickly topic is the next recommended reading. Available Addons: TLS Security Addon cURL Parser Addon Online resources A WebGL demo page is available to demonstrate a few capabilities of the plugin. Both the samples and server has its own git repo: Samples repository . All samples are in the plugin's package too. Server repository This document is a quick guide, not all functions and properties can be found here, but suggestions, bugreports and pull-requests are always welcome on the documentation's own github repo . Notice All supported protocols are client implementations only, but all server side solutions (server, framework, cloud hosting, etc.) are supported! Contact For support, feature requests or general questions you can email me at besthttp@gmail.com , join to the plugin's discord server or create a new issue at the public Issues repository .","title":"Introduction"},{"location":"#introduction","text":"BestHTTP/2 is a HTTP/1.1 and HTTP/2 implementation that supports almost all Unity mobile and standalone platforms (see supported platforms ). My goal was to create an easy to use, but still powerful plugin to Unity to take advantage of the potential in HTTP/1.1 and later in HTTP/2. For HTTP requests, the Getting Started Quickly topic is the next recommended reading.","title":"Introduction"},{"location":"#available-addons","text":"TLS Security Addon cURL Parser Addon","title":"Available Addons:"},{"location":"#online-resources","text":"A WebGL demo page is available to demonstrate a few capabilities of the plugin. Both the samples and server has its own git repo: Samples repository . All samples are in the plugin's package too. Server repository This document is a quick guide, not all functions and properties can be found here, but suggestions, bugreports and pull-requests are always welcome on the documentation's own github repo . Notice All supported protocols are client implementations only, but all server side solutions (server, framework, cloud hosting, etc.) are supported!","title":"Online resources"},{"location":"#contact","text":"For support, feature requests or general questions you can email me at besthttp@gmail.com , join to the plugin's discord server or create a new issue at the public Issues repository .","title":"Contact"},{"location":"ThirdPartyNotices/","text":"Third-Party Notices This asset is governed by the Asset Store EULA ; however, the following components are governed by the licenses indicated below: DotNetZip Microsoft Public License (MS-PL) This license governs use of the accompanying software. If you use the software, you accept this license. If you do not accept the license, do not use the software. Definitions The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and \"distribution\" have the same meaning here as under U.S. copyright law. A \"contribution\" is the original software, or any additions or changes to the software. A \"contributor\" is any person that distributes its contribution under this license. \"Licensed patents\" are a contributor's patent claims that read directly on its contribution. Grant of Rights (A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create. (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software. Conditions and Limitations (A) No Trademark License- This license does not grant you rights to use any contributors' name, logo, or trademarks. (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license from such contributor to the software ends automatically. (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are present in the software. (D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may only do so under a license that complies with this license. (E) The software is licensed \"as-is.\" You bear the risk of using it. The contributors give no express warranties, guarantees or conditions. You may have additional consumer rights under your local laws which this license cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement. BouncyCastle MIT Copyright (c) 2000 - 2020 The Legion of the Bouncy Castle Inc. (https://www.bouncycastle.org) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. LitJson Public Domain This is free and unencumbered software released into the public domain. Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means. In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. For more information, please refer to http://unlicense.org/ Thank you for reading this notice. Following the tradition of other public domain projects, here's a blessing: May you find forgiveness for yourself and forgive others. May you experience and share the gift of unconditional love. May you see light, wherever the illusion of darkness appears.","title":"Third-Party Notices"},{"location":"ThirdPartyNotices/#third-party-notices","text":"This asset is governed by the Asset Store EULA ; however, the following components are governed by the licenses indicated below:","title":"Third-Party Notices"},{"location":"ThirdPartyNotices/#dotnetzip","text":"Microsoft Public License (MS-PL) This license governs use of the accompanying software. If you use the software, you accept this license. If you do not accept the license, do not use the software. Definitions The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and \"distribution\" have the same meaning here as under U.S. copyright law. A \"contribution\" is the original software, or any additions or changes to the software. A \"contributor\" is any person that distributes its contribution under this license. \"Licensed patents\" are a contributor's patent claims that read directly on its contribution. Grant of Rights (A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create. (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software. Conditions and Limitations (A) No Trademark License- This license does not grant you rights to use any contributors' name, logo, or trademarks. (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license from such contributor to the software ends automatically. (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are present in the software. (D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may only do so under a license that complies with this license. (E) The software is licensed \"as-is.\" You bear the risk of using it. The contributors give no express warranties, guarantees or conditions. You may have additional consumer rights under your local laws which this license cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement.","title":"DotNetZip"},{"location":"ThirdPartyNotices/#bouncycastle","text":"MIT Copyright (c) 2000 - 2020 The Legion of the Bouncy Castle Inc. (https://www.bouncycastle.org) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"BouncyCastle"},{"location":"ThirdPartyNotices/#litjson","text":"Public Domain This is free and unencumbered software released into the public domain. Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means. In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. For more information, please refer to http://unlicense.org/ Thank you for reading this notice. Following the tradition of other public domain projects, here's a blessing: May you find forgiveness for yourself and forgive others. May you experience and share the gift of unconditional love. May you see light, wherever the illusion of darkness appears.","title":"LitJson"},{"location":"UpgradeGuide/","text":"Upgrade from 1.x to 2.x BestHTTP/2 is a major version upgrade of the Best HTTP (Pro) package. Because folders got renamed and features removed, this upgrade isn't a drop-in replace of the old version. The old /Best HTTP (Pro)/ folder must be deleted before importing the new package. Other breaking changes are: General [ Breaking change ] Removed Statistics API. There's no replacement API for connection releated (active/inactive connections, requests in queue, etc.) statistics. Cookie and cache releated ones can be done through the CookieJar and HTTPCacheService classes. [ Breaking change ] Changed some BouncyCastle related class' namespace to avoid collision with other plugins and SDKs. Namespaces now starts with BestHTTP.SecureProtocol.Org.BouncyCastle. instead of just Org.BouncyCastle. . [ Breaking change ] Rewrote Abort mechanism. This shouldn't be a breaking change per se, but there might be uncaught bugs. [ Breaking change ] Minumum Unity version is now 2017.3 as it's the first version to support .asmdef files. Otherwise the plugin should still work under previous versions too. HTTPRequest [ Breaking change ] New easier to use http streaming API through the OnStreamingData event. So instead of calling GetStreamedFragments periodically in the main callback, error handling in the main callback and data processing can be separated: var request = new HTTPRequest(new Uri(\"...\"), OnRequestFinished); request.OnStreamingData += OnDataDownloaded; void OnDataDownloaded(HTTPRequest request, HTTPResponse response, byte[] data, int dataLength) { this.ProcessedBytes += dataLength; SetDataProcessedUI(this.ProcessedBytes, this.DownloadLength); // TODO: process downloaded data } [ Breaking change ] UseStreaming is an internal property now. When there's a callback specified for OnStreamingData , the request automatically becomes a streaming request. [ Breaking change ] Removed GetStreamedFragments function, use the new OnStreamingData event. [ Breaking change ] Renamed OnProgress to OnDownloadProgress [ Breaking change ] Removed DisableRetry , use MaxRetries instead: var request = new HTTPRequest(new Uri(\"...\"), OnRequestFinished); //request.DisableRetry = true; request.MaxRetries = 0; request.Send(); [ Breaking change ] Removed Priority property [ Breaking change ] Removed TryToMinimizeTCPLatency property, because of the plugin's own buffering mechanism it became an always on setting. [ Breaking change ] Removed HTTPFormUsage.RawJSon support. There's a small example on how a request can be set up to send json with the RawData property. Websocket [ Breaking change ] Removed OnErrorDesc event [ Breaking change ] OnError event now has a string parameter instead of an Exception var webSocket = new WebSocket.WebSocket(new Uri(address)); webSocket.OnError += OnError; void OnError(WebSocket.WebSocket ws, string error) { } SignalR Core [ Breaking change ] Changed up and down streaming API Documentation about the new and changed streaming API can be found in the SignalR Core topics .","title":"UpgradeGuide"},{"location":"UpgradeGuide/#upgrade-from-1x-to-2x","text":"BestHTTP/2 is a major version upgrade of the Best HTTP (Pro) package. Because folders got renamed and features removed, this upgrade isn't a drop-in replace of the old version. The old /Best HTTP (Pro)/ folder must be deleted before importing the new package. Other breaking changes are:","title":"Upgrade from 1.x to 2.x"},{"location":"UpgradeGuide/#general","text":"[ Breaking change ] Removed Statistics API. There's no replacement API for connection releated (active/inactive connections, requests in queue, etc.) statistics. Cookie and cache releated ones can be done through the CookieJar and HTTPCacheService classes. [ Breaking change ] Changed some BouncyCastle related class' namespace to avoid collision with other plugins and SDKs. Namespaces now starts with BestHTTP.SecureProtocol.Org.BouncyCastle. instead of just Org.BouncyCastle. . [ Breaking change ] Rewrote Abort mechanism. This shouldn't be a breaking change per se, but there might be uncaught bugs. [ Breaking change ] Minumum Unity version is now 2017.3 as it's the first version to support .asmdef files. Otherwise the plugin should still work under previous versions too.","title":"General"},{"location":"UpgradeGuide/#httprequest","text":"[ Breaking change ] New easier to use http streaming API through the OnStreamingData event. So instead of calling GetStreamedFragments periodically in the main callback, error handling in the main callback and data processing can be separated: var request = new HTTPRequest(new Uri(\"...\"), OnRequestFinished); request.OnStreamingData += OnDataDownloaded; void OnDataDownloaded(HTTPRequest request, HTTPResponse response, byte[] data, int dataLength) { this.ProcessedBytes += dataLength; SetDataProcessedUI(this.ProcessedBytes, this.DownloadLength); // TODO: process downloaded data } [ Breaking change ] UseStreaming is an internal property now. When there's a callback specified for OnStreamingData , the request automatically becomes a streaming request. [ Breaking change ] Removed GetStreamedFragments function, use the new OnStreamingData event. [ Breaking change ] Renamed OnProgress to OnDownloadProgress [ Breaking change ] Removed DisableRetry , use MaxRetries instead: var request = new HTTPRequest(new Uri(\"...\"), OnRequestFinished); //request.DisableRetry = true; request.MaxRetries = 0; request.Send(); [ Breaking change ] Removed Priority property [ Breaking change ] Removed TryToMinimizeTCPLatency property, because of the plugin's own buffering mechanism it became an always on setting. [ Breaking change ] Removed HTTPFormUsage.RawJSon support. There's a small example on how a request can be set up to send json with the RawData property.","title":"HTTPRequest"},{"location":"UpgradeGuide/#websocket","text":"[ Breaking change ] Removed OnErrorDesc event [ Breaking change ] OnError event now has a string parameter instead of an Exception var webSocket = new WebSocket.WebSocket(new Uri(address)); webSocket.OnError += OnError; void OnError(WebSocket.WebSocket ws, string error) { }","title":"Websocket"},{"location":"UpgradeGuide/#signalr-core","text":"[ Breaking change ] Changed up and down streaming API Documentation about the new and changed streaming API can be found in the SignalR Core topics .","title":"SignalR Core"},{"location":"changelog/","text":"2.5.3 (2021-10-18) General [ Bugfix ] Fixed race condition in the timing api that could result in an exception [ Bugfix ] Resend request with proxy authtentication header when it's a transparent proxy. Possible workaround for waiting for chunked encoded proxy response [ Bugfix ] Possible fix of a race condition in the BufferPool implementation [ Bugfix ] [ISSUE-75] HTTP2Response uses int for contentLength instead of long so doesn't track large (2.1GB+) files [ Improvement ] Dispose implementation overhaul [ Improvement ] Added support for relative redirect urls [ Improvement ] Logging out a BufferSegment now going to log out (part of) the data too [ Improvement ] [WebGL] Add Set-Cookie header ibky when its value isn't empty [ Improvement ] [WebGL] Use the default IO service under WebGL too, but explicitly disable the caching service and cookie saving [ Improvement ] Removed non-used ConcurrentStack file [ Improvement ] Don't keep an HTTP1 connection in the connection pool if the last processed request/response returned max=0 in a Keep-Alive header SignalR Core [ Bugfix ] [Long-Polling transport] Removed fake ping message as it's triggered a client-sent one, that triggered a new fake one, etc. [ Improvement ] [MessagePackProtocol] Added support for parameterless callbacks Websocket [ Bugfix ] [Long-Polling transport] Use WebSocket's MaxFragmentSize in WebSocketResponse Socket.IO 3 [ Bugfix ] Call Dispose on StringReaders 2.5.2 (2021-08-02) General [ Bugfix ] Moved documentation from readthedocs to github pages [ Bugfix ] [WebGL] In some cases XHR_Send called twice [ Improvement ] Return early if base request is cancelled instead of throwing an exception [ Improvement ] Change TCP Client's buffer sizes only when a custom value is set in the HTTPManager [ Improvement ] Sample URL changes HTTP/2 [ Bugfix ] Possible bugfix for a case where Process is called for a request while the handler already shutting down resulting in a NullRef. exception [ Bugfix ] GOAWAY frame's additional data read from the wrong position of the buffer SignalR Core [ Improvement ] Append access_token query param only if there's a negotiated access token [ Bugfix ] Set connectionStartedAt on a reconnect attempt too to avoid an outdated value cancelling authentication requests SocketIO 3 [ Improvement ] [Default Json parser] Catch and log exception when doing ReadParameters 2.5.1 (2021-05-28) General [ Bugfix ] Disabled strack trace collection for BufferPool releases HTTP/2 [ Bugfix ] First request over HTTP/2 doesn't set ProcessingStarted SocketIO 3 [ Bugfix ] [MsgPackParser] Skip object reading when there's no OnError subscriber 2.5.0 (2021-05-17) Websocket [ New Feature ] New Websocket Over HTTP/2 implementation General [ Improvement ] Added log when the DNS query is finished [ Improvement ] Buffer improvements [ Bugfix ] More Unity DateTime locale bug workaround SocketIO 3 [ Bugfix ] Fixed emitting to custom namespaces [ Bugfix ] Default namespace not going to be opened by default SignalR Core [ Improvement ] Added vector serializers compatible with Neuecc's MessagePack implementation [ Bugfix ] Cancel and clear (async) invocations when the connection is closed [ Bugfix ] Fixed case where reconnecting opened more connections 2.4.0 (2021-03-18) General [ Improvement ] Threads are now started as background threads [ Improvement ] Reworked HTTPRequest timeout handling, now callbacks are called almost instantly. [ Improvement ] Moved LitJson to the source folder instead of the examples, now it's under the BestHTTP.JSON namespace. [ Bugfix ] ISSUE-53 Redirect fails when UriBuilder escapes query string in the redirect location Socket.IO 3 [ New Feature ] A new Socket.IO implementation for Socket.IO 3 with strongly typed callbacks ! [ New Feature ] New parser interface to be able to implement parsers other than json [ New Feature ] New MsgPackParser [ Improvement ] Improved documentation SignalR Core [ Bugfix ] [Long-Polling Transport] stream got disposed while the transport tried to reuse it [ Improvement ] Introduced MessagePackProtocolSerializationOptions to be able to change how enums are serialized EventSource [ Bugfix ] [WebGL] Call Close on the browser's EventSource object to prevent its autmatic reconnection HTTP [ Improvement ] [WebGL] UploadStream is now going to be uploaded too. 2.3.2 (2021-01-06) TLS [ New Feature ] TLS Security Addon is now available! [ Bugfix ] Disabled chacha20-poly1305-04 as it seems it has a data corruption bug [ Improvement ] Improved compatibility with other TLS handlers by not aborting the TLS connection if the server sends back an encrypt-then-mac extension when a non blockcipher is selected General [ Bugfix ] Start to count down for a request's timeout when a HTTP1 or 2 handler picks it for processing [ Bugfix ] Caching discarded entities when it has only Cache-Control header with a max-age directive [ Improvement ] An already finished but waiting for processing its callback not going to be aborted by a timeout or direct Abort call [ Improvement ] When wrapping an Exception, AsyncHTTPException's message is going to be the exception's message SocketIO [ Bugfix ] Fixed various issues around custom namespaces SignalR Core [ Improvement ] Send back a ping message if the client received one from the server 2.3.1 (2020-12-14) General [ Bugfix ] Enable cookies in the editor when the WebGL platform is selected [ Bugfix ] Redirect to the same url is now breaks out from the redirect cycle [ Improvement ] DateTime logging changes to workaround a possible Unity issue [ Improvement ] Fixed HeaderParser compatibility with non-conformant headers [ Improvement ] HeaderParser is now used to determine whether a response is cachable to use less cpu and memory [ Improvement ] HTTPRequest 's MaxRedirects' default is now 10 HTTP/2 [ Improvement ] Send ENABLE_PUSH = 0 settings to the server SocketIO [ Bugfix ] The correct EIO version is sent now with the requests [ Improvement ] Changed socket notification about transport open to reduce overhead Websocket [ Improvement ] Don't log error on application quit 2.3.0 (2020-11-23) General [ New Feature ] New Exceptions property for proxies to be able to skip proxy for specified hosts [ Bugfix ] LitJson dictionary (object) instantiation fix [ Bugfix ] HeartbeatManager wasn't cleared on application quit SocketIO [ New Feature ] Support for Socket.IO 3 [ New Feature ] New ServerVersion option that can be set if the server's Socket.IO version is known [ New Feature ] New Auth function to send payload while connecting to a namespace (only with Socket.IO 3) [ Bugfix ] Fixed an issue where reconnection failed if there were an upgrading transport while waiting for reconnect countdown Websocket [ Bugfix ] Fixed typo in CloseAfterNoMesssage SignalR Core [ New Feature ] Added CancellationToken support for InvokeAsync and SendAsync 2.2.2 (2020-10-22) Websocket [ Bugfix ] ServerNoContextTakeover is set to the wrong value in the PerMessageCompression constructor WebGL [ Bugfix ] Fixed case where the response got corrupted 2.2.1 (2020-10-20) TLS [ New Feature ] Added new HTTPManager.TlsClientFactory callback to be able to provide custom Tls clients [ Improvement ] X509Name going to cache ToString result [ Bugfix ] SendCertificateVerifyMessage logged different function name General [ Improvement ] Made HTTPManager.GetRootCacheFolder() public instead of internal [ Improvement ] Switched to all-yellow logging color [ Improvement ] Renamed FileStreamModes.Open to OpenRead and added new OpenReadWrite [ Improvement ] ThreadedLogger 's thread is now named [ Improvement ] Added ExitThreadAfterInactivity to ThreadedLogger [ Bugfix ] Fixed example prefab ( ISSUE-36 ) [ Bugfix ] New Queued HTTPRequest state for possible double send fix ( ISSUE-38 ) HTTP/1 [ Improvement ] Request will send Keep-Alive header to the server to let them know about the client setting HTTP/2 [ Bugfix ] Fixed a possible infinite loop when HTTP2FrameHelper 's StreamRead had to read zero bytes, or when the TCP stream is got closed and stream.Read returns zero [ Improvement ] Removed a few unnecessary instructions from buffer processing Websocket [ Improvement ] Lowered CloseAfterNoMesssage 's default value to 2 seconds [ Bugfix ] Buffer used to masking the frame released back to the BufferPool before the masking itself, resulting in a possible frame corruption [ Bugfix ] Set the websocket's state to Closed on http request error [ Bugfix ] Removed PingFrequency from timeout calculation SignalR Core [ Bugfix ] Fixed issue where calling close on an initial hub connection doesn't lose the connection (and no close callbacks are called either) SocketIO [ Bugfix ] Added missing documentation about SocketOptions ' AdditionalQueryParams WebGL [ Bugfix ] Switch to use the URL class to avoid possible escaping issues [ Improvement ] Response handling speedup by not copying response body 2.2.0 (2020-09-02) TLS [ Improvement ] Bouncy Castle optimizations: depending on the negotiated ciphers download speed can increase and memory hungry parts are also rewritten to use the plugin's BufferPool to decrease GC usage. As parts of the optimizations now the plugin requires the \"Allow 'unsafe' Code\" to be set [ Improvement ] Added the use of Encrypt-then-MAC (RFC 7366) extension [ Improvement ] Added ChaCha20-Poly1305 (RFC 7905 ciphers to the client offered cipher suites to negotiate with the server [ Improvement ] Moved read buffer to the lowest level to reduce context switching when TLS is used, halving reads per TLS message [ Improvement ] Removed an optional error throwing to follow browser behavior General [ New Feature ] New Timing API to measure when request processing spent most of its time [ Improvement ] Changed thread names for HTTP/1 and HTTP/2 threads so they can be identified in the profiler [ Improvement ] Renamed confusing \"Remote server closed the connection before sending response header!\" exception text [ Improvement ] IL2CPP optimizations by adding and using Il2CppSetOptionAttribute and Il2CppEagerStaticClassConstructionAttribute [ Improvement ] Added more places to check request cancellation reducing time requirement in some cases to call the request's callback [ Bugfix ] Fixed compile errors when BESTHTTP_DISABLE_CACHING and/or BESTHTTP_DISABLE_COOKIES is used [ Bugfix ] Fixed a bug where an exception thrown while connecting treated as ConnectionTimedOut [ Bugfix ] When the underlying stream has no more data, ReadOnlyBufferedStream now returns with the value (0 or -1) the stream returned with [ Bugfix ] Fixed compile error using the old runtime [ Bugfix ] Dispose a ManualResetEvent used in DNS querying [ Bugfix ] Test token.IsCancellationRequested before calling final async logic HTTP/1 [ Improvement ] Use the lower value when server provided keep-alive timeout is available. Timeout is set lower then what sent to be more resistant to lag [ Bugfix ] With chunked encoding and gzip combined, when the last chunk contained only the gzip trail or parts of it it got truncated and thrown an exception [ Bugfix ] Fixed bug where redirection occured to the same host while also receiving a Connection: Close header&value resulted in the reuse of the closing connection HTTP/2 [ Improvement ] Suspending a http/2 session's worker thread now going to take account for the disconnect time too. [ Improvement ] Preliminary support for RFC 8441 [ Improvement ] Yandex.ru returned with a FLOW_CONTROL_ERROR(3) error when the plugin tried to set the connection window to the RFC defined maximum (2^31 - 1 bytes). Reducing the default by 10 Mib is sufficent. [ Bugfix ] Various frames' data didn't release back to the BufferPool [ Bugfix ] Ignore RST_STREAM frame when received for a stream with CLOSED state [ Bugfix ] Server's initial window size change wasn't handled possibly limiting upload speed [ Bugfix ] The plugin expected at least 1 byte of data for frames where padding is available corrupting downloaded data where the server inserts frames where only padding is present [ Bugfix ] Fixed a case where the server sent a HTTP/2 GOAWAY frame caused request(s) to get aborted twice SignalR [ Improvement ] Moved unnecessary logging behind a log level check SignalR Core [ Improvement ] Added support to be able to serialize floats. SocketIO [ New Feature ] [ ISSUE-25 ] HTTPRequestCustomizationCallback implementation Websocket [ Improvement ] Made the WebSocketResponse 's MaxFragmentSize public and changed its type to int. Now it can be accessed and modified on non-WebGL platforms 2.1.0 (2020-06-29) General [ New Feature ] Structured logging to be able to better track parallel requests. [ New Feature ] New threaded logger. [ New Feature ] New logging model to support output selection (file, unity's Debug.log, etc.) without changing the logger. [ Improvement ] New AsyncHTTPException added to be able to access the Status Code of the server's response. [ Improvement ] The HTTPUpdateDelegator going to be hidden in the inspector [ Improvement ] HTTPManager's IsQuitting is now public [ Improvement ] A few functions in the HTTPCacheService and HTTPCacheFileInfo became public. [ Improvement ] Textures loaded through HTTPResponse's DataAsTexture now going to be marked as non-readable. [ Improvement ] Made public all EventHelper classes (in the BestHTTP.Core namespace) to be able to subscribe to OnEvent callbacks. [ Improvement ] Added Third-Party Notices.txt and a similar entry in the documentation. [ Bugfix ] [ ISSUE-10 ] Fixed a case where HTTPRequest's async isn't returned when called with an already canceled cancellation token [ Bugfix ] Fixed a name collusion that produced an [Error] Failed to call static function Reset because an object was provided error in the editor. [ Bugfix ] Fixes for Configurable Enter Play Mode. [ Bugfix ] Moved SetSocketOption into the nearest try-catch block. It should workaround a rare Unity error where setting KeepAlive on the socket level throws an exception under UWP. [ Bugfix ] The plugin no longer going to reuse memory assigned to HTTPRequest's RawData. [ Bugfix ] HTTPCacheService's DeleteEntity now going to be trigger a save library event [ Bugfix ] Switched to Write locks in HTTPCacheService's SaveLibrary to prevent parallel executions HTTP/2 [ New Feature ] [ ISSUE-15 ] Trailing headers support. [ Improvement ] Log unexpected exceptions only when the plugin isn't shutting down [ Improvement ] Log unhandled frames [ Improvement ] To fix long-polling request issues over HTTP/2, the plugin no longer closes HTTP/2 streames after 30 seconds when it stays in HalfClosedLocal state. SignalR Core [ New Feature ] [ ISSUE-5 ] Implemented connection timeout. However, all IAuthenticationProvider now requires to implement the Cancel method too. [ New Feature ] GetUpStreamController and GetUpAndDownStreamController now can send non-streaming parameters too. [ New Feature ] HubOptions now has a new PingTimeoutInterval . [ Improvement ] Improved the default authenticator to also set the access_token parameter under WebGL [ Improvement ] Authentication providers now will receive a real websocket url (one that starts with ws:// or wss://) in their PrepareUri to be able to differentiate between HTTP and WebSocket [ Bugfix ] Send/Invoke tasks don't complete if not connected [ Bugfix ] Fixed timeout by making it dependent on received messages instead of sent messages. [ Bugfix ] Pings are not sent by the server for the long-polling transport, so every successful response generates one. Websocket [ Bugfix ] [ ISSUE-14 ] Disposing newFrameSignal wasn't thread safe [ Bugfix ] InternalRequest is now aborted if Close called while connecting. [ Improvement ] Fixed OnError double checking and reduced it to an else one. Server-Sent Events [ New Feature ] Added new OnComment event that will be called for comments sent by the server. [ Improvement ] Reduced EnqueueProtocolEvent calls when one chunk of data result in more than one events. [ Bugfix ] It now registers as a protocol and receives cancel requests on shutdown. 2.0.6 (2020-04-15) General [ Bugfix ] [ ISSUE-3 ] HTTP/1 - Aborts & timeouts are handled only when there's activity on the handler's thread [ Bugfix ] Fixed a memory leak of the TCP stream SignalR Core [ Bugfix ] [ ISSUE-4 ] Fixed race condition in HubConnection's CloseAsync [ Bugfix ] When the application is quitting HubConnection is going to report a normal closure now SocketIO [ Bugfix ] Fixed a bug where reconnecting while waiting for a pong message prevented all further ping messages HTTP/2 [ Bugfix ] Fixed a NullReferenceException when the server sends no initial settings. [ Bugfix ] Fixed a case where streaming was on and the HTTP2Stream closed itself because of a timeout [ Bugfix ] Moved clean-up code into one place and AutoResetEvent's close is called when both threads are closed insted of the HTTP2Handler's dispose as it might be called sooner while the AutoResetEvent still in use [ Bugfix ] Request's state is now properly set to TimedOut instead of just Aborted to mach behavior of the HTTP/1 implementation 2.0.5 (2020-03-18) General [ Bugfix ] Fixed an out of bounds exception in the StreamList (used by FileConnection) class [ Improvement ] StreamList now Disposes wrapped streams on the go SignalR Core [ Bugfix ] Implemented a workaround for UriBuilder behavior on Query building [ Bugfix ] [MessagePack Protocol] Fixed a bug in ReadArguments target is unknown [ Bugfix ] [MessagePack Protocol] BufferPoolMemoryStream now can expand when the initial buffer isn't enough [ Bugfix ] [MessagePack Protocol] Fixed ReadVarInt as it returned a wrong value [ Improvement ] [MessagePack Protocol] Type information no longer serialized [ Improvement ] [MessagePack Protocol] Implemented a new MessagePackExtensionTypeHandler to follow the msgpack spec on sending DateTime Websocket [ Bugfix ] newFrameSignal going to be disposed when all threads are finished HTTP/2 [ Bugfix ] Fixed an issue in the frame view that caused issues when received compressed data. Examples [ New Feature ] New MultipartFormDataStream implementation to send streams as multiform/form-data encoded. 2.0.4 (2020-02-11) General [ New Feature ] Possible to override read buffer size through the ReadBufferSizeOverride property [ Bugfix ] Long running streaming requests' state set to Timeout instead of Abort when aborted [ Bugfix ] Fixed a StackOverflowException when read buffer was larger than StreamFragmentSize [ Bugfix ] When ConfigureAwait set to false, HTTPResponse's Dispose may called before acccessing Data [ Bugfix ] Fixed case to avoid overwriting already set cookie name and value [ Bugfix ] Fixed a memory leak where HostConnection's CloseConnectionAfterInactivity is added back to the Timer [ Bugfix ] Fixed compiler warning when BESTHTTP_DISABLE_HTTP2 is in use [ Bugfix ] Don't process cached alt-svc header [ Bugfix ] HTTPResponse's RawData no longer pooled [ Improvement ] Run IsCachedEntityExpiresInTheFuture check before anything else to do not open a TCP channel to the server [ Improvement ] Added \"samesite\" cookie parsing [ Improvement ] Log out connector Connect exceptions when log level set to All [ Improvement ] Refresh data on disk when the stored and downloaded data length differs [ Improvement ] Call TryToStore on a status code of 304 too [ Improvement ] Small improvement to allocate less memory per frame in the Timer.cs [ Improvement ] Cache-Control Stale-On-Error implementation [ Improvement ] It can handle multiple Cache-Control headers now HTTP/2 [ Improvement ] Retry added for requests whose started already when the connection is closed [ Bugfix ] Some requests stuck when their processing started but the connections is closed [ Bugfix ] Stream id was a static field, instead of a per-connection one [ Bugfix ] Fixed a case where the reading thread didn't close [ Bugfix ] Send lower-case header names [ Bugfix ] Keep around a canceled request's stream to receive and process the server-sent headers. Otherwise the HPACK encoder remains in a faulty state [ Bugfix ] Aborting a request while processing its header/data frames before the HTTP2Stream's Process set the request's State to Finished, while its result remained null [ Bugfix ] Added logging for a possible content-length parse error case SignalR Core [ New Feature ] New ConnectAsync , CloseAsync , InvokeAsync and SendAsync functions. [ New Feature ] New sample to demonstrate the usage of the new *Async functions [ Bugfix ] In some cases the HubConnection remained open while received an error using the Long-Polling transport. [ Improvement ] New NegotiationResponse property added to the NegotiationResult class. It's a HTTPResponse object reference to the last /negotiate request. SocketIO [ Improvement ] New \"reconnect_before_offline_packets\" event. [ Bugfix ] Do not delete offline packets on each reconnect attempt Server-Sent Events [ New Feature ] New constructor parameter to override default read buffer size on non-WebGL builds when the server sends data non-chunked 2.0.3 (2019-12-06) General [ Improvement ] Reworked response reading to do not depend on StreamFragmentSize for download progress reporting [ Improvement ] HTTPResponse.MinBufferSize renamed to MinReadBufferSize [ Improvement ] VersionMajor and VersionMinor now set for HTTPResponse when it was created from a HTTP/2 connection too [ Improvement ] Merged recent LitJson changes HTTP/2 [ New Feature ] Implemented upload streaming and upload progress reporting SignalR Core [ New Feature ] Implemented MessagePack protocol using the Json & MessagePack Serialization Unity Asset Store package [ Improvement ] Under WebGL built with Unity 2019.2 Uri's IsAbsoluteUri returns the wrong value [ Bugfix ] Redirect uri's query parameters are removed while parsing and/or adding the negotiateVersion query param [ Bugfix ] LongPolling now handles the handshake response Websocket [ Bugfix ] OnClose event called more than once 2.0.2 (2019-11-22) General [ Bugfix ] HostConnection's AddProtocol didn't set the new known protocol causing request processing delays in some cases [ Bugfix ] Parts of the SignalR samples are back [ Bugfix ] Fixed compile errors when specific plugin defines are added [ Improvement ] Improved CookieJar's domain matching HTTP/2 [ New Feature ] Added PingFrequency option to HTTPManager.HTTP2Settings [ Bugfix ] Pong messages didn't send back the server's payload [ Bugfix ] HTTP2Handler used HTTPManager.MaxConnectionIdleTime instead of HTTPManager.HTTP2Settings.MaxIdleTime SignalR Core [ New Feature ] LongPolling transport added [ New Feature ] Automatic transport downgrade 2.0.1 (2019-11-17) HTTP/2 [ Bugfix ] \"host\" header must not sent in a HTTP/2 request General [ Bugfix ] Request's Response can be null when the ConnectionHelper tries to determine whether the connection can be kept open Socket.IO [ Bugfix ] Fixed an error that thrown when the packet's payload contained unicode characters. [ Bugfix ] Fixed error packet deserialization when the code field isn't an integer SignalR Core [ Bugfix ] Fixed compile errors when BESTHTTP_DISABLE_WEBSOCKET present [ New Feature ] Added support for allowReconnect in the close message (ASP.Net 3.1 feature) 2.0.0 (2019-10-31) Warning This is a major release breaking backward compatibility with older releases. See the Upgrade Guide for more details! General [ New Feature ] Added Application-Layer Protocol Negotiation support to the BouncyCastle lib [ New Feature ] HTTP/2 Support added [ New Feature ] New HTTP2Settings property added to the HTTPManager class [ New Feature ] Initial implementation of HTTP Alternate Services [ New Feature ] Added support for Unity 2019.3's (experimental) Enter Play Mode options [ New Feature ] Added Assembly Definition file to reduce recompile times [ Improvement ] Rewrote threading to avoid race conditions and reduce locking by using concurrent queues and lightweight ReaderWriterLockSlim s instead of lock blocks. [ Improvement ] New online documentation [ Breaking change ] Removed Statistics API [ Breaking change ] Changed some BouncyCastle related class' namespace to avoid collition with other plugins and SDKs [ Breaking change ] Rewrote Abort mechanism [ Breaking change ] Minumum Unity version is now 2017.3 [ Bugfix ] When the plugin is forced to use url-encoded form with binary data, it will base64 encode the data first HTTPRequest [ Breaking change ] New easier to use http streaming API through the OnStreamingData event [ Breaking change ] Renamed OnProgress to OnDownloadProgress [ Breaking change ] Removed DisableRetry , use MaxRetries instead [ Breaking change ] Removed Priority property [ Breaking change ] Removed TryToMinimizeTCPLatency property [ Breaking change ] Removed GetStreamedFragments function, use the new OnStreamingData event [ Breaking change ] Removed HTTPFormUsage.RawJSon support Server-Sent Events [ Improvement ] Rewrote implementation to support Server-Sent Events over HTTP/2 SocketIO [ Improvement ] Improved compatibility with newer WebAssembly runtime Websocket [ Breaking change ] Removed OnErrorDesc event [ Breaking change ] OnError event now has a string parameter instead of an Exception SignalR Core [ New Feature ] Added automatic reconnection support through the new IRetryPolicy interface [ Improvement ] Improved ASP.Net Core 3 compatibility [ Breaking change ] Changed up and down streaming API","title":"Changelog"},{"location":"changelog/#253-2021-10-18","text":"General [ Bugfix ] Fixed race condition in the timing api that could result in an exception [ Bugfix ] Resend request with proxy authtentication header when it's a transparent proxy. Possible workaround for waiting for chunked encoded proxy response [ Bugfix ] Possible fix of a race condition in the BufferPool implementation [ Bugfix ] [ISSUE-75] HTTP2Response uses int for contentLength instead of long so doesn't track large (2.1GB+) files [ Improvement ] Dispose implementation overhaul [ Improvement ] Added support for relative redirect urls [ Improvement ] Logging out a BufferSegment now going to log out (part of) the data too [ Improvement ] [WebGL] Add Set-Cookie header ibky when its value isn't empty [ Improvement ] [WebGL] Use the default IO service under WebGL too, but explicitly disable the caching service and cookie saving [ Improvement ] Removed non-used ConcurrentStack file [ Improvement ] Don't keep an HTTP1 connection in the connection pool if the last processed request/response returned max=0 in a Keep-Alive header SignalR Core [ Bugfix ] [Long-Polling transport] Removed fake ping message as it's triggered a client-sent one, that triggered a new fake one, etc. [ Improvement ] [MessagePackProtocol] Added support for parameterless callbacks Websocket [ Bugfix ] [Long-Polling transport] Use WebSocket's MaxFragmentSize in WebSocketResponse Socket.IO 3 [ Bugfix ] Call Dispose on StringReaders","title":"2.5.3 (2021-10-18)"},{"location":"changelog/#252-2021-08-02","text":"General [ Bugfix ] Moved documentation from readthedocs to github pages [ Bugfix ] [WebGL] In some cases XHR_Send called twice [ Improvement ] Return early if base request is cancelled instead of throwing an exception [ Improvement ] Change TCP Client's buffer sizes only when a custom value is set in the HTTPManager [ Improvement ] Sample URL changes HTTP/2 [ Bugfix ] Possible bugfix for a case where Process is called for a request while the handler already shutting down resulting in a NullRef. exception [ Bugfix ] GOAWAY frame's additional data read from the wrong position of the buffer SignalR Core [ Improvement ] Append access_token query param only if there's a negotiated access token [ Bugfix ] Set connectionStartedAt on a reconnect attempt too to avoid an outdated value cancelling authentication requests SocketIO 3 [ Improvement ] [Default Json parser] Catch and log exception when doing ReadParameters","title":"2.5.2 (2021-08-02)"},{"location":"changelog/#251-2021-05-28","text":"General [ Bugfix ] Disabled strack trace collection for BufferPool releases HTTP/2 [ Bugfix ] First request over HTTP/2 doesn't set ProcessingStarted SocketIO 3 [ Bugfix ] [MsgPackParser] Skip object reading when there's no OnError subscriber","title":"2.5.1 (2021-05-28)"},{"location":"changelog/#250-2021-05-17","text":"Websocket [ New Feature ] New Websocket Over HTTP/2 implementation General [ Improvement ] Added log when the DNS query is finished [ Improvement ] Buffer improvements [ Bugfix ] More Unity DateTime locale bug workaround SocketIO 3 [ Bugfix ] Fixed emitting to custom namespaces [ Bugfix ] Default namespace not going to be opened by default SignalR Core [ Improvement ] Added vector serializers compatible with Neuecc's MessagePack implementation [ Bugfix ] Cancel and clear (async) invocations when the connection is closed [ Bugfix ] Fixed case where reconnecting opened more connections","title":"2.5.0 (2021-05-17)"},{"location":"changelog/#240-2021-03-18","text":"General [ Improvement ] Threads are now started as background threads [ Improvement ] Reworked HTTPRequest timeout handling, now callbacks are called almost instantly. [ Improvement ] Moved LitJson to the source folder instead of the examples, now it's under the BestHTTP.JSON namespace. [ Bugfix ] ISSUE-53 Redirect fails when UriBuilder escapes query string in the redirect location Socket.IO 3 [ New Feature ] A new Socket.IO implementation for Socket.IO 3 with strongly typed callbacks ! [ New Feature ] New parser interface to be able to implement parsers other than json [ New Feature ] New MsgPackParser [ Improvement ] Improved documentation SignalR Core [ Bugfix ] [Long-Polling Transport] stream got disposed while the transport tried to reuse it [ Improvement ] Introduced MessagePackProtocolSerializationOptions to be able to change how enums are serialized EventSource [ Bugfix ] [WebGL] Call Close on the browser's EventSource object to prevent its autmatic reconnection HTTP [ Improvement ] [WebGL] UploadStream is now going to be uploaded too.","title":"2.4.0 (2021-03-18)"},{"location":"changelog/#232-2021-01-06","text":"TLS [ New Feature ] TLS Security Addon is now available! [ Bugfix ] Disabled chacha20-poly1305-04 as it seems it has a data corruption bug [ Improvement ] Improved compatibility with other TLS handlers by not aborting the TLS connection if the server sends back an encrypt-then-mac extension when a non blockcipher is selected General [ Bugfix ] Start to count down for a request's timeout when a HTTP1 or 2 handler picks it for processing [ Bugfix ] Caching discarded entities when it has only Cache-Control header with a max-age directive [ Improvement ] An already finished but waiting for processing its callback not going to be aborted by a timeout or direct Abort call [ Improvement ] When wrapping an Exception, AsyncHTTPException's message is going to be the exception's message SocketIO [ Bugfix ] Fixed various issues around custom namespaces SignalR Core [ Improvement ] Send back a ping message if the client received one from the server","title":"2.3.2 (2021-01-06)"},{"location":"changelog/#231-2020-12-14","text":"General [ Bugfix ] Enable cookies in the editor when the WebGL platform is selected [ Bugfix ] Redirect to the same url is now breaks out from the redirect cycle [ Improvement ] DateTime logging changes to workaround a possible Unity issue [ Improvement ] Fixed HeaderParser compatibility with non-conformant headers [ Improvement ] HeaderParser is now used to determine whether a response is cachable to use less cpu and memory [ Improvement ] HTTPRequest 's MaxRedirects' default is now 10 HTTP/2 [ Improvement ] Send ENABLE_PUSH = 0 settings to the server SocketIO [ Bugfix ] The correct EIO version is sent now with the requests [ Improvement ] Changed socket notification about transport open to reduce overhead Websocket [ Improvement ] Don't log error on application quit","title":"2.3.1 (2020-12-14)"},{"location":"changelog/#230-2020-11-23","text":"General [ New Feature ] New Exceptions property for proxies to be able to skip proxy for specified hosts [ Bugfix ] LitJson dictionary (object) instantiation fix [ Bugfix ] HeartbeatManager wasn't cleared on application quit SocketIO [ New Feature ] Support for Socket.IO 3 [ New Feature ] New ServerVersion option that can be set if the server's Socket.IO version is known [ New Feature ] New Auth function to send payload while connecting to a namespace (only with Socket.IO 3) [ Bugfix ] Fixed an issue where reconnection failed if there were an upgrading transport while waiting for reconnect countdown Websocket [ Bugfix ] Fixed typo in CloseAfterNoMesssage SignalR Core [ New Feature ] Added CancellationToken support for InvokeAsync and SendAsync","title":"2.3.0 (2020-11-23)"},{"location":"changelog/#222-2020-10-22","text":"Websocket [ Bugfix ] ServerNoContextTakeover is set to the wrong value in the PerMessageCompression constructor WebGL [ Bugfix ] Fixed case where the response got corrupted","title":"2.2.2 (2020-10-22)"},{"location":"changelog/#221-2020-10-20","text":"TLS [ New Feature ] Added new HTTPManager.TlsClientFactory callback to be able to provide custom Tls clients [ Improvement ] X509Name going to cache ToString result [ Bugfix ] SendCertificateVerifyMessage logged different function name General [ Improvement ] Made HTTPManager.GetRootCacheFolder() public instead of internal [ Improvement ] Switched to all-yellow logging color [ Improvement ] Renamed FileStreamModes.Open to OpenRead and added new OpenReadWrite [ Improvement ] ThreadedLogger 's thread is now named [ Improvement ] Added ExitThreadAfterInactivity to ThreadedLogger [ Bugfix ] Fixed example prefab ( ISSUE-36 ) [ Bugfix ] New Queued HTTPRequest state for possible double send fix ( ISSUE-38 ) HTTP/1 [ Improvement ] Request will send Keep-Alive header to the server to let them know about the client setting HTTP/2 [ Bugfix ] Fixed a possible infinite loop when HTTP2FrameHelper 's StreamRead had to read zero bytes, or when the TCP stream is got closed and stream.Read returns zero [ Improvement ] Removed a few unnecessary instructions from buffer processing Websocket [ Improvement ] Lowered CloseAfterNoMesssage 's default value to 2 seconds [ Bugfix ] Buffer used to masking the frame released back to the BufferPool before the masking itself, resulting in a possible frame corruption [ Bugfix ] Set the websocket's state to Closed on http request error [ Bugfix ] Removed PingFrequency from timeout calculation SignalR Core [ Bugfix ] Fixed issue where calling close on an initial hub connection doesn't lose the connection (and no close callbacks are called either) SocketIO [ Bugfix ] Added missing documentation about SocketOptions ' AdditionalQueryParams WebGL [ Bugfix ] Switch to use the URL class to avoid possible escaping issues [ Improvement ] Response handling speedup by not copying response body","title":"2.2.1 (2020-10-20)"},{"location":"changelog/#220-2020-09-02","text":"TLS [ Improvement ] Bouncy Castle optimizations: depending on the negotiated ciphers download speed can increase and memory hungry parts are also rewritten to use the plugin's BufferPool to decrease GC usage. As parts of the optimizations now the plugin requires the \"Allow 'unsafe' Code\" to be set [ Improvement ] Added the use of Encrypt-then-MAC (RFC 7366) extension [ Improvement ] Added ChaCha20-Poly1305 (RFC 7905 ciphers to the client offered cipher suites to negotiate with the server [ Improvement ] Moved read buffer to the lowest level to reduce context switching when TLS is used, halving reads per TLS message [ Improvement ] Removed an optional error throwing to follow browser behavior General [ New Feature ] New Timing API to measure when request processing spent most of its time [ Improvement ] Changed thread names for HTTP/1 and HTTP/2 threads so they can be identified in the profiler [ Improvement ] Renamed confusing \"Remote server closed the connection before sending response header!\" exception text [ Improvement ] IL2CPP optimizations by adding and using Il2CppSetOptionAttribute and Il2CppEagerStaticClassConstructionAttribute [ Improvement ] Added more places to check request cancellation reducing time requirement in some cases to call the request's callback [ Bugfix ] Fixed compile errors when BESTHTTP_DISABLE_CACHING and/or BESTHTTP_DISABLE_COOKIES is used [ Bugfix ] Fixed a bug where an exception thrown while connecting treated as ConnectionTimedOut [ Bugfix ] When the underlying stream has no more data, ReadOnlyBufferedStream now returns with the value (0 or -1) the stream returned with [ Bugfix ] Fixed compile error using the old runtime [ Bugfix ] Dispose a ManualResetEvent used in DNS querying [ Bugfix ] Test token.IsCancellationRequested before calling final async logic HTTP/1 [ Improvement ] Use the lower value when server provided keep-alive timeout is available. Timeout is set lower then what sent to be more resistant to lag [ Bugfix ] With chunked encoding and gzip combined, when the last chunk contained only the gzip trail or parts of it it got truncated and thrown an exception [ Bugfix ] Fixed bug where redirection occured to the same host while also receiving a Connection: Close header&value resulted in the reuse of the closing connection HTTP/2 [ Improvement ] Suspending a http/2 session's worker thread now going to take account for the disconnect time too. [ Improvement ] Preliminary support for RFC 8441 [ Improvement ] Yandex.ru returned with a FLOW_CONTROL_ERROR(3) error when the plugin tried to set the connection window to the RFC defined maximum (2^31 - 1 bytes). Reducing the default by 10 Mib is sufficent. [ Bugfix ] Various frames' data didn't release back to the BufferPool [ Bugfix ] Ignore RST_STREAM frame when received for a stream with CLOSED state [ Bugfix ] Server's initial window size change wasn't handled possibly limiting upload speed [ Bugfix ] The plugin expected at least 1 byte of data for frames where padding is available corrupting downloaded data where the server inserts frames where only padding is present [ Bugfix ] Fixed a case where the server sent a HTTP/2 GOAWAY frame caused request(s) to get aborted twice SignalR [ Improvement ] Moved unnecessary logging behind a log level check SignalR Core [ Improvement ] Added support to be able to serialize floats. SocketIO [ New Feature ] [ ISSUE-25 ] HTTPRequestCustomizationCallback implementation Websocket [ Improvement ] Made the WebSocketResponse 's MaxFragmentSize public and changed its type to int. Now it can be accessed and modified on non-WebGL platforms","title":"2.2.0 (2020-09-02)"},{"location":"changelog/#210-2020-06-29","text":"General [ New Feature ] Structured logging to be able to better track parallel requests. [ New Feature ] New threaded logger. [ New Feature ] New logging model to support output selection (file, unity's Debug.log, etc.) without changing the logger. [ Improvement ] New AsyncHTTPException added to be able to access the Status Code of the server's response. [ Improvement ] The HTTPUpdateDelegator going to be hidden in the inspector [ Improvement ] HTTPManager's IsQuitting is now public [ Improvement ] A few functions in the HTTPCacheService and HTTPCacheFileInfo became public. [ Improvement ] Textures loaded through HTTPResponse's DataAsTexture now going to be marked as non-readable. [ Improvement ] Made public all EventHelper classes (in the BestHTTP.Core namespace) to be able to subscribe to OnEvent callbacks. [ Improvement ] Added Third-Party Notices.txt and a similar entry in the documentation. [ Bugfix ] [ ISSUE-10 ] Fixed a case where HTTPRequest's async isn't returned when called with an already canceled cancellation token [ Bugfix ] Fixed a name collusion that produced an [Error] Failed to call static function Reset because an object was provided error in the editor. [ Bugfix ] Fixes for Configurable Enter Play Mode. [ Bugfix ] Moved SetSocketOption into the nearest try-catch block. It should workaround a rare Unity error where setting KeepAlive on the socket level throws an exception under UWP. [ Bugfix ] The plugin no longer going to reuse memory assigned to HTTPRequest's RawData. [ Bugfix ] HTTPCacheService's DeleteEntity now going to be trigger a save library event [ Bugfix ] Switched to Write locks in HTTPCacheService's SaveLibrary to prevent parallel executions HTTP/2 [ New Feature ] [ ISSUE-15 ] Trailing headers support. [ Improvement ] Log unexpected exceptions only when the plugin isn't shutting down [ Improvement ] Log unhandled frames [ Improvement ] To fix long-polling request issues over HTTP/2, the plugin no longer closes HTTP/2 streames after 30 seconds when it stays in HalfClosedLocal state. SignalR Core [ New Feature ] [ ISSUE-5 ] Implemented connection timeout. However, all IAuthenticationProvider now requires to implement the Cancel method too. [ New Feature ] GetUpStreamController and GetUpAndDownStreamController now can send non-streaming parameters too. [ New Feature ] HubOptions now has a new PingTimeoutInterval . [ Improvement ] Improved the default authenticator to also set the access_token parameter under WebGL [ Improvement ] Authentication providers now will receive a real websocket url (one that starts with ws:// or wss://) in their PrepareUri to be able to differentiate between HTTP and WebSocket [ Bugfix ] Send/Invoke tasks don't complete if not connected [ Bugfix ] Fixed timeout by making it dependent on received messages instead of sent messages. [ Bugfix ] Pings are not sent by the server for the long-polling transport, so every successful response generates one. Websocket [ Bugfix ] [ ISSUE-14 ] Disposing newFrameSignal wasn't thread safe [ Bugfix ] InternalRequest is now aborted if Close called while connecting. [ Improvement ] Fixed OnError double checking and reduced it to an else one. Server-Sent Events [ New Feature ] Added new OnComment event that will be called for comments sent by the server. [ Improvement ] Reduced EnqueueProtocolEvent calls when one chunk of data result in more than one events. [ Bugfix ] It now registers as a protocol and receives cancel requests on shutdown.","title":"2.1.0 (2020-06-29)"},{"location":"changelog/#206-2020-04-15","text":"General [ Bugfix ] [ ISSUE-3 ] HTTP/1 - Aborts & timeouts are handled only when there's activity on the handler's thread [ Bugfix ] Fixed a memory leak of the TCP stream SignalR Core [ Bugfix ] [ ISSUE-4 ] Fixed race condition in HubConnection's CloseAsync [ Bugfix ] When the application is quitting HubConnection is going to report a normal closure now SocketIO [ Bugfix ] Fixed a bug where reconnecting while waiting for a pong message prevented all further ping messages HTTP/2 [ Bugfix ] Fixed a NullReferenceException when the server sends no initial settings. [ Bugfix ] Fixed a case where streaming was on and the HTTP2Stream closed itself because of a timeout [ Bugfix ] Moved clean-up code into one place and AutoResetEvent's close is called when both threads are closed insted of the HTTP2Handler's dispose as it might be called sooner while the AutoResetEvent still in use [ Bugfix ] Request's state is now properly set to TimedOut instead of just Aborted to mach behavior of the HTTP/1 implementation","title":"2.0.6 (2020-04-15)"},{"location":"changelog/#205-2020-03-18","text":"General [ Bugfix ] Fixed an out of bounds exception in the StreamList (used by FileConnection) class [ Improvement ] StreamList now Disposes wrapped streams on the go SignalR Core [ Bugfix ] Implemented a workaround for UriBuilder behavior on Query building [ Bugfix ] [MessagePack Protocol] Fixed a bug in ReadArguments target is unknown [ Bugfix ] [MessagePack Protocol] BufferPoolMemoryStream now can expand when the initial buffer isn't enough [ Bugfix ] [MessagePack Protocol] Fixed ReadVarInt as it returned a wrong value [ Improvement ] [MessagePack Protocol] Type information no longer serialized [ Improvement ] [MessagePack Protocol] Implemented a new MessagePackExtensionTypeHandler to follow the msgpack spec on sending DateTime Websocket [ Bugfix ] newFrameSignal going to be disposed when all threads are finished HTTP/2 [ Bugfix ] Fixed an issue in the frame view that caused issues when received compressed data. Examples [ New Feature ] New MultipartFormDataStream implementation to send streams as multiform/form-data encoded.","title":"2.0.5 (2020-03-18)"},{"location":"changelog/#204-2020-02-11","text":"General [ New Feature ] Possible to override read buffer size through the ReadBufferSizeOverride property [ Bugfix ] Long running streaming requests' state set to Timeout instead of Abort when aborted [ Bugfix ] Fixed a StackOverflowException when read buffer was larger than StreamFragmentSize [ Bugfix ] When ConfigureAwait set to false, HTTPResponse's Dispose may called before acccessing Data [ Bugfix ] Fixed case to avoid overwriting already set cookie name and value [ Bugfix ] Fixed a memory leak where HostConnection's CloseConnectionAfterInactivity is added back to the Timer [ Bugfix ] Fixed compiler warning when BESTHTTP_DISABLE_HTTP2 is in use [ Bugfix ] Don't process cached alt-svc header [ Bugfix ] HTTPResponse's RawData no longer pooled [ Improvement ] Run IsCachedEntityExpiresInTheFuture check before anything else to do not open a TCP channel to the server [ Improvement ] Added \"samesite\" cookie parsing [ Improvement ] Log out connector Connect exceptions when log level set to All [ Improvement ] Refresh data on disk when the stored and downloaded data length differs [ Improvement ] Call TryToStore on a status code of 304 too [ Improvement ] Small improvement to allocate less memory per frame in the Timer.cs [ Improvement ] Cache-Control Stale-On-Error implementation [ Improvement ] It can handle multiple Cache-Control headers now HTTP/2 [ Improvement ] Retry added for requests whose started already when the connection is closed [ Bugfix ] Some requests stuck when their processing started but the connections is closed [ Bugfix ] Stream id was a static field, instead of a per-connection one [ Bugfix ] Fixed a case where the reading thread didn't close [ Bugfix ] Send lower-case header names [ Bugfix ] Keep around a canceled request's stream to receive and process the server-sent headers. Otherwise the HPACK encoder remains in a faulty state [ Bugfix ] Aborting a request while processing its header/data frames before the HTTP2Stream's Process set the request's State to Finished, while its result remained null [ Bugfix ] Added logging for a possible content-length parse error case SignalR Core [ New Feature ] New ConnectAsync , CloseAsync , InvokeAsync and SendAsync functions. [ New Feature ] New sample to demonstrate the usage of the new *Async functions [ Bugfix ] In some cases the HubConnection remained open while received an error using the Long-Polling transport. [ Improvement ] New NegotiationResponse property added to the NegotiationResult class. It's a HTTPResponse object reference to the last /negotiate request. SocketIO [ Improvement ] New \"reconnect_before_offline_packets\" event. [ Bugfix ] Do not delete offline packets on each reconnect attempt Server-Sent Events [ New Feature ] New constructor parameter to override default read buffer size on non-WebGL builds when the server sends data non-chunked","title":"2.0.4 (2020-02-11)"},{"location":"changelog/#203-2019-12-06","text":"General [ Improvement ] Reworked response reading to do not depend on StreamFragmentSize for download progress reporting [ Improvement ] HTTPResponse.MinBufferSize renamed to MinReadBufferSize [ Improvement ] VersionMajor and VersionMinor now set for HTTPResponse when it was created from a HTTP/2 connection too [ Improvement ] Merged recent LitJson changes HTTP/2 [ New Feature ] Implemented upload streaming and upload progress reporting SignalR Core [ New Feature ] Implemented MessagePack protocol using the Json & MessagePack Serialization Unity Asset Store package [ Improvement ] Under WebGL built with Unity 2019.2 Uri's IsAbsoluteUri returns the wrong value [ Bugfix ] Redirect uri's query parameters are removed while parsing and/or adding the negotiateVersion query param [ Bugfix ] LongPolling now handles the handshake response Websocket [ Bugfix ] OnClose event called more than once","title":"2.0.3 (2019-12-06)"},{"location":"changelog/#202-2019-11-22","text":"General [ Bugfix ] HostConnection's AddProtocol didn't set the new known protocol causing request processing delays in some cases [ Bugfix ] Parts of the SignalR samples are back [ Bugfix ] Fixed compile errors when specific plugin defines are added [ Improvement ] Improved CookieJar's domain matching HTTP/2 [ New Feature ] Added PingFrequency option to HTTPManager.HTTP2Settings [ Bugfix ] Pong messages didn't send back the server's payload [ Bugfix ] HTTP2Handler used HTTPManager.MaxConnectionIdleTime instead of HTTPManager.HTTP2Settings.MaxIdleTime SignalR Core [ New Feature ] LongPolling transport added [ New Feature ] Automatic transport downgrade","title":"2.0.2 (2019-11-22)"},{"location":"changelog/#201-2019-11-17","text":"HTTP/2 [ Bugfix ] \"host\" header must not sent in a HTTP/2 request General [ Bugfix ] Request's Response can be null when the ConnectionHelper tries to determine whether the connection can be kept open Socket.IO [ Bugfix ] Fixed an error that thrown when the packet's payload contained unicode characters. [ Bugfix ] Fixed error packet deserialization when the code field isn't an integer SignalR Core [ Bugfix ] Fixed compile errors when BESTHTTP_DISABLE_WEBSOCKET present [ New Feature ] Added support for allowReconnect in the close message (ASP.Net 3.1 feature)","title":"2.0.1 (2019-11-17)"},{"location":"changelog/#200-2019-10-31","text":"Warning This is a major release breaking backward compatibility with older releases. See the Upgrade Guide for more details! General [ New Feature ] Added Application-Layer Protocol Negotiation support to the BouncyCastle lib [ New Feature ] HTTP/2 Support added [ New Feature ] New HTTP2Settings property added to the HTTPManager class [ New Feature ] Initial implementation of HTTP Alternate Services [ New Feature ] Added support for Unity 2019.3's (experimental) Enter Play Mode options [ New Feature ] Added Assembly Definition file to reduce recompile times [ Improvement ] Rewrote threading to avoid race conditions and reduce locking by using concurrent queues and lightweight ReaderWriterLockSlim s instead of lock blocks. [ Improvement ] New online documentation [ Breaking change ] Removed Statistics API [ Breaking change ] Changed some BouncyCastle related class' namespace to avoid collition with other plugins and SDKs [ Breaking change ] Rewrote Abort mechanism [ Breaking change ] Minumum Unity version is now 2017.3 [ Bugfix ] When the plugin is forced to use url-encoded form with binary data, it will base64 encode the data first HTTPRequest [ Breaking change ] New easier to use http streaming API through the OnStreamingData event [ Breaking change ] Renamed OnProgress to OnDownloadProgress [ Breaking change ] Removed DisableRetry , use MaxRetries instead [ Breaking change ] Removed Priority property [ Breaking change ] Removed TryToMinimizeTCPLatency property [ Breaking change ] Removed GetStreamedFragments function, use the new OnStreamingData event [ Breaking change ] Removed HTTPFormUsage.RawJSon support Server-Sent Events [ Improvement ] Rewrote implementation to support Server-Sent Events over HTTP/2 SocketIO [ Improvement ] Improved compatibility with newer WebAssembly runtime Websocket [ Breaking change ] Removed OnErrorDesc event [ Breaking change ] OnError event now has a string parameter instead of an Exception SignalR Core [ New Feature ] Added automatic reconnection support through the new IRetryPolicy interface [ Improvement ] Improved ASP.Net Core 3 compatibility [ Breaking change ] Changed up and down streaming API","title":"2.0.0 (2019-10-31)"},{"location":"platforms/","text":"Supported platforms and their limitations iOS No platform specific bugs or limitations are known. Android To enable stripping link_android_subset.xml in the \\Assets\\Best HTTP\\ folder should be used by renaming to link.xml. Universal Windows Platform The native https handler can\u2019t connect to custom ports. If you want to connect to a custom port using https you have to use the plugin\u2019s alternate https handler by setting the request\u2019s UseAlternateSSL to true. WebGL In WebGL builds the plugin will use the underlying browser\u2019s XmlHTTPRequest implementation. Because of this, there are features that isn\u2019t available: Cookies has limited support Caching Download and upload streaming doesn't work as XmlHTTPRequest buffers all data Proxy Server Certificate Validation Redirection Control These limitations may change in a future update of the plugin. If you make requests to another server that your WebGL build is loaded from the remote server must set some headers to enable the requests. For more details you can start reading on the Wikipedia page of CORS . Other limitations HTTPS On Android, iOS and desktop platforms .net\u2019s Net SslStream are used for HTTPS. This can handle a wide range of certificates, however there are some that can fail with. To give an alternate solution BouncyCastle are bundled in the plugin, you can use it by setting the UseAlternateSSL to true on your HTTPRequest object. But it can fail on some certifications too. On Windows Phone 8.1(and greater) and on WinRT(Windows Store Apps) a secure, Tls 1.2 protocol will handle the connection. HTTP/2 Retry mechanism isn't implemented","title":"Platforms"},{"location":"platforms/#supported-platforms-and-their-limitations","text":"iOS No platform specific bugs or limitations are known. Android To enable stripping link_android_subset.xml in the \\Assets\\Best HTTP\\ folder should be used by renaming to link.xml. Universal Windows Platform The native https handler can\u2019t connect to custom ports. If you want to connect to a custom port using https you have to use the plugin\u2019s alternate https handler by setting the request\u2019s UseAlternateSSL to true. WebGL In WebGL builds the plugin will use the underlying browser\u2019s XmlHTTPRequest implementation. Because of this, there are features that isn\u2019t available: Cookies has limited support Caching Download and upload streaming doesn't work as XmlHTTPRequest buffers all data Proxy Server Certificate Validation Redirection Control These limitations may change in a future update of the plugin. If you make requests to another server that your WebGL build is loaded from the remote server must set some headers to enable the requests. For more details you can start reading on the Wikipedia page of CORS .","title":"Supported platforms and their limitations"},{"location":"platforms/#other-limitations","text":"HTTPS On Android, iOS and desktop platforms .net\u2019s Net SslStream are used for HTTPS. This can handle a wide range of certificates, however there are some that can fail with. To give an alternate solution BouncyCastle are bundled in the plugin, you can use it by setting the UseAlternateSSL to true on your HTTPRequest object. But it can fail on some certifications too. On Windows Phone 8.1(and greater) and on WinRT(Windows Store Apps) a secure, Tls 1.2 protocol will handle the connection. HTTP/2 Retry mechanism isn't implemented","title":"Other limitations"},{"location":"1.HTTP/GettingStarted/","text":"Getting Started Quickly After you imported the package, you should add a using statement to your source file like any other regular usings: using BestHTTP; GET Requests The simplest way to do a request to a web server is to create a HTTPRequest object providing the url and a callback function to it's constructor. After we constructed a new HTTPRequest object the only thing we need to do, is actually send the request with the Send() function. Let's see an example: HTTPRequest request = new HTTPRequest(new Uri(\"https://google.com\"), OnRequestFinished); request.Send(); The OnRequestFinished() function's implementation might be this: void OnRequestFinished(HTTPRequest request, HTTPResponse response) { Debug.Log(\"Request Finished! Text received: \" + response.DataAsText); } As you can see the callback function always receives the original HTTPRequest object and an HTTPResponse object that holds the response from the server. The HTTPResponse object is null if there were an error and the request object has an Exception property that might carry extra information about the error if there were any. While the requests are always processed on separate threads, calling the callback function is done on Unity's main thread, so we don't have to do any thread synchronization. If we want to write more compact code we can use c#'s lambda expressions. In this example we don't even need a temporary variable: new HTTPRequest(new Uri(\"https://google.com\"), (request, response) => Debug.Log(\"Finished!\")) .Send(); Notice Error handling is omitted for brevity in most of the samples through the documentation, but there's a complete section dedicated to error handling . POST Requests The above examples were simple GET requests. If we don\u2019t specify the method, all requests will be GET requests by default. The constructor has another parameter that can be used to specify the method of the request: HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); request.AddField(\"FieldName\", \"Field Value\"); request.Send(); To POST any data without setting a field you can use the RawData property: HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); request.RawData = Encoding.UTF8.GetBytes(\"Field Value\"); request.Send(); For additional samples check out the Small Code-Samples section . Beside GET and POST you can use the HEAD, PUT, DELETE and PATCH methods as well: Head Requests HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Head, OnRequestFinished); request.Send(); Put Requests HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Put, OnRequestFinished); request.Send(); Delete Requests HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Delete, OnRequestFinished); request.Send(); Patch Requests HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Patch, OnRequestFinished); request.Send(); How To Access The Downloaded Data Most of the time we use our requests to receive some data from a server. The raw bytes can be accessed from the HTTPResponse object's Data property. Let's see an example how to download an image: new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"), (request, response) => { var tex = new Texture2D(0, 0); tex.LoadImage(response.Data); guiTexture.texture = tex; }).Send(); Beside of DataAsTexture2D there is a DataAsText property too to decode the response as an Utf8 string. Warning All examples in this document are without any error checking! See the Error Handling topic ! More Examples More examples and sample code snippets can be found under the Small Code-Samples topic, like How to send binary data in a Form How to send JSON data How to access response headers","title":"Getting Started Quickly"},{"location":"1.HTTP/GettingStarted/#getting-started-quickly","text":"After you imported the package, you should add a using statement to your source file like any other regular usings: using BestHTTP;","title":"Getting Started Quickly"},{"location":"1.HTTP/GettingStarted/#get-requests","text":"The simplest way to do a request to a web server is to create a HTTPRequest object providing the url and a callback function to it's constructor. After we constructed a new HTTPRequest object the only thing we need to do, is actually send the request with the Send() function. Let's see an example: HTTPRequest request = new HTTPRequest(new Uri(\"https://google.com\"), OnRequestFinished); request.Send(); The OnRequestFinished() function's implementation might be this: void OnRequestFinished(HTTPRequest request, HTTPResponse response) { Debug.Log(\"Request Finished! Text received: \" + response.DataAsText); } As you can see the callback function always receives the original HTTPRequest object and an HTTPResponse object that holds the response from the server. The HTTPResponse object is null if there were an error and the request object has an Exception property that might carry extra information about the error if there were any. While the requests are always processed on separate threads, calling the callback function is done on Unity's main thread, so we don't have to do any thread synchronization. If we want to write more compact code we can use c#'s lambda expressions. In this example we don't even need a temporary variable: new HTTPRequest(new Uri(\"https://google.com\"), (request, response) => Debug.Log(\"Finished!\")) .Send(); Notice Error handling is omitted for brevity in most of the samples through the documentation, but there's a complete section dedicated to error handling .","title":"GET Requests"},{"location":"1.HTTP/GettingStarted/#post-requests","text":"The above examples were simple GET requests. If we don\u2019t specify the method, all requests will be GET requests by default. The constructor has another parameter that can be used to specify the method of the request: HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); request.AddField(\"FieldName\", \"Field Value\"); request.Send(); To POST any data without setting a field you can use the RawData property: HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); request.RawData = Encoding.UTF8.GetBytes(\"Field Value\"); request.Send(); For additional samples check out the Small Code-Samples section . Beside GET and POST you can use the HEAD, PUT, DELETE and PATCH methods as well:","title":"POST Requests"},{"location":"1.HTTP/GettingStarted/#head-requests","text":"HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Head, OnRequestFinished); request.Send();","title":"Head Requests"},{"location":"1.HTTP/GettingStarted/#put-requests","text":"HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Put, OnRequestFinished); request.Send();","title":"Put Requests"},{"location":"1.HTTP/GettingStarted/#delete-requests","text":"HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Delete, OnRequestFinished); request.Send();","title":"Delete Requests"},{"location":"1.HTTP/GettingStarted/#patch-requests","text":"HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Patch, OnRequestFinished); request.Send();","title":"Patch Requests"},{"location":"1.HTTP/GettingStarted/#how-to-access-the-downloaded-data","text":"Most of the time we use our requests to receive some data from a server. The raw bytes can be accessed from the HTTPResponse object's Data property. Let's see an example how to download an image: new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"), (request, response) => { var tex = new Texture2D(0, 0); tex.LoadImage(response.Data); guiTexture.texture = tex; }).Send(); Beside of DataAsTexture2D there is a DataAsText property too to decode the response as an Utf8 string. Warning All examples in this document are without any error checking! See the Error Handling topic !","title":"How To Access The Downloaded Data"},{"location":"1.HTTP/GettingStarted/#more-examples","text":"More examples and sample code snippets can be found under the Small Code-Samples topic, like How to send binary data in a Form How to send JSON data How to access response headers","title":"More Examples"},{"location":"1.HTTP/HTTPRequest/","text":"Here are the complete list of usable constructors, functions and properties. Constructors HTTPRequest(Uri uri) : Creates a new HTTPRequest object to access the given resource with a GET request. This constructor can be used with Async-Await . var request = new HTTPRequest(new Uri(\"https://example.org\")); HTTPRequest(Uri uri, OnRequestFinishedDelegate callback) : Creates a new HTTPRequest object to access the given resource with a GET request. When finished, the given callback will be called. var request = new HTTPRequest(new Uri(\"https://example.org\"), callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } HTTPRequest(Uri uri, bool isKeepAlive, OnRequestFinishedDelegate callback) : Same as the previous, but with an additional hint that we don't want to reuse the TCP connection. (Keep alive setting is ignored when the client can negotiate a HTTP/2 connection .) var request = new HTTPRequest(new Uri(\"https://example.org\"), isKeepAlive: false, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } Notice isKeepAlive is just a hint. For example if the plugin can negotiate a HTTP/2 connection, it's still going to keep the connection alive. HTTPRequest(Uri uri, bool isKeepAlive, bool disableCache, OnRequestFinishedDelegate callback) : Same as the previous, but the plugin will not try to load the content from the cache and saving to the cache is ignored too. var request = new HTTPRequest(new Uri(\"https://example.org\"), isKeepAlive: true, disableCache: false, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } HTTPRequest(Uri uri, HTTPMethods methodType) : Creates a new HTTPRequest object to access the given resource using the given method(HEAD, GET, POST, PUT, DELETE, PATCH, MERGE, OPTIONS). This constructor can be used with Async-Await . var request = new HTTPRequest(new Uri(\"https://example.org\"), methodType: HTTPMethods.Post); HTTPRequest(Uri uri, HTTPMethods methodType, OnRequestFinishedDelegate callback) : Creates a new HTTPRequest object to access the given resource using the given method(HEAD, GET, POST, PUT, DELETE, PATCH, MERGE, OPTIONS). When finished, the given callback will be called. var request = new HTTPRequest(new Uri(\"https://example.org\"), methodType: HTTPMethods.Post, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } HTTPRequest(Uri uri, HTTPMethods methodType, bool isKeepAlive, OnRequestFinishedDelegate callback) : Same as the previous, but with an additional hint that we don't want to reuse the TCP connection. (Keep alive setting is ignored when the client can negotiate a HTTP/2 connection .) var request = new HTTPRequest(new Uri(\"https://example.org\"), methodType: HTTPMethods.Post, isKeepAlive: false, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } HTTPRequest(Uri uri, HTTPMethods methodType, bool isKeepAlive, bool disableCache, OnRequestFinishedDelegate callback) : Same as the previous, but the plugin will not try to load the content from the cache and saving to the cache is ignored too. var request = new HTTPRequest(new Uri(\"https://example.org\"), methodType: HTTPMethods.Post, isKeepAlive: false, disableCache: true, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } Properties Uri Uri : The original request the HTTPRequest is created with. Uri RedirectUri : The Uri that the request redirected to. Uri CurrentUri : Returns with RedirectUri if IsRedirected is true, returns with the original Uri otherwise. bool IsRedirected : Indicates that the request is redirected. HTTPMethods MethodType : The method that how we want to process our request the server. byte[] RawData : The raw data to send in a POST request. If it set all other fields that added to this request will be ignored. Stream UploadStream : The stream that the plugin will use to get the data to send out the server. When this property is set, no forms or the RawData property will be used. bool DisposeUploadStream : When set to true(its default value) the plugin will call the UploadStream's Dispose() function when finished uploading the data from it. Default value is true. bool UseUploadStreamLength : If it's true, the plugin will use the Stream's Length property. Otherwise the plugin will send the data chunked. Default value is true. bool IsKeepAlive : Indicates that the connection should be open after the response received. If its true, then the internal TCP connections will be reused if it's possible. Default value is true. The default value can be changed in the HTTPManager class. If you make rare request to the server it's should be changed to false. bool DisableCache : With this property caching can be enabled/disabled on a per-request basis. bool CacheOnly : It can be used with streaming. When set to true, no OnStreamingData event is called, the streamed content will be saved straight to the cache if all requirements are met(caching is enabled and there's a caching headers). int StreamFragmentSize : Maximum size of a data chunk that we want to receive when streaming is set. Its default value is 1 MB. bool StreamChunksImmediately : When set to true, StreamFragmentSize will be ignored and downloaded chunks will be sent immediately. int ReadBufferSizeOverride : This property can be used to force the HTTPRequest to use an exact sized read buffer. int MaxFragmentQueueLength : Maximum unprocessed fragments allowed to queue up. DateTime ProcessingStarted : When the processing of the request started. bool IsTimedOut : Returns true if the time passed the Timeout setting since processing started. int Retries : Number of times that the plugin retried the request. int MaxRetries : Maximum number of tries allowed. To disable it set to 0. Its default value is 1 for GET requests, otherwise 0. bool IsCancellationRequested : True if Abort() is called on this request. HTTPResponse Response : The response to the query. It can be null when the request times out, aborted, there's connection issues, etc. HTTPResponse ProxyResponse : Response from the Proxy server. It's null with transparent proxies. Exception Exception : It there is an exception while processing the request or response the Response property will be null, and the Exception will be stored in this property. For more information see the Error Handling topic. object Tag : Any object can be passed with the request with this property, the plugin doesn't overwrites it. (eq. it can be identified, etc.) Credentials Credentials : The UserName, Password pair that the plugin will use to authenticate to the remote server with HTTP Authentication. The plugin supports Basic and Digest HTTP authentication. bool HasProxy : True, if there is a Proxy object set for the Proxy property. Proxy Proxy : A web proxy 's properties where the request must pass through. int MaxRedirects : How many redirection supported for this request. The default is int.MaxValue. 0 or a negative value means no redirection supported. bool UseAlternateSSL : Use Bouncy Castle's code to handle the secure protocol instead of Mono's. Its default value is true. Read more about HTTPS . Notice If there's an active connection to the server the plugin doesn't check what SSL/TLS handler is used for that connection, bool IsCookiesEnabled : If true cookies will be added to the headers (if any), and parsed from the response. If false, all cookie operations will be ignored. It's default value is HTTPManager 's IsCookiesEnabled . List<Cookie> Cookies : Cookies that are added to this list will be sent to the server alongside withe the server sent ones. If cookies are disabled only these cookies will be sent. HTTPFormUsage FormUsage : What form should used. Its default value is Automatic. HTTPRequestStates State : Current state of this request. int RedirectCount : How many times the request redirected. Func<HTTPRequest, System.Security.Cryptography.X509Certificates.X509Certificate, System.Security.Cryptography.X509Certificates.X509Chain, bool> CustomCertificationValidator : Custom validator for an SslStream. This event will receive the original HTTPRequest, an X509Certificate and an X509Chain objects. It must return true if the certificate valid, false otherwise. It's not available when UseAlternateSSL is true and on some platforms! TimeSpan ConnectTimeout : Maximum time we wait to establish the connection to the target server. If set to TimeSpan.Zero or lower, no connect timeout logic is executed. Default value is 20 seconds. TimeSpan Timeout : Maximum time we want to wait to the request to finish after the connection is established. Default value is 60 seconds. It's disabled for streaming requests! See EnableTimoutForStreaming . bool EnableTimoutForStreaming : Set to true to enable Timeouts on streaming request. Default value is false. bool EnableSafeReadOnUnknownContentLength : Enables safe read method when the response's length of the content is unknown. Its default value is enabled (true). SecureProtocol.Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer CustomCertificateVerifyer : The ICertificateVerifyer implementation that the plugin will use to verify the server certificates when the request's UseAlternateSSL property is set to true. SecureProtocol.Org.BouncyCastle.Crypto.Tls.IClientCredentialsProvider CustomClientCredentialsProvider : The IClientCredentialsProvider implementation that the plugin will use to send client certificates when the request's UseAlternateSSL property is set to true. List<string> CustomTLSServerNameList : With this property custom Server Name Indication entries can be sent to the server while negotiating TLS. All added entries must conform to the rules defined in RFC 3546 , the plugin will not check the entries' validity! This list will be sent to every server that the plugin must connect to while it tries to finish the request. So for example if redirected to an another server, that new server will receive this list too! LoggingContext Context : Logging context of the request. TimingCollector Timing : Timing information . WithCredentials : Its value will be set to the XmlHTTPRequest 's withCredentials field. Its default value is HTTPManager.IsCookiesEnabled 's value. It's WebGL only. Events Action<HTTPRequest, HTTPResponse> OnHeadersReceived : This event is called when the plugin received and parsed all headers. OnBeforeRedirectionDelegate OnBeforeRedirection : It's called before the plugin will do a new request to the new uri. The return value of this function will control the redirection: if it's false the redirection is aborted. This function is called on a thread other than the main Unity thread! OnBeforeHeaderSendDelegate OnBeforeHeaderSend : This event will be fired before the plugin will write headers to the wire. New headers can be added in this callback. This event is called on a non-Unity thread! OnRequestFinishedDelegate Callback : The callback function that will be called when a request is fully processed or when any downloaded fragment is available if UseStreaming is true. Can be null for fire-and-forget requests. OnDownloadProgressDelegate OnDownloadProgress : Called when new data downloaded from the server. The first parameter is the original HTTTPRequest object itself, the second parameter is the downloaded bytes while the third parameter is the content length. Notice There are download modes where we can't figure out the exact length of the final content. In these cases we just guarantee that the third parameter will be at least the size of the second one. OnStreamingDataDelegate OnStreamingData : Called for every fragment of data downloaded from the server. Return true if dataFrament is processed and the plugin can recycle the byte[] . OnUploadProgressDelegate OnUploadProgress : Called after every chunk of data sent out to the wire. Form Functions HTTP defines two types of form encoding: URL Encoded and Multipart Forms . The plugin supports both of them and selects the most performing one automatically. Sometime servers supports one specific encoding only and expects data in that one encoding. In this case the FormUsage property can be used to force the plugin to use that encoding method for the request: var request = new HTTPRequest(new Uri(\"https://httpbin.org/post\"), HTTPMethods.Post, OnRequestFinished); request.AddField(\"field name\", \"field value\"); request.FormUsage = BestHTTP.Forms.HTTPFormUsage.Multipart; request.Send(); Notice These functions can be used to send form s, sending JSon or any other data the RawData or UploadStream properties can be used! void AddField(string fieldName, string value) : Add a field with a given string value. void AddField(string fieldName, string value, System.Text.Encoding e) : Add a field with a given string value. The plugin going to send encoding information too. void AddBinaryData(string fieldName, byte[] content) : Add a field with binary content to the form. void AddBinaryData(string fieldName, byte[] content, string fileName) :Add a field with binary content to the form. void AddBinaryData(string fieldName, byte[] content, string fileName, string mimeType) : Add a field with binary content to the form. void SetForm(HTTPFormBase form) : Manually set a HTTP Form. List<HTTPFieldData> GetFormFields() : Returns with the added form-fields or null if no one added. void ClearForm() : Clears all data from the form. Header Functions Long headers can be sent as one or more headers (for example the server might send multiple set-cookie headers), hence the plugin stores them in a list and GetHeaderValues returns with it. To help work with them easier, GetFirstHeaderValue returns with the first value from the list. This can be used when we know that the server going to send only one header. void AddHeader(string name, string value) : Adds a header and value pair to the Headers. Use it to add custom headers to the request. void SetHeader(string name, string value) : Removes any previously added values, and sets the given one. bool RemoveHeader(string name) : Removes the specified header. Returns true, if the header found and succesfully removed. bool HasHeader(string name) : Returns true if the given head name is already in the Headers. string GetFirstHeaderValue(string name) : Returns the first header or null for the given header name. List<string> GetHeaderValues(string name) : Returns all header values for the given header or null. void RemoveHeaders() : Removes all headers. Range Header Functions Range headers can be used to resume to an unfinished download, download only parts of a (large) content or download multiple parts in parallel. void SetRangeHeader(long firstBytePos) : Sets the Range header to download the content from the given byte position. See RFC 2616 . void SetRangeHeader(long firstBytePos, long lastBytePos) : Sets the Range header to download the content from the given byte position to the given last position. See RFC 2616 . Other Functions HTTPRequest Send() : Starts processing the request. void Abort() : Aborts an already established connection, so no further download or upload are done. void Clear() : Resets the request for a state where switching MethodType is possible.","title":"HTTPRequest"},{"location":"1.HTTP/HTTPRequest/#constructors","text":"HTTPRequest(Uri uri) : Creates a new HTTPRequest object to access the given resource with a GET request. This constructor can be used with Async-Await . var request = new HTTPRequest(new Uri(\"https://example.org\")); HTTPRequest(Uri uri, OnRequestFinishedDelegate callback) : Creates a new HTTPRequest object to access the given resource with a GET request. When finished, the given callback will be called. var request = new HTTPRequest(new Uri(\"https://example.org\"), callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } HTTPRequest(Uri uri, bool isKeepAlive, OnRequestFinishedDelegate callback) : Same as the previous, but with an additional hint that we don't want to reuse the TCP connection. (Keep alive setting is ignored when the client can negotiate a HTTP/2 connection .) var request = new HTTPRequest(new Uri(\"https://example.org\"), isKeepAlive: false, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } Notice isKeepAlive is just a hint. For example if the plugin can negotiate a HTTP/2 connection, it's still going to keep the connection alive. HTTPRequest(Uri uri, bool isKeepAlive, bool disableCache, OnRequestFinishedDelegate callback) : Same as the previous, but the plugin will not try to load the content from the cache and saving to the cache is ignored too. var request = new HTTPRequest(new Uri(\"https://example.org\"), isKeepAlive: true, disableCache: false, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } HTTPRequest(Uri uri, HTTPMethods methodType) : Creates a new HTTPRequest object to access the given resource using the given method(HEAD, GET, POST, PUT, DELETE, PATCH, MERGE, OPTIONS). This constructor can be used with Async-Await . var request = new HTTPRequest(new Uri(\"https://example.org\"), methodType: HTTPMethods.Post); HTTPRequest(Uri uri, HTTPMethods methodType, OnRequestFinishedDelegate callback) : Creates a new HTTPRequest object to access the given resource using the given method(HEAD, GET, POST, PUT, DELETE, PATCH, MERGE, OPTIONS). When finished, the given callback will be called. var request = new HTTPRequest(new Uri(\"https://example.org\"), methodType: HTTPMethods.Post, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } HTTPRequest(Uri uri, HTTPMethods methodType, bool isKeepAlive, OnRequestFinishedDelegate callback) : Same as the previous, but with an additional hint that we don't want to reuse the TCP connection. (Keep alive setting is ignored when the client can negotiate a HTTP/2 connection .) var request = new HTTPRequest(new Uri(\"https://example.org\"), methodType: HTTPMethods.Post, isKeepAlive: false, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { } HTTPRequest(Uri uri, HTTPMethods methodType, bool isKeepAlive, bool disableCache, OnRequestFinishedDelegate callback) : Same as the previous, but the plugin will not try to load the content from the cache and saving to the cache is ignored too. var request = new HTTPRequest(new Uri(\"https://example.org\"), methodType: HTTPMethods.Post, isKeepAlive: false, disableCache: true, callback: OnRequestFinished); void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { }","title":"Constructors"},{"location":"1.HTTP/HTTPRequest/#properties","text":"Uri Uri : The original request the HTTPRequest is created with. Uri RedirectUri : The Uri that the request redirected to. Uri CurrentUri : Returns with RedirectUri if IsRedirected is true, returns with the original Uri otherwise. bool IsRedirected : Indicates that the request is redirected. HTTPMethods MethodType : The method that how we want to process our request the server. byte[] RawData : The raw data to send in a POST request. If it set all other fields that added to this request will be ignored. Stream UploadStream : The stream that the plugin will use to get the data to send out the server. When this property is set, no forms or the RawData property will be used. bool DisposeUploadStream : When set to true(its default value) the plugin will call the UploadStream's Dispose() function when finished uploading the data from it. Default value is true. bool UseUploadStreamLength : If it's true, the plugin will use the Stream's Length property. Otherwise the plugin will send the data chunked. Default value is true. bool IsKeepAlive : Indicates that the connection should be open after the response received. If its true, then the internal TCP connections will be reused if it's possible. Default value is true. The default value can be changed in the HTTPManager class. If you make rare request to the server it's should be changed to false. bool DisableCache : With this property caching can be enabled/disabled on a per-request basis. bool CacheOnly : It can be used with streaming. When set to true, no OnStreamingData event is called, the streamed content will be saved straight to the cache if all requirements are met(caching is enabled and there's a caching headers). int StreamFragmentSize : Maximum size of a data chunk that we want to receive when streaming is set. Its default value is 1 MB. bool StreamChunksImmediately : When set to true, StreamFragmentSize will be ignored and downloaded chunks will be sent immediately. int ReadBufferSizeOverride : This property can be used to force the HTTPRequest to use an exact sized read buffer. int MaxFragmentQueueLength : Maximum unprocessed fragments allowed to queue up. DateTime ProcessingStarted : When the processing of the request started. bool IsTimedOut : Returns true if the time passed the Timeout setting since processing started. int Retries : Number of times that the plugin retried the request. int MaxRetries : Maximum number of tries allowed. To disable it set to 0. Its default value is 1 for GET requests, otherwise 0. bool IsCancellationRequested : True if Abort() is called on this request. HTTPResponse Response : The response to the query. It can be null when the request times out, aborted, there's connection issues, etc. HTTPResponse ProxyResponse : Response from the Proxy server. It's null with transparent proxies. Exception Exception : It there is an exception while processing the request or response the Response property will be null, and the Exception will be stored in this property. For more information see the Error Handling topic. object Tag : Any object can be passed with the request with this property, the plugin doesn't overwrites it. (eq. it can be identified, etc.) Credentials Credentials : The UserName, Password pair that the plugin will use to authenticate to the remote server with HTTP Authentication. The plugin supports Basic and Digest HTTP authentication. bool HasProxy : True, if there is a Proxy object set for the Proxy property. Proxy Proxy : A web proxy 's properties where the request must pass through. int MaxRedirects : How many redirection supported for this request. The default is int.MaxValue. 0 or a negative value means no redirection supported. bool UseAlternateSSL : Use Bouncy Castle's code to handle the secure protocol instead of Mono's. Its default value is true. Read more about HTTPS . Notice If there's an active connection to the server the plugin doesn't check what SSL/TLS handler is used for that connection, bool IsCookiesEnabled : If true cookies will be added to the headers (if any), and parsed from the response. If false, all cookie operations will be ignored. It's default value is HTTPManager 's IsCookiesEnabled . List<Cookie> Cookies : Cookies that are added to this list will be sent to the server alongside withe the server sent ones. If cookies are disabled only these cookies will be sent. HTTPFormUsage FormUsage : What form should used. Its default value is Automatic. HTTPRequestStates State : Current state of this request. int RedirectCount : How many times the request redirected. Func<HTTPRequest, System.Security.Cryptography.X509Certificates.X509Certificate, System.Security.Cryptography.X509Certificates.X509Chain, bool> CustomCertificationValidator : Custom validator for an SslStream. This event will receive the original HTTPRequest, an X509Certificate and an X509Chain objects. It must return true if the certificate valid, false otherwise. It's not available when UseAlternateSSL is true and on some platforms! TimeSpan ConnectTimeout : Maximum time we wait to establish the connection to the target server. If set to TimeSpan.Zero or lower, no connect timeout logic is executed. Default value is 20 seconds. TimeSpan Timeout : Maximum time we want to wait to the request to finish after the connection is established. Default value is 60 seconds. It's disabled for streaming requests! See EnableTimoutForStreaming . bool EnableTimoutForStreaming : Set to true to enable Timeouts on streaming request. Default value is false. bool EnableSafeReadOnUnknownContentLength : Enables safe read method when the response's length of the content is unknown. Its default value is enabled (true). SecureProtocol.Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer CustomCertificateVerifyer : The ICertificateVerifyer implementation that the plugin will use to verify the server certificates when the request's UseAlternateSSL property is set to true. SecureProtocol.Org.BouncyCastle.Crypto.Tls.IClientCredentialsProvider CustomClientCredentialsProvider : The IClientCredentialsProvider implementation that the plugin will use to send client certificates when the request's UseAlternateSSL property is set to true. List<string> CustomTLSServerNameList : With this property custom Server Name Indication entries can be sent to the server while negotiating TLS. All added entries must conform to the rules defined in RFC 3546 , the plugin will not check the entries' validity! This list will be sent to every server that the plugin must connect to while it tries to finish the request. So for example if redirected to an another server, that new server will receive this list too! LoggingContext Context : Logging context of the request. TimingCollector Timing : Timing information . WithCredentials : Its value will be set to the XmlHTTPRequest 's withCredentials field. Its default value is HTTPManager.IsCookiesEnabled 's value. It's WebGL only.","title":"Properties"},{"location":"1.HTTP/HTTPRequest/#events","text":"Action<HTTPRequest, HTTPResponse> OnHeadersReceived : This event is called when the plugin received and parsed all headers. OnBeforeRedirectionDelegate OnBeforeRedirection : It's called before the plugin will do a new request to the new uri. The return value of this function will control the redirection: if it's false the redirection is aborted. This function is called on a thread other than the main Unity thread! OnBeforeHeaderSendDelegate OnBeforeHeaderSend : This event will be fired before the plugin will write headers to the wire. New headers can be added in this callback. This event is called on a non-Unity thread! OnRequestFinishedDelegate Callback : The callback function that will be called when a request is fully processed or when any downloaded fragment is available if UseStreaming is true. Can be null for fire-and-forget requests. OnDownloadProgressDelegate OnDownloadProgress : Called when new data downloaded from the server. The first parameter is the original HTTTPRequest object itself, the second parameter is the downloaded bytes while the third parameter is the content length. Notice There are download modes where we can't figure out the exact length of the final content. In these cases we just guarantee that the third parameter will be at least the size of the second one. OnStreamingDataDelegate OnStreamingData : Called for every fragment of data downloaded from the server. Return true if dataFrament is processed and the plugin can recycle the byte[] . OnUploadProgressDelegate OnUploadProgress : Called after every chunk of data sent out to the wire.","title":"Events"},{"location":"1.HTTP/HTTPRequest/#form-functions","text":"HTTP defines two types of form encoding: URL Encoded and Multipart Forms . The plugin supports both of them and selects the most performing one automatically. Sometime servers supports one specific encoding only and expects data in that one encoding. In this case the FormUsage property can be used to force the plugin to use that encoding method for the request: var request = new HTTPRequest(new Uri(\"https://httpbin.org/post\"), HTTPMethods.Post, OnRequestFinished); request.AddField(\"field name\", \"field value\"); request.FormUsage = BestHTTP.Forms.HTTPFormUsage.Multipart; request.Send(); Notice These functions can be used to send form s, sending JSon or any other data the RawData or UploadStream properties can be used! void AddField(string fieldName, string value) : Add a field with a given string value. void AddField(string fieldName, string value, System.Text.Encoding e) : Add a field with a given string value. The plugin going to send encoding information too. void AddBinaryData(string fieldName, byte[] content) : Add a field with binary content to the form. void AddBinaryData(string fieldName, byte[] content, string fileName) :Add a field with binary content to the form. void AddBinaryData(string fieldName, byte[] content, string fileName, string mimeType) : Add a field with binary content to the form. void SetForm(HTTPFormBase form) : Manually set a HTTP Form. List<HTTPFieldData> GetFormFields() : Returns with the added form-fields or null if no one added. void ClearForm() : Clears all data from the form.","title":"Form Functions"},{"location":"1.HTTP/HTTPRequest/#header-functions","text":"Long headers can be sent as one or more headers (for example the server might send multiple set-cookie headers), hence the plugin stores them in a list and GetHeaderValues returns with it. To help work with them easier, GetFirstHeaderValue returns with the first value from the list. This can be used when we know that the server going to send only one header. void AddHeader(string name, string value) : Adds a header and value pair to the Headers. Use it to add custom headers to the request. void SetHeader(string name, string value) : Removes any previously added values, and sets the given one. bool RemoveHeader(string name) : Removes the specified header. Returns true, if the header found and succesfully removed. bool HasHeader(string name) : Returns true if the given head name is already in the Headers. string GetFirstHeaderValue(string name) : Returns the first header or null for the given header name. List<string> GetHeaderValues(string name) : Returns all header values for the given header or null. void RemoveHeaders() : Removes all headers.","title":"Header Functions"},{"location":"1.HTTP/HTTPRequest/#range-header-functions","text":"Range headers can be used to resume to an unfinished download, download only parts of a (large) content or download multiple parts in parallel. void SetRangeHeader(long firstBytePos) : Sets the Range header to download the content from the given byte position. See RFC 2616 . void SetRangeHeader(long firstBytePos, long lastBytePos) : Sets the Range header to download the content from the given byte position to the given last position. See RFC 2616 .","title":"Range Header Functions"},{"location":"1.HTTP/HTTPRequest/#other-functions","text":"HTTPRequest Send() : Starts processing the request. void Abort() : Aborts an already established connection, so no further download or upload are done. void Clear() : Resets the request for a state where switching MethodType is possible.","title":"Other Functions"},{"location":"1.HTTP/HTTPResponse/","text":"Properties int VersionMajor : Major version number of this response received with. With HTTP/1.1 it's going to be 1 , and with HTTP/2 it's 2 . int VersionMinor : Minor version number of this response received with. With HTTP/1.1 it's going to be 1 , and with HTTP/2 it's 0 . int StatusCode : The status code that sent from the server. bool IsSuccess : Returns true if the status code is in the range of [200..300[ or 304 (Not Modified) string Message : The message that sent along with the StatusCode from the server. You can check it for errors from the server. bool IsStreamed : True if it's a streamed response. bool IsFromCache : Indicates that the response body is read from the cache. HTTPCacheFileInfo CacheFileInfo : Provides information about the file used for caching the request. bool IsCacheOnly : Determines if this response is only stored to cache. If both IsCacheOnly and IsStreamed are true, OnStreamingData isn't called. bool IsProxyResponse : True, if this is a response for a HTTPProxy request. Dictionary<string, List<string>> Headers : The headers that sent from the server. byte[] Data : The data that downloaded from the server. All Transfer and Content encodings decoded if any(eg. chunked, gzip, deflate). bool IsUpgraded : The normal HTTP protocol is upgraded to an other. List<Cookie> Cookies : The cookies that the server sent to the client. string DataAsText : The data converted to an UTF8 string. Texture2D DataAsTexture2D : The data loaded to a Texture2D. bool IsClosedManually : True if the connection's stream will be closed manually. Used in custom protocols (WebSocket, EventSource). LoggingContext Context : Logging context of the request. Functions List<string> GetHeaderValues(string name) : Returns the list of values that received from the server for the given header name. Remarks: All headers converted to lowercase while reading the response. If no header found with the given name or there are no values in the list (eg. Count == 0) returns null. string GetFirstHeaderValue(string name) : Returns the first value in the header list or null if there are no header or value. If no header found with the given name or there are no values in the list (eg. Count == 0) returns null. bool HasHeaderWithValue(string headerName, string value) : Checks if there is a header with the given name and value. Returns true if there is a header with the given name and value. bool HasHeader(string headerName) : Checks if there is a header with the given name. Returns true if there is a header with the given name. HTTPRange GetRange() : Parses the 'Content-Range' header's value and returns a HTTPRange object. If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist. (Normally, this means return a 200 response containing the full entity). In this case because of there are no 'Content-Range' header, this function will return null! Returns null if no 'Content-Range' header found.","title":"HTTPResponse"},{"location":"1.HTTP/HTTPResponse/#properties","text":"int VersionMajor : Major version number of this response received with. With HTTP/1.1 it's going to be 1 , and with HTTP/2 it's 2 . int VersionMinor : Minor version number of this response received with. With HTTP/1.1 it's going to be 1 , and with HTTP/2 it's 0 . int StatusCode : The status code that sent from the server. bool IsSuccess : Returns true if the status code is in the range of [200..300[ or 304 (Not Modified) string Message : The message that sent along with the StatusCode from the server. You can check it for errors from the server. bool IsStreamed : True if it's a streamed response. bool IsFromCache : Indicates that the response body is read from the cache. HTTPCacheFileInfo CacheFileInfo : Provides information about the file used for caching the request. bool IsCacheOnly : Determines if this response is only stored to cache. If both IsCacheOnly and IsStreamed are true, OnStreamingData isn't called. bool IsProxyResponse : True, if this is a response for a HTTPProxy request. Dictionary<string, List<string>> Headers : The headers that sent from the server. byte[] Data : The data that downloaded from the server. All Transfer and Content encodings decoded if any(eg. chunked, gzip, deflate). bool IsUpgraded : The normal HTTP protocol is upgraded to an other. List<Cookie> Cookies : The cookies that the server sent to the client. string DataAsText : The data converted to an UTF8 string. Texture2D DataAsTexture2D : The data loaded to a Texture2D. bool IsClosedManually : True if the connection's stream will be closed manually. Used in custom protocols (WebSocket, EventSource). LoggingContext Context : Logging context of the request.","title":"Properties"},{"location":"1.HTTP/HTTPResponse/#functions","text":"List<string> GetHeaderValues(string name) : Returns the list of values that received from the server for the given header name. Remarks: All headers converted to lowercase while reading the response. If no header found with the given name or there are no values in the list (eg. Count == 0) returns null. string GetFirstHeaderValue(string name) : Returns the first value in the header list or null if there are no header or value. If no header found with the given name or there are no values in the list (eg. Count == 0) returns null. bool HasHeaderWithValue(string headerName, string value) : Checks if there is a header with the given name and value. Returns true if there is a header with the given name and value. bool HasHeader(string headerName) : Checks if there is a header with the given name. Returns true if there is a header with the given name. HTTPRange GetRange() : Parses the 'Content-Range' header's value and returns a HTTPRange object. If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist. (Normally, this means return a 200 response containing the full entity). In this case because of there are no 'Content-Range' header, this function will return null! Returns null if no 'Content-Range' header found.","title":"Functions"},{"location":"1.HTTP/AdvancedTopics/Async-await/","text":"Async-Await with HTTPRequest Starting in v1.12.0 new async APIs are added to the HTTPRequest. Async APIs are GetHTTPResponseAsync , GetAsStringAsync , GetAsTexture2DAsync , GetRawDataAsync and using LitJson from the Examples folder there's a GetFromJsonResultAsync too. Warning When Get...Async APIs are used, the plugin overwrites any previously set callback, hence no callback will be called for that request! Simple async-await Example Simplest example to download a string using async-await: using System; using System.Threading.Tasks; using UnityEngine; using BestHTTP; public class AsyncTest : MonoBehaviour { async Task Start() { var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\")); Debug.Log(await request.GetAsStringAsync()); } } Handling Errors Any outcome that fails to resolve the expected outcome are going to throw an exception. try { Debug.Log(await request.GetAsStringAsync(tokenSource.Token)); } catch (Exception ex) { Debug.LogException(ex); } Possible errors are various timeouts, status codes that indicate errors (401, 404 for example), request cancellation, etc. The exception is an AsyncHTTPException containing the StatusCode if there were any and the textual Content sent by the server: try { Debug.Log(await request.GetAsStringAsync(tokenSource.Token)); } catch(AsyncHTTPException ex) { Debug.Log(\"Status Code: \" + ex.StatusCode); Debug.Log(\"Message: \" + ex.Message); Debug.Log(\"Content: \" + ex.Content); } Using CancellationToken Async APIs can accept a CancellationToken : using System; using System.Threading; using System.Threading.Tasks; using UnityEngine; using BestHTTP; public class AsyncTest : MonoBehaviour { async Task Start() { var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\")); CancellationTokenSource tokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(10)); try { Debug.Log(await request.GetAsStringAsync(tokenSource.Token)); } catch(Exception ex) { Debug.LogException(ex); } // don't forget to dispose! ;) tokenSource.Dispose(); } } When the token's cancellation take action, the plugin will call Abort on the HTTPRequest object. Configure Await With ConfigureAwait the Task can be configured to continue its exetution on the completing thread. The example below with ConfigureAwait(false) should display two different thread ids. With ConfigureAwait(true) , thread ids should be the same. using System; using System.Threading; using System.Threading.Tasks; using UnityEngine; using BestHTTP; public class AsyncTest : MonoBehaviour { async Task Start() { var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\")); Debug.Log(\"Thread id before: \" + Thread.CurrentThread.ManagedThreadId); string result = await request.GetAsStringAsync().ConfigureAwait(false); Debug.Log(\"Thread id after: \" + Thread.CurrentThread.ManagedThreadId); Debug.Log(\"Result: \" + result); } }","title":"Async-Await with HTTPRequest"},{"location":"1.HTTP/AdvancedTopics/Async-await/#async-await-with-httprequest","text":"Starting in v1.12.0 new async APIs are added to the HTTPRequest. Async APIs are GetHTTPResponseAsync , GetAsStringAsync , GetAsTexture2DAsync , GetRawDataAsync and using LitJson from the Examples folder there's a GetFromJsonResultAsync too. Warning When Get...Async APIs are used, the plugin overwrites any previously set callback, hence no callback will be called for that request!","title":"Async-Await with HTTPRequest"},{"location":"1.HTTP/AdvancedTopics/Async-await/#simple-async-await-example","text":"Simplest example to download a string using async-await: using System; using System.Threading.Tasks; using UnityEngine; using BestHTTP; public class AsyncTest : MonoBehaviour { async Task Start() { var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\")); Debug.Log(await request.GetAsStringAsync()); } }","title":"Simple async-await Example"},{"location":"1.HTTP/AdvancedTopics/Async-await/#handling-errors","text":"Any outcome that fails to resolve the expected outcome are going to throw an exception. try { Debug.Log(await request.GetAsStringAsync(tokenSource.Token)); } catch (Exception ex) { Debug.LogException(ex); } Possible errors are various timeouts, status codes that indicate errors (401, 404 for example), request cancellation, etc. The exception is an AsyncHTTPException containing the StatusCode if there were any and the textual Content sent by the server: try { Debug.Log(await request.GetAsStringAsync(tokenSource.Token)); } catch(AsyncHTTPException ex) { Debug.Log(\"Status Code: \" + ex.StatusCode); Debug.Log(\"Message: \" + ex.Message); Debug.Log(\"Content: \" + ex.Content); }","title":"Handling Errors"},{"location":"1.HTTP/AdvancedTopics/Async-await/#using-cancellationtoken","text":"Async APIs can accept a CancellationToken : using System; using System.Threading; using System.Threading.Tasks; using UnityEngine; using BestHTTP; public class AsyncTest : MonoBehaviour { async Task Start() { var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\")); CancellationTokenSource tokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(10)); try { Debug.Log(await request.GetAsStringAsync(tokenSource.Token)); } catch(Exception ex) { Debug.LogException(ex); } // don't forget to dispose! ;) tokenSource.Dispose(); } } When the token's cancellation take action, the plugin will call Abort on the HTTPRequest object.","title":"Using CancellationToken"},{"location":"1.HTTP/AdvancedTopics/Async-await/#configure-await","text":"With ConfigureAwait the Task can be configured to continue its exetution on the completing thread. The example below with ConfigureAwait(false) should display two different thread ids. With ConfigureAwait(true) , thread ids should be the same. using System; using System.Threading; using System.Threading.Tasks; using UnityEngine; using BestHTTP; public class AsyncTest : MonoBehaviour { async Task Start() { var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\")); Debug.Log(\"Thread id before: \" + Thread.CurrentThread.ManagedThreadId); string result = await request.GetAsStringAsync().ConfigureAwait(false); Debug.Log(\"Thread id after: \" + Thread.CurrentThread.ManagedThreadId); Debug.Log(\"Result: \" + result); } }","title":"Configure Await"},{"location":"1.HTTP/AdvancedTopics/Authentication/","text":"Authentication Best HTTP supports Basic and Digest authentication through the HTTPRequest\u2019s Credentials property: using BestHTTP; using BestHTTP.Authentication; var request = new HTTPRequest(new Uri(\"http://yourserver.org/auth-path\"), (req, resp) => { if (resp.StatusCode != 401) Debug.Log(\"Authenticated\"); else Debug.Log(\"NOT Authenticated\"); }); request.Credentials = new Credentials(\"usr\", \"paswd\"); request.Send();","title":"Authentication"},{"location":"1.HTTP/AdvancedTopics/Authentication/#authentication","text":"Best HTTP supports Basic and Digest authentication through the HTTPRequest\u2019s Credentials property: using BestHTTP; using BestHTTP.Authentication; var request = new HTTPRequest(new Uri(\"http://yourserver.org/auth-path\"), (req, resp) => { if (resp.StatusCode != 401) Debug.Log(\"Authenticated\"); else Debug.Log(\"NOT Authenticated\"); }); request.Credentials = new Credentials(\"usr\", \"paswd\"); request.Send();","title":"Authentication"},{"location":"1.HTTP/AdvancedTopics/Caching/","text":"Caching works automatically and without any further setup. The plugin handles the caching headers received from the server in the response and adds additional headers to the request to check the cached content's freshness. Headers Caching uses the following headers: ETag : When present for a cached entity, the plugin will send out an If-None-Match header with the following request to test the stored entity's freshness. If the server returns with an 304 - Not Modified , the plugin loads the content from the local cache. Last-Modified : All operations is the same as with the ETag header, but it will send out an If-Modified-Since header. Expires : When present for a cached entity and its value is in the future, the plugin loads content from the cache without contacting the server to validate the entity's freshness. When present all previous headers are ignored. Cache-Control : When present with the max-age option and the entity's calculated age is less then its max-age, the plugin loads the content from the cache the same way as with the Expires. When present all previous headers are ignored. Flow-chart about caching: Disable caching There's quite a few ways to disable caching. It can be done globally with the BESTHTTP_DISABLE_CACHING define or by setting HTTPManager.IsCachingDisabled to true before any HTTPRequest instantiation: HTTPManager.IsCachingDisabled = true; It can be disabled per-request by setting the HTTPRequest's DisableCache property to true: var request = new HTTPRequest(new Uri(\"...\"), ImageDownloaded); request.DisableCache = true; request.Send(); Caching related properties HTTPRequest : DisableCache : With this property caching can be enabled/disabled on a per-request basis. CacheOnly : It can be used with streaming . When set to true, no OnStreamingData event is called, the streamed content will be saved straight to the cache if all requirements are met(caching is enabled and there's a caching headers). HTTPResponse : IsFromCache : Indicates that the response body is read from the cache. CacheFileInfo : Provides information about the file used for caching the request. IsCacheOnly : Determines if this response is only stored to cache. If both IsCacheOnly and IsStreamed are true, OnStreamingData isn't called. Maintainence Although caching is automatic we have some control over it, or we can gain some info using the public functions of the HTTPCacheService class: BeginClear() : It will start clearing the entire cache on a separate thread. BeginMaintainence() : With this function\u2019s help, we can delete cached entries based on the last access time. It deletes entries that\u2019s last access time is older than the specified time. We can also use this function to keep the cache size under control: // Delete cache entries that weren\u2019t accessed in the last two weeks, then // delete entries to keep the size of the cache under 50 megabytes, starting with the oldest. HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); GetCacheSize() : Will return the size of the cache in bytes. GetCacheEntryCount() : Will return the number of the entries stored in the cache. The average cache entry size can be computed with the float avgSize = GetCacheSize() / (float) GetCacheEntryCount() formula. IsDoingMaintainence : Its value is true while the cache service doing any Clear or Maintainence on a separate thread.","title":"Caching"},{"location":"1.HTTP/AdvancedTopics/Caching/#headers","text":"Caching uses the following headers: ETag : When present for a cached entity, the plugin will send out an If-None-Match header with the following request to test the stored entity's freshness. If the server returns with an 304 - Not Modified , the plugin loads the content from the local cache. Last-Modified : All operations is the same as with the ETag header, but it will send out an If-Modified-Since header. Expires : When present for a cached entity and its value is in the future, the plugin loads content from the cache without contacting the server to validate the entity's freshness. When present all previous headers are ignored. Cache-Control : When present with the max-age option and the entity's calculated age is less then its max-age, the plugin loads the content from the cache the same way as with the Expires. When present all previous headers are ignored. Flow-chart about caching:","title":"Headers"},{"location":"1.HTTP/AdvancedTopics/Caching/#disable-caching","text":"There's quite a few ways to disable caching. It can be done globally with the BESTHTTP_DISABLE_CACHING define or by setting HTTPManager.IsCachingDisabled to true before any HTTPRequest instantiation: HTTPManager.IsCachingDisabled = true; It can be disabled per-request by setting the HTTPRequest's DisableCache property to true: var request = new HTTPRequest(new Uri(\"...\"), ImageDownloaded); request.DisableCache = true; request.Send();","title":"Disable caching"},{"location":"1.HTTP/AdvancedTopics/Caching/#caching-related-properties","text":"HTTPRequest : DisableCache : With this property caching can be enabled/disabled on a per-request basis. CacheOnly : It can be used with streaming . When set to true, no OnStreamingData event is called, the streamed content will be saved straight to the cache if all requirements are met(caching is enabled and there's a caching headers). HTTPResponse : IsFromCache : Indicates that the response body is read from the cache. CacheFileInfo : Provides information about the file used for caching the request. IsCacheOnly : Determines if this response is only stored to cache. If both IsCacheOnly and IsStreamed are true, OnStreamingData isn't called.","title":"Caching related properties"},{"location":"1.HTTP/AdvancedTopics/Caching/#maintainence","text":"Although caching is automatic we have some control over it, or we can gain some info using the public functions of the HTTPCacheService class: BeginClear() : It will start clearing the entire cache on a separate thread. BeginMaintainence() : With this function\u2019s help, we can delete cached entries based on the last access time. It deletes entries that\u2019s last access time is older than the specified time. We can also use this function to keep the cache size under control: // Delete cache entries that weren\u2019t accessed in the last two weeks, then // delete entries to keep the size of the cache under 50 megabytes, starting with the oldest. HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); GetCacheSize() : Will return the size of the cache in bytes. GetCacheEntryCount() : Will return the number of the entries stored in the cache. The average cache entry size can be computed with the float avgSize = GetCacheSize() / (float) GetCacheEntryCount() formula. IsDoingMaintainence : Its value is true while the cache service doing any Clear or Maintainence on a separate thread.","title":"Maintainence"},{"location":"1.HTTP/AdvancedTopics/Cookies/","text":"Cookies Handling of cookie operations are transparent to the programmer. Setting up the request Cookie header and parsing and maintaining the response's Set-Cookie header are done automatically by the plugin. However it can be controlled in various ways: It can be disabled per-request or globally by setting the HTTPRequest object's IsCookiesEnabled property or the HTTPManager.IsCookiesEnabled property. Cookies can be deleted from the Cookie Jar by calling the CookieJar.Clear() function. New cookies that are sent from the server can be accessed through the response's Cookies property. There are numerous global setting regarding cookies. See the Global Settings section for more information. Cookies can be added to a HTTPRequest by adding them to the Cookies list: var request = new HTTPRequest(new Uri(address), OnFinished); request.Cookies.Add(new Cookie(\"Name\", \"Value\")); request.Send(); These cookies will be merged with the server sent cookies. If IsCookiesEnabled is set to false on the request or in the HTTPManager , then only these user-set cookies will be sent.","title":"Cookies"},{"location":"1.HTTP/AdvancedTopics/Cookies/#cookies","text":"Handling of cookie operations are transparent to the programmer. Setting up the request Cookie header and parsing and maintaining the response's Set-Cookie header are done automatically by the plugin. However it can be controlled in various ways: It can be disabled per-request or globally by setting the HTTPRequest object's IsCookiesEnabled property or the HTTPManager.IsCookiesEnabled property. Cookies can be deleted from the Cookie Jar by calling the CookieJar.Clear() function. New cookies that are sent from the server can be accessed through the response's Cookies property. There are numerous global setting regarding cookies. See the Global Settings section for more information. Cookies can be added to a HTTPRequest by adding them to the Cookies list: var request = new HTTPRequest(new Uri(address), OnFinished); request.Cookies.Add(new Cookie(\"Name\", \"Value\")); request.Send(); These cookies will be merged with the server sent cookies. If IsCookiesEnabled is set to false on the request or in the HTTPManager , then only these user-set cookies will be sent.","title":"Cookies"},{"location":"1.HTTP/AdvancedTopics/DownloadProgress/","text":"Download Progress Tracking To track and display download progress you can use the OnDownloadProgress event of the HTTPRequest class. This event\u2019s parameters are the original HTTPRequest object, the downloaded bytes and the expected length of the downloaded content. var request = new HTTPRequest(new Uri(address), OnFinished); request.OnDownloadProgress = OnDownloadProgress; request.Send(); void OnDownloadProgress(HTTPRequest request, long downloaded, long length) { float progressPercent = (downloaded / (float)length) * 100.0f; Debug.Log(\"Downloaded: \" + progressPercent.ToString(\"F2\") + \"%\"); } Warning When the server sends the content with chunked encoding the plugin can't determine what will be the final length so length will be advanced by the current chunk's length.","title":"Download Progress Tracking"},{"location":"1.HTTP/AdvancedTopics/DownloadProgress/#download-progress-tracking","text":"To track and display download progress you can use the OnDownloadProgress event of the HTTPRequest class. This event\u2019s parameters are the original HTTPRequest object, the downloaded bytes and the expected length of the downloaded content. var request = new HTTPRequest(new Uri(address), OnFinished); request.OnDownloadProgress = OnDownloadProgress; request.Send(); void OnDownloadProgress(HTTPRequest request, long downloaded, long length) { float progressPercent = (downloaded / (float)length) * 100.0f; Debug.Log(\"Downloaded: \" + progressPercent.ToString(\"F2\") + \"%\"); } Warning When the server sends the content with chunked encoding the plugin can't determine what will be the final length so length will be advanced by the current chunk's length.","title":"Download Progress Tracking"},{"location":"1.HTTP/AdvancedTopics/DownloadStreaming/","text":"Download Streaming Warning Not available under the WebGL runtime. See platforms and limitations section for more details For larger responses it's not advised to keep the whole entity in memory. To be able process downloaded data as soon as received the plugin provides the OnStreamingData callback. var request = new HTTPRequest(new Uri(\"...\"), OnRequestFinished); request.OnStreamingData += OnDataDownloaded; bool OnDataDownloaded(HTTPRequest request, HTTPResponse response, byte[] dataFragment, int dataFragmentLength) { // Use downloaded data return true; } The callback's parameters are the following: request : the original HTTPRequest object response : the HTTPResponse object the data belongs to. Through this object all already received information can be accessed (status code, headers, etc.) dataFragment : the actual downloaded bytes. Because the plugin reuses byte arrays, its length can be larger than the downloaded data, so instead of dataFragment.Length the dataFragmentLength parameter must be used! dataFragmentLength : the real downloaded byte count of the dataFragment parameter. Use this parameter instead of dataFragment.Length ! The callback also must return true or false depending on whether the plugin can reuse the dataFragment buffer or not. For more details see the BufferPool documentation . So in case the dataFragment's reference is kept by user code, the callback must return false: var request = new HTTPRequest(new Uri(\"...\"), OnRequestFinished); request.OnStreamingData += OnDataDownloaded; List<Data> dataToProcess = new List<Data>(); bool OnDataDownloaded(HTTPRequest request, HTTPResponse response, byte[] dataFragment, int dataFragmentLength) { // dataFragment is saved to process it later dataToProcess.Add(new Data { buffer = dataFragment, length = dataFragmentLength }); // so the callback must return false, otherwise the plugin would reuse the byte[] overwriting the data in it return false; } struct Data { public byte[] buffer; public int length; } Size of the dataFragment (== dataFragmentLength ) depends on various factors: Value of the StreamFragmentSize property. The plugin tries to keep the fragments' size around StreamFragmentSize , but the BufferPool can return a larger chunks of memory. If StreamChunksImmediately is true , then no buffering will be done. In case of chunked content-encoding the size of the fragment is the chunk length. In case there's a content-length header, the plugin fills up an at least HTTPResponse.MinBufferSize d buffer for the next fragment. Because there's a time window between producing dataFragments and consuming them in an OnStreamingData callback, to prevent consuming too much memory there's a hard limit on the queued dataFragments. When this hard limit is reached the reader thread stops producing new fragments and resumes as soon as there's free slots in the queue. This hard limit can be changed through the MaxFragmentQueueLength property. So, the maximum amount of memory the plugin will consme for streaming is about ( MaxFragmentQueueLength * StreamFragmentSize ). With HTTP/2, the reading thread doesn't know the semantics of the frames it reads from the stream, so it can't limit what and how many frames/data it reads (it would also block the reading of other frames too). To limit a HTTP/2 stream and/or the whole HTTP/2 connection HTTPManager.HTTP2Settings ' InitialStreamWindowSize and InitialConnectionWindowSize can be used. Streaming into a file In the following example the FileStream is created on-demand and its reference is stored in the request's Tag property to reuse the instance instead of reopening the file every time. var request = new HTTPRequest(new Uri(url), OnRequestFinished); request.OnStreamingData += OnData; request.Send(); private bool OnData(HTTPRequest req, HTTPResponse resp, byte[] dataFragment, int dataFragmentLength) { if (resp.IsSuccess) { var fs = req.Tag as System.IO.FileStream; if (fs == null) req.Tag = fs = new System.IO.FileStream(\"fileName\", System.IO.FileMode.Create); fs.Write(dataFragment, 0, dataFragmentLength); } // Return true if dataFragment is processed so the plugin can recycle it return true; } private void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { var fs = req.Tag as System.IO.FileStream; if (fs != null) fs.Dispose(); switch (req.State) { // The request finished without any problem. case HTTPRequestStates.Finished: if (resp.IsSuccess) { Debug.Log(\"Done!\"); } else { Debug.LogWarning(string.Format(\"Request finished Successfully, but the server sent an error. Status Code: {0}-{1} Message: {2}\", resp.StatusCode, resp.Message, resp.DataAsText)); } break; default: // There were an error while downloading the content. // The incomplete file should be deleted. System.IO.File.Delete(\"filename\"); break; } }","title":"Download Streaming"},{"location":"1.HTTP/AdvancedTopics/DownloadStreaming/#download-streaming","text":"Warning Not available under the WebGL runtime. See platforms and limitations section for more details For larger responses it's not advised to keep the whole entity in memory. To be able process downloaded data as soon as received the plugin provides the OnStreamingData callback. var request = new HTTPRequest(new Uri(\"...\"), OnRequestFinished); request.OnStreamingData += OnDataDownloaded; bool OnDataDownloaded(HTTPRequest request, HTTPResponse response, byte[] dataFragment, int dataFragmentLength) { // Use downloaded data return true; } The callback's parameters are the following: request : the original HTTPRequest object response : the HTTPResponse object the data belongs to. Through this object all already received information can be accessed (status code, headers, etc.) dataFragment : the actual downloaded bytes. Because the plugin reuses byte arrays, its length can be larger than the downloaded data, so instead of dataFragment.Length the dataFragmentLength parameter must be used! dataFragmentLength : the real downloaded byte count of the dataFragment parameter. Use this parameter instead of dataFragment.Length ! The callback also must return true or false depending on whether the plugin can reuse the dataFragment buffer or not. For more details see the BufferPool documentation . So in case the dataFragment's reference is kept by user code, the callback must return false: var request = new HTTPRequest(new Uri(\"...\"), OnRequestFinished); request.OnStreamingData += OnDataDownloaded; List<Data> dataToProcess = new List<Data>(); bool OnDataDownloaded(HTTPRequest request, HTTPResponse response, byte[] dataFragment, int dataFragmentLength) { // dataFragment is saved to process it later dataToProcess.Add(new Data { buffer = dataFragment, length = dataFragmentLength }); // so the callback must return false, otherwise the plugin would reuse the byte[] overwriting the data in it return false; } struct Data { public byte[] buffer; public int length; } Size of the dataFragment (== dataFragmentLength ) depends on various factors: Value of the StreamFragmentSize property. The plugin tries to keep the fragments' size around StreamFragmentSize , but the BufferPool can return a larger chunks of memory. If StreamChunksImmediately is true , then no buffering will be done. In case of chunked content-encoding the size of the fragment is the chunk length. In case there's a content-length header, the plugin fills up an at least HTTPResponse.MinBufferSize d buffer for the next fragment. Because there's a time window between producing dataFragments and consuming them in an OnStreamingData callback, to prevent consuming too much memory there's a hard limit on the queued dataFragments. When this hard limit is reached the reader thread stops producing new fragments and resumes as soon as there's free slots in the queue. This hard limit can be changed through the MaxFragmentQueueLength property. So, the maximum amount of memory the plugin will consme for streaming is about ( MaxFragmentQueueLength * StreamFragmentSize ). With HTTP/2, the reading thread doesn't know the semantics of the frames it reads from the stream, so it can't limit what and how many frames/data it reads (it would also block the reading of other frames too). To limit a HTTP/2 stream and/or the whole HTTP/2 connection HTTPManager.HTTP2Settings ' InitialStreamWindowSize and InitialConnectionWindowSize can be used.","title":"Download Streaming"},{"location":"1.HTTP/AdvancedTopics/DownloadStreaming/#streaming-into-a-file","text":"In the following example the FileStream is created on-demand and its reference is stored in the request's Tag property to reuse the instance instead of reopening the file every time. var request = new HTTPRequest(new Uri(url), OnRequestFinished); request.OnStreamingData += OnData; request.Send(); private bool OnData(HTTPRequest req, HTTPResponse resp, byte[] dataFragment, int dataFragmentLength) { if (resp.IsSuccess) { var fs = req.Tag as System.IO.FileStream; if (fs == null) req.Tag = fs = new System.IO.FileStream(\"fileName\", System.IO.FileMode.Create); fs.Write(dataFragment, 0, dataFragmentLength); } // Return true if dataFragment is processed so the plugin can recycle it return true; } private void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { var fs = req.Tag as System.IO.FileStream; if (fs != null) fs.Dispose(); switch (req.State) { // The request finished without any problem. case HTTPRequestStates.Finished: if (resp.IsSuccess) { Debug.Log(\"Done!\"); } else { Debug.LogWarning(string.Format(\"Request finished Successfully, but the server sent an error. Status Code: {0}-{1} Message: {2}\", resp.StatusCode, resp.Message, resp.DataAsText)); } break; default: // There were an error while downloading the content. // The incomplete file should be deleted. System.IO.File.Delete(\"filename\"); break; } }","title":"Streaming into a file"},{"location":"1.HTTP/AdvancedTopics/ErrorHandling/","text":"Error handling Because the callbacks' HTTPResponse parameter can be null in cases where there was an error on client side (request aborting, timeouts or non-reachable server), as a best practice a HTTPRequest 's callback should look like this: private void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { switch (req.State) { // The request finished without any problem. case HTTPRequestStates.Finished: if (resp.IsSuccess) { // Everything went as expected! } else { Debug.LogWarning(string.Format(\"Request finished Successfully, but the server sent an error. Status Code: {0}-{1} Message: {2}\", resp.StatusCode, resp.Message, resp.DataAsText)); } break; // The request finished with an unexpected error. The request's Exception property may contain more info about the error. case HTTPRequestStates.Error: Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); break; // The request aborted, initiated by the user. case HTTPRequestStates.Aborted: Debug.LogWarning(\"Request Aborted!\"); break; // Connecting to the server is timed out. case HTTPRequestStates.ConnectionTimedOut: Debug.LogError(\"Connection Timed Out!\"); break; // The request didn't finished in the given time. case HTTPRequestStates.TimedOut: Debug.LogError(\"Processing the request Timed Out!\"); break; } } A request may fail even before reaching the server so it's wise to check its State first. But even if the request reach the server it can fail if the request is badly constructed or incomplete (status code of 4xxx), or because the server had an issue (status code of 5xxx). So in the Finshed case we still have to check the HTTPResponse 's StatusCode for those codes, or just simple test against the IsSuccess property. IsSuccess is just a shortened way to check whether the status code is in a valid range: public bool IsSuccess { get { return (this.StatusCode >= 200 && this.StatusCode < 300) || this.StatusCode == 304; } }","title":"ErrorHandling"},{"location":"1.HTTP/AdvancedTopics/ErrorHandling/#error-handling","text":"Because the callbacks' HTTPResponse parameter can be null in cases where there was an error on client side (request aborting, timeouts or non-reachable server), as a best practice a HTTPRequest 's callback should look like this: private void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { switch (req.State) { // The request finished without any problem. case HTTPRequestStates.Finished: if (resp.IsSuccess) { // Everything went as expected! } else { Debug.LogWarning(string.Format(\"Request finished Successfully, but the server sent an error. Status Code: {0}-{1} Message: {2}\", resp.StatusCode, resp.Message, resp.DataAsText)); } break; // The request finished with an unexpected error. The request's Exception property may contain more info about the error. case HTTPRequestStates.Error: Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); break; // The request aborted, initiated by the user. case HTTPRequestStates.Aborted: Debug.LogWarning(\"Request Aborted!\"); break; // Connecting to the server is timed out. case HTTPRequestStates.ConnectionTimedOut: Debug.LogError(\"Connection Timed Out!\"); break; // The request didn't finished in the given time. case HTTPRequestStates.TimedOut: Debug.LogError(\"Processing the request Timed Out!\"); break; } } A request may fail even before reaching the server so it's wise to check its State first. But even if the request reach the server it can fail if the request is badly constructed or incomplete (status code of 4xxx), or because the server had an issue (status code of 5xxx). So in the Finshed case we still have to check the HTTPResponse 's StatusCode for those codes, or just simple test against the IsSuccess property. IsSuccess is just a shortened way to check whether the status code is in a valid range: public bool IsSuccess { get { return (this.StatusCode >= 200 && this.StatusCode < 300) || this.StatusCode == 304; } }","title":"Error handling"},{"location":"1.HTTP/AdvancedTopics/Redirections/","text":"Control Redirections Redirection are handled automatically by the plugin, but sometimes we have to make changes before a new request is made to the uri that we redirected to. We can do these changes in the OnBeforeRedirection event handler of a HTTPRequest . This event is called before the plugin will do a new request to the new uri. The return value of the function will control the redirection: if it's false the redirection is aborted. This function is called on a thread other than the main Unity thread! var request = new HTTPRequest(uri, HTTPMethods.Post); request.AddField(\"field\", \"data\"); request.OnBeforeRedirection += OnBeforeRedirect; request.Send(); bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) { if (req.MethodType == HTTPMethods.Post && resp.StatusCode == 302) { req.MethodType = HTTPMethods.Get; // Don't send more data than needed. // So we will delete our already processed form data. req.Clear(); } return true; }","title":"Control Redirections"},{"location":"1.HTTP/AdvancedTopics/Redirections/#control-redirections","text":"Redirection are handled automatically by the plugin, but sometimes we have to make changes before a new request is made to the uri that we redirected to. We can do these changes in the OnBeforeRedirection event handler of a HTTPRequest . This event is called before the plugin will do a new request to the new uri. The return value of the function will control the redirection: if it's false the redirection is aborted. This function is called on a thread other than the main Unity thread! var request = new HTTPRequest(uri, HTTPMethods.Post); request.AddField(\"field\", \"data\"); request.OnBeforeRedirection += OnBeforeRedirect; request.Send(); bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) { if (req.MethodType == HTTPMethods.Post && resp.StatusCode == 302) { req.MethodType = HTTPMethods.Get; // Don't send more data than needed. // So we will delete our already processed form data. req.Clear(); } return true; }","title":"Control Redirections"},{"location":"1.HTTP/AdvancedTopics/Request.Abort/","text":"Aborting a Request You can abort an ongoing request by calling the HTTPRequest object\u2019s Abort() function: request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => { \u2026 }); request.Send(); // And after some time: request.Abort(); The callback function will be called and the response object will be null .","title":"Aborting a Request"},{"location":"1.HTTP/AdvancedTopics/Request.Abort/#aborting-a-request","text":"You can abort an ongoing request by calling the HTTPRequest object\u2019s Abort() function: request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => { \u2026 }); request.Send(); // And after some time: request.Abort(); The callback function will be called and the response object will be null .","title":"Aborting a Request"},{"location":"1.HTTP/AdvancedTopics/RequestStates/","text":"Request States All request has a State property that contains its internal state. The possible states are the following: Initial : Initial status of a request. No callback will be called with this status. Processing : Processing of the request started. In this state the client will send the request, and parse the response. No callback will be called with this status. Finished : The request finished without problem. Parsing the response done, the result can be used. The user defined callback will be called with a valid response object. The request\u2019s Exception property will be null . Error : The request finished with an unexpected error in the plugin. The user defined callback will be called with a null response object. The request's Exception property may contain more info about the error, but it can be null . Aborted : The request aborted by the client(HTTPRequests Abort() function). The user defined callback will be called with a null response. The request\u2019s Exception property will be null . ConnectionTimedOut : Connecting to the server timed out. The user defined callback will be called with a null response. The request\u2019s Exception property will be null . TimedOut : The request didn't finished in the given time. The user defined callback will be called with a null response. The request\u2019s Exception property will be null . For a usage example see the previous section\u2019s example.","title":"Request States"},{"location":"1.HTTP/AdvancedTopics/RequestStates/#request-states","text":"All request has a State property that contains its internal state. The possible states are the following: Initial : Initial status of a request. No callback will be called with this status. Processing : Processing of the request started. In this state the client will send the request, and parse the response. No callback will be called with this status. Finished : The request finished without problem. Parsing the response done, the result can be used. The user defined callback will be called with a valid response object. The request\u2019s Exception property will be null . Error : The request finished with an unexpected error in the plugin. The user defined callback will be called with a null response object. The request's Exception property may contain more info about the error, but it can be null . Aborted : The request aborted by the client(HTTPRequests Abort() function). The user defined callback will be called with a null response. The request\u2019s Exception property will be null . ConnectionTimedOut : Connecting to the server timed out. The user defined callback will be called with a null response. The request\u2019s Exception property will be null . TimedOut : The request didn't finished in the given time. The user defined callback will be called with a null response. The request\u2019s Exception property will be null . For a usage example see the previous section\u2019s example.","title":"Request States"},{"location":"1.HTTP/AdvancedTopics/ServerCertificateValidation/","text":"Server Certificate Validation Server sent certificates can be validated by implementing an ICertificateVerifyer interface and setting it to a HTTPRequest\u2019s CustomCertificateVerifyer : using System; using BestHTTP.SecureProtocol.Org.BouncyCastle.Crypto.Tls; using BestHTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509; class CustomVerifier : ICertificateVerifyer { public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) { // TODO: Return false, if validation fails return true; } } var request = new HTTPRequest(new Uri(\"https://google.com\"), ...); request.CustomCertificateVerifyer = new CustomVerifier(); request.UseAlternateSSL = true; request.Send();","title":"Server Certificate Validation"},{"location":"1.HTTP/AdvancedTopics/ServerCertificateValidation/#server-certificate-validation","text":"Server sent certificates can be validated by implementing an ICertificateVerifyer interface and setting it to a HTTPRequest\u2019s CustomCertificateVerifyer : using System; using BestHTTP.SecureProtocol.Org.BouncyCastle.Crypto.Tls; using BestHTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509; class CustomVerifier : ICertificateVerifyer { public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) { // TODO: Return false, if validation fails return true; } } var request = new HTTPRequest(new Uri(\"https://google.com\"), ...); request.CustomCertificateVerifyer = new CustomVerifier(); request.UseAlternateSSL = true; request.Send();","title":"Server Certificate Validation"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/","text":"Small Code-Samples Upload a picture using forms var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); request.AddBinaryData(\"image\", texture.EncodeToPNG(), \"image.png\", \"image/png\"); request.Send(); Upload a picture without forms, sending only the raw data var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); request.SetHeader(\"Content-Type\", \"image/png\"); request.RawData = texture.EncodeToPNG(); request.Send(); Send json data string json = \"{ 'field': 'value' }\"; var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); request.SetHeader(\"Content-Type\", \"application/json; charset=UTF-8\"); request.RawData = System.Text.Encoding.UTF8.GetBytes(json); request.Send(); Display download progress var request = new HTTPRequest(new Uri(\"http://serveroflargefile.net/path\"), (req, resp) => { Debug.Log(\"Finished!\"); }); request.OnDownloadProgress += (req, down, length) => Debug.Log(string.Format(\"Progress: {0:P2}\", down / (float)length)); request.Send(); Abort a request var request = new HTTPRequest(new Uri(address), (req, resp) => { // State should be HTTPRequestStates.Aborted if we call Abort() before // it\u2019s finishes Debug.Log(req.State); }); request.Send(); // and then call Abort when the request isn't relevant anymore request.Abort(); Verify hostnames in HTTPS public sealed class HostNameVerifier : Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer { public bool IsValid(Uri targetUri, SecureProtocol.Org.BouncyCastle.Asn1.X509.X509CertificateStructure[] certs) { foreach (var cert in certs) { var values = cert.Subject.GetValueList(); if (values.Contains(targetUri.Host)) return true; } return false; } } HTTPManager.DefaultCertificateVerifyer = new HostNameVerifier(); Get header values var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\"), (req, resp) => { // One response can contain multiple header: value pairs for the same 'header'. List<string> values = resp.GetHeaderValues(\"custom-header\"); foreach (string header in values) Debug.Log(header); // GetFirstHeaderValue returns the first header's value. It's good for headers that we are sure that occur only one per response. string contentLengthHeader = resp.GetFirstHeaderValue(\"content-length\"); Debug.Log(contentLengthHeader); }); request.Send();","title":"Small Code-Samples"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/#small-code-samples","text":"","title":"Small Code-Samples"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/#upload-a-picture-using-forms","text":"var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); request.AddBinaryData(\"image\", texture.EncodeToPNG(), \"image.png\", \"image/png\"); request.Send();","title":"Upload a picture using forms"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/#upload-a-picture-without-forms-sending-only-the-raw-data","text":"var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); request.SetHeader(\"Content-Type\", \"image/png\"); request.RawData = texture.EncodeToPNG(); request.Send();","title":"Upload a picture without forms, sending only the raw data"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/#send-json-data","text":"string json = \"{ 'field': 'value' }\"; var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); request.SetHeader(\"Content-Type\", \"application/json; charset=UTF-8\"); request.RawData = System.Text.Encoding.UTF8.GetBytes(json); request.Send();","title":"Send json data"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/#display-download-progress","text":"var request = new HTTPRequest(new Uri(\"http://serveroflargefile.net/path\"), (req, resp) => { Debug.Log(\"Finished!\"); }); request.OnDownloadProgress += (req, down, length) => Debug.Log(string.Format(\"Progress: {0:P2}\", down / (float)length)); request.Send();","title":"Display download progress"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/#abort-a-request","text":"var request = new HTTPRequest(new Uri(address), (req, resp) => { // State should be HTTPRequestStates.Aborted if we call Abort() before // it\u2019s finishes Debug.Log(req.State); }); request.Send(); // and then call Abort when the request isn't relevant anymore request.Abort();","title":"Abort a request"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/#verify-hostnames-in-https","text":"public sealed class HostNameVerifier : Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer { public bool IsValid(Uri targetUri, SecureProtocol.Org.BouncyCastle.Asn1.X509.X509CertificateStructure[] certs) { foreach (var cert in certs) { var values = cert.Subject.GetValueList(); if (values.Contains(targetUri.Host)) return true; } return false; } } HTTPManager.DefaultCertificateVerifyer = new HostNameVerifier();","title":"Verify hostnames in HTTPS"},{"location":"1.HTTP/AdvancedTopics/SmallCode-Samples/#get-header-values","text":"var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\"), (req, resp) => { // One response can contain multiple header: value pairs for the same 'header'. List<string> values = resp.GetHeaderValues(\"custom-header\"); foreach (string header in values) Debug.Log(header); // GetFirstHeaderValue returns the first header's value. It's good for headers that we are sure that occur only one per response. string contentLengthHeader = resp.GetFirstHeaderValue(\"content-length\"); Debug.Log(contentLengthHeader); }); request.Send();","title":"Get header values"},{"location":"1.HTTP/AdvancedTopics/Timeouts/","text":"Timeouts You can set two timeout for a request: ConnectTimeout : With this property you can control how much time you want to wait for a connection to be made between your app and the remote server. Its default value is 20 seconds. request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); request.ConnectTimeout = TimeSpan.FromSeconds(2); request.Send(); Timeout : With this property you can control how much time you want to wait for a request to be processed(sending the request, and downloading the response). Its default value is 60 seconds. request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); request.Timeout = TimeSpan.FromSeconds(10); request.Send(); A more complete example: string url = \"https://httpbin.org/get\"; HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) => { switch (req.State) { // The request finished without any problems. case HTTPRequestStates.Finished: Debug.Log(\"Request Finished Successfully!\\n\" + resp.DataAsText); break; // The request finished with an unexpected error. // The request's Exception property may contain more information about the error. case HTTPRequestStates.Error: Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); break; // The request aborted, initiated by the user. case HTTPRequestStates.Aborted: Debug.LogWarning(\"Request Aborted!\"); break; // Connecting to the server timed out. case HTTPRequestStates.ConnectionTimedOut: Debug.LogError(\"Connection Timed Out!\"); break; // The request didn't finished in the given time. case HTTPRequestStates.TimedOut: Debug.LogError(\"Processing the request Timed Out!\"); break; } }); // Very little time, for testing purposes: //request.ConnectTimeout = TimeSpan.FromMilliseconds(2); request.Timeout = TimeSpan.FromSeconds(5); request.DisableCache = true; request.Send();","title":"Timeouts"},{"location":"1.HTTP/AdvancedTopics/Timeouts/#timeouts","text":"You can set two timeout for a request: ConnectTimeout : With this property you can control how much time you want to wait for a connection to be made between your app and the remote server. Its default value is 20 seconds. request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); request.ConnectTimeout = TimeSpan.FromSeconds(2); request.Send(); Timeout : With this property you can control how much time you want to wait for a request to be processed(sending the request, and downloading the response). Its default value is 60 seconds. request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); request.Timeout = TimeSpan.FromSeconds(10); request.Send(); A more complete example: string url = \"https://httpbin.org/get\"; HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) => { switch (req.State) { // The request finished without any problems. case HTTPRequestStates.Finished: Debug.Log(\"Request Finished Successfully!\\n\" + resp.DataAsText); break; // The request finished with an unexpected error. // The request's Exception property may contain more information about the error. case HTTPRequestStates.Error: Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); break; // The request aborted, initiated by the user. case HTTPRequestStates.Aborted: Debug.LogWarning(\"Request Aborted!\"); break; // Connecting to the server timed out. case HTTPRequestStates.ConnectionTimedOut: Debug.LogError(\"Connection Timed Out!\"); break; // The request didn't finished in the given time. case HTTPRequestStates.TimedOut: Debug.LogError(\"Processing the request Timed Out!\"); break; } }); // Very little time, for testing purposes: //request.ConnectTimeout = TimeSpan.FromMilliseconds(2); request.Timeout = TimeSpan.FromSeconds(5); request.DisableCache = true; request.Send();","title":"Timeouts"},{"location":"1.HTTP/AdvancedTopics/Timing/","text":"Timing API A HTTPRequest tracks timings of various phases. These phases could be the following( naming and meaning similiar to the one can be found in the Chrome DevTools ): Queued : Duration the plugin kept the request in its internal queue. Normally this should be a very low time, but when MaxConnectionPerServer or HTTP/2's negotiated MaxConcurrentStreams applies requests could stay in the queue longer. Queued for redirection : The same as the previous, but the request already made a round-trip to a server and got redirected. DNS Lookup : Duration to resolve the server's IP address. Absent if the request processed on a reused connection. TCP Connection : Time required to connect to the server through a new TCP channel. Absent if the request processed on a reused connection. Proxy Negotiation : Time took to negotiate with the proxy. Absent if the request processed on a reused connection. TLS Negotiation : Duration of the TLS negotiation. Absent if the request processed on a reused connection. Request Sent : Time required to write all bytes of the request (headers + payload) to the network. Waiting (TTFB) : Time the plugin had to wait for the first byte of the server's response. Headers : Time required to read all headers. Response Received : Time required to read all bytes of the response's payload. Loading from Cache : Time required to read all bytes from a previously cached response. Absent for non-cached contents. Writing to Cache : Time took to cache the response. Absent for non-cachable contents. Queued for Dispatch : Time between the request is finished and its callback is called. Just like the Queued timings, the request shouldn't stay too much in this queue either. However, because callbacks are called from a MonoBehavior's Upate function, frequency of the Update calls greatly affects these numbers. Finished in : Duration from start to finish. As noted, not all phases are present for all requests, but it's also true that new entries are addded for every redirection. For example a request timing can look like this when it's a first request (no connection is reused): [TimingCollector Start: '12:42:56' ['Queued': 00:00:00.0030003] ['DNS Lookup': 00:00:00.0050012] ['TCP Connection': 00:00:00.0040004] ['Proxy Negotiation': 00:00:00.3006451] ['TLS Negotiation': 00:00:00.4023915] ['Queued': 00:00:00.0072776] ['Request Sent': 00:00:00.0139910] ['Waiting (TTFB)': 00:00:00.1346626] ['Headers': 00:00:00.0060009] ['Response Received': 00:00:00.0019991] ['Queued for Dispatch': 00:00:00.0020012] ['Finished in': 00:00:00.8809709]] The code that produced this log entry: IEnumerator DoTiming() { var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\")); yield return request.Send(); Debug.Log(request.Timing.ToString()); } As can be seen the three largest entries are Proxy Negotiation , TLS Negotiation and Waiting (TTFB) . But, when a reques can be sent through an already open connection or using HTTP/2, running the code above can produce an entry like this: [TimingCollector Start: '12:49:48' ['Queued': 00:00:00] ['Request Sent': 00:00:00.0010005] ['Waiting (TTFB)': 00:00:00.1308247] ['Headers': 00:00:00] ['Response Received': 00:00:00] ['Queued for Dispatch': 00:00:00] ['Finished in': 00:00:00.1318252]] Most of the time spent for waiting for the server's response. Warning Timing uses DateTime.Now to calculate time spent between the phases, accuracy depends on this call. It can be used to get a better view on where the plugin had to wait or spend time and not for benchmarking!","title":"Timing API"},{"location":"1.HTTP/AdvancedTopics/Timing/#timing-api","text":"A HTTPRequest tracks timings of various phases. These phases could be the following( naming and meaning similiar to the one can be found in the Chrome DevTools ): Queued : Duration the plugin kept the request in its internal queue. Normally this should be a very low time, but when MaxConnectionPerServer or HTTP/2's negotiated MaxConcurrentStreams applies requests could stay in the queue longer. Queued for redirection : The same as the previous, but the request already made a round-trip to a server and got redirected. DNS Lookup : Duration to resolve the server's IP address. Absent if the request processed on a reused connection. TCP Connection : Time required to connect to the server through a new TCP channel. Absent if the request processed on a reused connection. Proxy Negotiation : Time took to negotiate with the proxy. Absent if the request processed on a reused connection. TLS Negotiation : Duration of the TLS negotiation. Absent if the request processed on a reused connection. Request Sent : Time required to write all bytes of the request (headers + payload) to the network. Waiting (TTFB) : Time the plugin had to wait for the first byte of the server's response. Headers : Time required to read all headers. Response Received : Time required to read all bytes of the response's payload. Loading from Cache : Time required to read all bytes from a previously cached response. Absent for non-cached contents. Writing to Cache : Time took to cache the response. Absent for non-cachable contents. Queued for Dispatch : Time between the request is finished and its callback is called. Just like the Queued timings, the request shouldn't stay too much in this queue either. However, because callbacks are called from a MonoBehavior's Upate function, frequency of the Update calls greatly affects these numbers. Finished in : Duration from start to finish. As noted, not all phases are present for all requests, but it's also true that new entries are addded for every redirection. For example a request timing can look like this when it's a first request (no connection is reused): [TimingCollector Start: '12:42:56' ['Queued': 00:00:00.0030003] ['DNS Lookup': 00:00:00.0050012] ['TCP Connection': 00:00:00.0040004] ['Proxy Negotiation': 00:00:00.3006451] ['TLS Negotiation': 00:00:00.4023915] ['Queued': 00:00:00.0072776] ['Request Sent': 00:00:00.0139910] ['Waiting (TTFB)': 00:00:00.1346626] ['Headers': 00:00:00.0060009] ['Response Received': 00:00:00.0019991] ['Queued for Dispatch': 00:00:00.0020012] ['Finished in': 00:00:00.8809709]] The code that produced this log entry: IEnumerator DoTiming() { var request = new HTTPRequest(new Uri(\"https://httpbin.org/get\")); yield return request.Send(); Debug.Log(request.Timing.ToString()); } As can be seen the three largest entries are Proxy Negotiation , TLS Negotiation and Waiting (TTFB) . But, when a reques can be sent through an already open connection or using HTTP/2, running the code above can produce an entry like this: [TimingCollector Start: '12:49:48' ['Queued': 00:00:00] ['Request Sent': 00:00:00.0010005] ['Waiting (TTFB)': 00:00:00.1308247] ['Headers': 00:00:00] ['Response Received': 00:00:00] ['Queued for Dispatch': 00:00:00] ['Finished in': 00:00:00.1318252]] Most of the time spent for waiting for the server's response. Warning Timing uses DateTime.Now to calculate time spent between the phases, accuracy depends on this call. It can be used to get a better view on where the plugin had to wait or spend time and not for benchmarking!","title":"Timing API"},{"location":"1.HTTP/AdvancedTopics/UploadProgress/","text":"Upload Progress Tracking To track and display upload progress you can use the OnUploadProgress event of the HTTPRequest class. The OnUploadProgress can be used with RawData, forms(through AddField and AddBinaryData) and with UploadStream too. var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); request.RawData = Encoding.UTF8.GetBytes(\"Field Value\"); request.OnUploadProgress = OnUploadProgress; request.Send(); void OnUploadProgress(HTTPRequest request, long uploaded, long length) { float progressPercent = (uploaded / (float)length) * 100.0f; Debug.Log(\"Uploaded: \" + progressPercent.ToString(\"F2\") + \"%\"); }","title":"Upload Progress Tracking"},{"location":"1.HTTP/AdvancedTopics/UploadProgress/#upload-progress-tracking","text":"To track and display upload progress you can use the OnUploadProgress event of the HTTPRequest class. The OnUploadProgress can be used with RawData, forms(through AddField and AddBinaryData) and with UploadStream too. var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); request.RawData = Encoding.UTF8.GetBytes(\"Field Value\"); request.OnUploadProgress = OnUploadProgress; request.Send(); void OnUploadProgress(HTTPRequest request, long uploaded, long length) { float progressPercent = (uploaded / (float)length) * 100.0f; Debug.Log(\"Uploaded: \" + progressPercent.ToString(\"F2\") + \"%\"); }","title":"Upload Progress Tracking"},{"location":"1.HTTP/AdvancedTopics/UploadStreaming/","text":"Upload Streaming You can set a Stream instance to upload to a HTTPRequest object through the UploadStream property. The plugin will use this stream to gather data to send to the server. When the upload finished and the DisposeUploadStream is true, then the plugin will call the Dispose() function on the stream. If the stream\u2019s length is unknown, the UseUploadStreamLength property should be set to false. In this case, the plugin will send the data from the stream with chunked Transfer-Encoding. var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); request.UploadStream = new FileStream(\"File_To.Upload\", FileMode.Open); request.Send();","title":"Upload Streaming"},{"location":"1.HTTP/AdvancedTopics/UploadStreaming/#upload-streaming","text":"You can set a Stream instance to upload to a HTTPRequest object through the UploadStream property. The plugin will use this stream to gather data to send to the server. When the upload finished and the DisposeUploadStream is true, then the plugin will call the Dispose() function on the stream. If the stream\u2019s length is unknown, the UseUploadStreamLength property should be set to false. In this case, the plugin will send the data from the stream with chunked Transfer-Encoding. var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); request.UploadStream = new FileStream(\"File_To.Upload\", FileMode.Open); request.Send();","title":"Upload Streaming"},{"location":"2.WebSocket/","text":"WebSocket WebSocket is a high level protocol compared to plain TCP connections, while it keeps similiarities with its simple API. While they have similar naming too, it must be highlighted that a WebSocket connection must go through a HTTP upgrade process and it can't connect to a plain TCP socket that implements a custom protcol to exchange messages! Constructors Constructor to specify only the server's endpoint: var webSocket = new WebSocket(new Uri(\"wss://echo.websocket.org\")); Constructor to add origin, protocol and used extension information: var webSocket = new WebSocket(uri: new Uri(\"wss://echo.websocket.org\"), origin: \"echo.websocket.org\", protocol: \"Echo\", extensions: null); Warning The extension parameter isn't available under WebGL! Events OnOpen : Called when connection to the server is established. After this event the WebSocket\u2019s IsOpen property will be True until we or the server closes the connection or if an error occurs. webSocket.OnOpen += OnWebSocketOpen; private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(\"WebSocket is now Open!\"); } OnMessage : Called when a textual message received from the server. webSocket.OnMessage += OnMessageReceived; private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(\"Text Message received from server: \" + message); } OnBinary : Called when a binary blob message received from the server. webSocket.OnBinary += OnBinaryMessageReceived; private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(\"Binary Message received from server. Length: \" + message.Length); } OnClosed : Called when the client or the server closes the connection. When the client closes the connection through the Close function it can provide a Code and a Message that indicates the reason for closing. The server typically will echoes our Code and Message back. webSocket.OnClosed += OnWebSocketClosed; private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(\"WebSocket is now Closed!\"); } OnError : Called when can\u2019t connect to the server, an internal error occurs or when the connection is lost. The second parameter is string describing the error. webSocket.OnError += OnError; void OnError(WebSocket ws, string error) { Debug.LogError(\"Error: \" + error); } Warning OnClose and OnError are mutually exclusive! When OnError is called no OnClosed going to be triggered. But, the connections is closed in both cases. When OnClose is called, the plugin could receive and send a close frame to the server and even if there were some kind of error (protocol error, too big message, etc), the tcp connection is healthy and the server could inform the client that it's about to close the connection. On the other hand, when OnError is called, that's because something really bad happened (tcp channel disconnected for example). In case when the editor is exiting from play mode, the plugin has no time sending a close frame to the server and waiting for an answer, so it just shuts down everything immediately. OnIncompleteFrame : Longer text or binary messages are fragmented, these fragments are assembled by the plugin automatically by default. This mechanism can be overwritten if we register an event handler to the WebSocket\u2019s OnIncompleteFrame event. This event called every time the client receives an incomplete fragment. If an event hanler is added to OnIncompleteFrame , incomplete fragments going to be ignored by the plugin and it doesn\u2019t try to assemble these nor store them. This event can be used to achieve streaming experience. It's not available under WebGL! OnInternalRequestCreated : Called when the internal HTTPRequest object created. The plugin might call it more than once for one WebSocket instance if it has to fall back from the HTTP/2 implementation to the HTTP/1 one. It's not available under WebGL. Methods All methods are non-blocking, Open and Close just starts the opening and closing logic, Send places the data to a buffer that will be picked up by the sender thread. Open : Calling Open() we can start the connection procedure to the server. webSocket.Open(); Notice Just as other calls, Open is not a blocking call. Messages can be sent to the server after an OnOpen event. Send : Sending out text messages: webSocket.Send(\"Message to the Server\"); Sending out binary messages: // Allocate and fill up the buffer with data byte[] buffer = new byte[length]; webSocket.Send(buffer); Large messages (larger than 32767 bytes by default) are sent fragmented to the server. Websocket frames produced by the Send methods are placed into an internal queue and a sender thread going to send them one by one. The BufferedAmount property keeps track the amount of bytes sitting in this queue. Close : After all communication is done we should close the connection by calling the Close() method. webSocket.Close(); Notice You can\u2019t reuse a closed WebSocket instance, you have to create and setup a new one. Properties IsOpen : It's true if the websocket connection is open for sending and receiving. State : It's more verbose about the sate of the WebSocket than the IsOpen property. State can be Connecting , Open , Closing , Closed and Unknown . BufferedAmount : The amount of unsent, buffered up data in bytes. StartPingThread : Set to true to let the plugin send ping messages periodically to the server. Its default value is false. It's not available under WebGL! PingFrequency : The delay between two ping messages in milliseconds. Its default value is 1000 (1 second). It's not available under WebGL! CloseAfterNoMesssage : If StartPingThread set to true, the plugin will close the connection and emit an OnError event if no message is received from the server in the given time. Its default value is 2 sec. It's not available under WebGL! InternalRequest : The internal HTTPRequest object the plugin uses to send the websocket upgrade request to the server. It's not available under WebGL! To customize this internal request, use the OnInternalRequestCreated callback: string token = \"...\"; var ws = new WebSocket(new Uri(\"wss://server.com/\")); ws.OnInternalRequestCreated += (ws, req) => req.AddHeader(\"Authentication\", $\"Bearer {token}\"); Extensions : IExtension implementations the plugin will negotiate with the server to use. It's not available under WebGL! Latency : If StartPingThread is set to true , the plugin going to calculate Latency from the ping-pong message round-trip times. It's not available under WebGL! LastMessageReceived : When the last message is received from the server. It's not available under WebGL! Context : LoggingContext instance used for logging. Per-Message Compression Extension The plugin enables and uses the Per-Message Compression Extension by default. It can be disabled by passing null as the last (extensions) parameter of the websocket constructor. To change defaults we can use the same constructor, but with a new PerMessageCompression object: using BestHTTP.WebSocket; using BestHTTP.WebSocket.Extensions; var perMessageCompressionExtension = new PerMessageCompression(/*compression level: */ BestHTTP.Decompression.Zlib.CompressionLevel.Default, /*clientNoContextTakeover: */ false, /*serverNoContextTakeover: */ false, /*clientMaxWindowBits: */ BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsMax, /*desiredServerMaxWindowBits: */ BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsMax, /*minDatalengthToCompress: */ PerMessageCompression.MinDataLengthToCompressDefault); var webSocket = new WebSocket(new Uri(\"wss://echo.websocket.org/\"), null, null, perMessageCompressionExtension); Extension usage depends on the server too, but if the server agrees to use the extension, the plugin can receive and send compressed messages automatically. Implementations The plugin now have three implementations: WebGL Under WebGL the plugin must use the underlying browser's WebSocket implementation . Browsers are exposing a limited API, hence not all features, methods and properties are available under this platform. HTTP/1 Upgrade This implementation uses HTTP/1 upgrade mechanism. This was the default for every non-webgl platform. If the server agrees on the upgrade the plugin creates a WebSocketResponse object (instead of the regular HTTPResponse ) to handle message sending and receiving. This WebSocketResponse object's lifetime is bound to its websocket object and it's possible to access it after the OnOpen event. Accessing it has little usage, but in a few cases it can be beneficial: void OnOpened(WebSocket webSocket) { (webSocket.InternalRequest.Response as WebSocketResponse).MaxFragmentSize = 16 * 1024; } WebSocket Over HTTP/2 This new implementation is based on RFC 8441 and uses an already open HTTP/2 connection that advertised itself as one that supports the Extended Connect method. If there's no open HTTP/2 connection the plugin uses the 'old' HTTP/1 based one. Because connecting over the already open HTTP/2 connection still can fail, the plugin can fallback to the HTTP/1 based one. When a fallback happens a new HTTPRequest object will be created by the new implementation and the OnInternalRequestCreated callback will be called again for this request too. If fallback is disabled WebSocket's OnError will be called. This implementation uses the underlying HTTP/2 connection's framing mechanism, the maximum fragment size is the one that the HTTP/2 connection negotiated. Both WebSocket Over HTTP/2 and its fallback mechanism can be disabled: // Disable WebSocket Over HTTP/2 HTTPManager.HTTP2Settings.WebSocketOverHTTP2Settings.EnableWebSocketOverHTTP2 = false; // Disable fallback mechanism HTTPManager.HTTP2Settings.WebSocketOverHTTP2Settings.EnableImplementationFallback = false; Pros of WebSocket Over HTTP/2: Less resource usage both on the client and server It doesn't have to do the TCP and TLS handshake round trips Better utilization of TCP","title":"Index"},{"location":"2.WebSocket/#websocket","text":"WebSocket is a high level protocol compared to plain TCP connections, while it keeps similiarities with its simple API. While they have similar naming too, it must be highlighted that a WebSocket connection must go through a HTTP upgrade process and it can't connect to a plain TCP socket that implements a custom protcol to exchange messages!","title":"WebSocket"},{"location":"2.WebSocket/#constructors","text":"Constructor to specify only the server's endpoint: var webSocket = new WebSocket(new Uri(\"wss://echo.websocket.org\")); Constructor to add origin, protocol and used extension information: var webSocket = new WebSocket(uri: new Uri(\"wss://echo.websocket.org\"), origin: \"echo.websocket.org\", protocol: \"Echo\", extensions: null); Warning The extension parameter isn't available under WebGL!","title":"Constructors"},{"location":"2.WebSocket/#events","text":"OnOpen : Called when connection to the server is established. After this event the WebSocket\u2019s IsOpen property will be True until we or the server closes the connection or if an error occurs. webSocket.OnOpen += OnWebSocketOpen; private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(\"WebSocket is now Open!\"); } OnMessage : Called when a textual message received from the server. webSocket.OnMessage += OnMessageReceived; private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(\"Text Message received from server: \" + message); } OnBinary : Called when a binary blob message received from the server. webSocket.OnBinary += OnBinaryMessageReceived; private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(\"Binary Message received from server. Length: \" + message.Length); } OnClosed : Called when the client or the server closes the connection. When the client closes the connection through the Close function it can provide a Code and a Message that indicates the reason for closing. The server typically will echoes our Code and Message back. webSocket.OnClosed += OnWebSocketClosed; private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(\"WebSocket is now Closed!\"); } OnError : Called when can\u2019t connect to the server, an internal error occurs or when the connection is lost. The second parameter is string describing the error. webSocket.OnError += OnError; void OnError(WebSocket ws, string error) { Debug.LogError(\"Error: \" + error); } Warning OnClose and OnError are mutually exclusive! When OnError is called no OnClosed going to be triggered. But, the connections is closed in both cases. When OnClose is called, the plugin could receive and send a close frame to the server and even if there were some kind of error (protocol error, too big message, etc), the tcp connection is healthy and the server could inform the client that it's about to close the connection. On the other hand, when OnError is called, that's because something really bad happened (tcp channel disconnected for example). In case when the editor is exiting from play mode, the plugin has no time sending a close frame to the server and waiting for an answer, so it just shuts down everything immediately. OnIncompleteFrame : Longer text or binary messages are fragmented, these fragments are assembled by the plugin automatically by default. This mechanism can be overwritten if we register an event handler to the WebSocket\u2019s OnIncompleteFrame event. This event called every time the client receives an incomplete fragment. If an event hanler is added to OnIncompleteFrame , incomplete fragments going to be ignored by the plugin and it doesn\u2019t try to assemble these nor store them. This event can be used to achieve streaming experience. It's not available under WebGL! OnInternalRequestCreated : Called when the internal HTTPRequest object created. The plugin might call it more than once for one WebSocket instance if it has to fall back from the HTTP/2 implementation to the HTTP/1 one. It's not available under WebGL.","title":"Events"},{"location":"2.WebSocket/#methods","text":"All methods are non-blocking, Open and Close just starts the opening and closing logic, Send places the data to a buffer that will be picked up by the sender thread. Open : Calling Open() we can start the connection procedure to the server. webSocket.Open(); Notice Just as other calls, Open is not a blocking call. Messages can be sent to the server after an OnOpen event. Send : Sending out text messages: webSocket.Send(\"Message to the Server\"); Sending out binary messages: // Allocate and fill up the buffer with data byte[] buffer = new byte[length]; webSocket.Send(buffer); Large messages (larger than 32767 bytes by default) are sent fragmented to the server. Websocket frames produced by the Send methods are placed into an internal queue and a sender thread going to send them one by one. The BufferedAmount property keeps track the amount of bytes sitting in this queue. Close : After all communication is done we should close the connection by calling the Close() method. webSocket.Close(); Notice You can\u2019t reuse a closed WebSocket instance, you have to create and setup a new one.","title":"Methods"},{"location":"2.WebSocket/#properties","text":"IsOpen : It's true if the websocket connection is open for sending and receiving. State : It's more verbose about the sate of the WebSocket than the IsOpen property. State can be Connecting , Open , Closing , Closed and Unknown . BufferedAmount : The amount of unsent, buffered up data in bytes. StartPingThread : Set to true to let the plugin send ping messages periodically to the server. Its default value is false. It's not available under WebGL! PingFrequency : The delay between two ping messages in milliseconds. Its default value is 1000 (1 second). It's not available under WebGL! CloseAfterNoMesssage : If StartPingThread set to true, the plugin will close the connection and emit an OnError event if no message is received from the server in the given time. Its default value is 2 sec. It's not available under WebGL! InternalRequest : The internal HTTPRequest object the plugin uses to send the websocket upgrade request to the server. It's not available under WebGL! To customize this internal request, use the OnInternalRequestCreated callback: string token = \"...\"; var ws = new WebSocket(new Uri(\"wss://server.com/\")); ws.OnInternalRequestCreated += (ws, req) => req.AddHeader(\"Authentication\", $\"Bearer {token}\"); Extensions : IExtension implementations the plugin will negotiate with the server to use. It's not available under WebGL! Latency : If StartPingThread is set to true , the plugin going to calculate Latency from the ping-pong message round-trip times. It's not available under WebGL! LastMessageReceived : When the last message is received from the server. It's not available under WebGL! Context : LoggingContext instance used for logging.","title":"Properties"},{"location":"2.WebSocket/#per-message-compression-extension","text":"The plugin enables and uses the Per-Message Compression Extension by default. It can be disabled by passing null as the last (extensions) parameter of the websocket constructor. To change defaults we can use the same constructor, but with a new PerMessageCompression object: using BestHTTP.WebSocket; using BestHTTP.WebSocket.Extensions; var perMessageCompressionExtension = new PerMessageCompression(/*compression level: */ BestHTTP.Decompression.Zlib.CompressionLevel.Default, /*clientNoContextTakeover: */ false, /*serverNoContextTakeover: */ false, /*clientMaxWindowBits: */ BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsMax, /*desiredServerMaxWindowBits: */ BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsMax, /*minDatalengthToCompress: */ PerMessageCompression.MinDataLengthToCompressDefault); var webSocket = new WebSocket(new Uri(\"wss://echo.websocket.org/\"), null, null, perMessageCompressionExtension); Extension usage depends on the server too, but if the server agrees to use the extension, the plugin can receive and send compressed messages automatically.","title":"Per-Message Compression Extension"},{"location":"2.WebSocket/#implementations","text":"The plugin now have three implementations:","title":"Implementations"},{"location":"2.WebSocket/#webgl","text":"Under WebGL the plugin must use the underlying browser's WebSocket implementation . Browsers are exposing a limited API, hence not all features, methods and properties are available under this platform.","title":"WebGL"},{"location":"2.WebSocket/#http1-upgrade","text":"This implementation uses HTTP/1 upgrade mechanism. This was the default for every non-webgl platform. If the server agrees on the upgrade the plugin creates a WebSocketResponse object (instead of the regular HTTPResponse ) to handle message sending and receiving. This WebSocketResponse object's lifetime is bound to its websocket object and it's possible to access it after the OnOpen event. Accessing it has little usage, but in a few cases it can be beneficial: void OnOpened(WebSocket webSocket) { (webSocket.InternalRequest.Response as WebSocketResponse).MaxFragmentSize = 16 * 1024; }","title":"HTTP/1 Upgrade"},{"location":"2.WebSocket/#websocket-over-http2","text":"This new implementation is based on RFC 8441 and uses an already open HTTP/2 connection that advertised itself as one that supports the Extended Connect method. If there's no open HTTP/2 connection the plugin uses the 'old' HTTP/1 based one. Because connecting over the already open HTTP/2 connection still can fail, the plugin can fallback to the HTTP/1 based one. When a fallback happens a new HTTPRequest object will be created by the new implementation and the OnInternalRequestCreated callback will be called again for this request too. If fallback is disabled WebSocket's OnError will be called. This implementation uses the underlying HTTP/2 connection's framing mechanism, the maximum fragment size is the one that the HTTP/2 connection negotiated. Both WebSocket Over HTTP/2 and its fallback mechanism can be disabled: // Disable WebSocket Over HTTP/2 HTTPManager.HTTP2Settings.WebSocketOverHTTP2Settings.EnableWebSocketOverHTTP2 = false; // Disable fallback mechanism HTTPManager.HTTP2Settings.WebSocketOverHTTP2Settings.EnableImplementationFallback = false; Pros of WebSocket Over HTTP/2: Less resource usage both on the client and server It doesn't have to do the TCP and TLS handshake round trips Better utilization of TCP","title":"WebSocket Over HTTP/2"},{"location":"3.1Socket.IO3/","text":"Socket.IO 3 Changes made in Socket.IO v3 (and Engine.IO v4) enables a less complex parser and message sending logic. To make the plugin's Socket.IO implementation a more user-friendly API with strongly typed callbacks, keeping backward compatibility became unaccomplishable. Breaking the backward compatibility however enabled to add even more features like volatile emits and new parsers. The old implementation is still available in the package, but with Socket.IO 3, i recommend to use classes from the new BestHTTP.SocketIO3 namespace. Notice Compatible with Socket.IO 4 too as Socket.IO 4 contains no protocol related changes . Connecting to a Socket.IO service First step to connect to a Socket.IO server is to create a SocketManager instance: using BestHTTP.SocketIO3; var manager = new SocketManager(new Uri(\"http://localhost:3000\")); The official Socket.IO server implementation binds to the /socket.io/ path, and the client going to append it to the uri if the uri's path part isn't present. By default SocketManager going to start to connect to the server as soon as a namespace is accessed through its Socket property or GetSocket function: using BestHTTP.SocketIO3; var manager = new SocketManager(new Uri(\"http://localhost:3000\")); // Accessing the root (\"/\") socket var root = manager.Socket; // or calling GetSocket triggers the connection procedure. var customNamespace = manager.GetSocket(\"/my_namespace\"); // At this point the manager already started to connect to the server This auto connection can be disabled through a SocketOptions instance: using BestHTTP.SocketIO3; SocketOptions options = new SocketOptions(); options.AutoConnect = false; var manager = new SocketManager(new Uri(\"http://localhost:3000\"), options); var root = manager.Socket; var customNamespace = manager.GetSocket(\"/my_namespace\"); // AutoConnect is turned off, Open must be called manager.Open(); This way the SocketManager going to start to connect to the server when its Open function is called. Open and connection to the server in general is non-blocking, the function returns immediately and messages are sent only after the connect event. Warning Don't forget that the new implementation is under the BestHTTP.SocketIO3 namespace! Socket IDs As of Socket.IO 3 the connection has an ID and all namespaces (sockets) has a different one too. The connection's ID can be accessed through the SocketManager \u2019s Handshake property: var manager = new SocketManager(new Uri(\"http://localhost:3000\")); manager.Socket.On(\"connect\", () => Debug.Log(manager.Handshake.Sid)); Per-socket ID is received when the socket is connected, can be accessed through the connect event as a parameter, or later through the socket instance: manager = new SocketManager(new Uri(\"http://localhost:3000\"), options); manager.Socket.On<ConnectResponse>(SocketIOEventTypes.Connect, OnConnected); void OnConnected(ConnectResponse resp) { // Method 1: received as parameter Debug.Log(\"Sid through parameter: \" + resp.sid); // Method 2: access through the socket Debug.Log(\"Sid through socket: \" + manager.Socket.Id); } ConnectResponse 's sid and Socket 's Id is the same value. Notice ConnectResponse can be found in the BestHTTP.SocketIO3.Events namespace. Disconnecting SocketManager 's Close function closes all sockets, shuts down the transport and no more communication is done to the server. Calling Disconnect on a socket disconnects only that socket, communication through other sockets are still possible. Disconnecting the last socket closes the SocketManager too. Subscribing to events Subscribing to Socket.IO events can be done through the On and Once functions. There's also an ExpectAcknowledgement function that can be used to define a callbacks that going to be called when the server executes a callback function . Parameterless events All functions to subscribe to events support parameterless events. These events aren't expects any parameters from the servers: manager.Socket.On(\"connect\", () => Debug.Log(\"connected!\")); Strongly typed events Both On and Once can accept numerous type parameters and tries to parse the received event to match these types. For example the following call on the server: socket.emit('message', 0, 1); Thi event can be caught with the followin subscription on the client: manager.Socket.On<int, int>(\"message\", (arg1, arg2) => Debug.Log($\"{arg1}, {arg2}\")); Here we subscribe to the event called \"message\" , expecting two int parameters. Complex objects can be sent and subscribed to (Server): socket.emit(\"user-info\", { users: [\"User 1\", \"User 2\"], buff: Buffer.from([9, 8, 7, 6, 5, 4, 3, 2, 1]) }); (Client:) class UserInfo { public string[] users; public byte[] buff; } manager.Socket.On<UserInfo>(\"user-info\", OnUserInfo); private void OnUserInfo(UserInfo userInfo) { Debug.Log($\"user-info: {string.Join(\",\", userInfo.users)}, buff: {userInfo.buff.Length}\"); } By default any additional fields that present in the receiving type that has no corresponding field in the json going to be initialized to its default value. Binary data can be sent alone too (Server): socket.emit('binary', Buffer.from([9, 8, 7, 6, 5, 4, 3, 2, 1])); (Client:) manager.Socket.On<byte[]>(\"binary\", OnBinaryMessage); private void OnBinaryMessage(byte[] buffer) { Debug.Log(\"OnBinaryMessage: \" + buffer.Length); } Inject SocketManager and Socket as callback parameters While the client parse the parameters it can inject the SocketManager or the receiving Socket instance (Server) into the parameter list: socket.emit('binary', Buffer.from([9, 8, 7, 6, 5, 4, 3, 2, 1])); (Client:) manager.Socket.On<SocketManager, Socket, byte[]>(\"binary\", OnBinaryMessage); private void OnBinaryMessage(SocketManager manager, Socket socket, byte[] buffer) { Debug.Log(\"OnBinaryMessage: \" + buffer.Length); } Acknowledgements With ExpectAcknowledgement we can set a callback that's going to be called (Client): class ReturnVal { public int code; public string msg; } manager.Socket.ExpectAcknowledgement<ReturnVal>(OnAcknowledgements).Emit(\"chat message\", \"msg 1\"); private void OnAcknowledgements(ReturnVal value) { Debug.Log($\"{value.code}, '{value.msg}'\"); } (Server:) socket.on('chat message', (msg, ack_callback) => { ack_callback({ code: 102, msg: 'ok ' + msg }); }); Special Events connect and error events are special as their type parameters are already defined. connect emits a ConnectResponse object that have only one field sid : manager.Socket.On<ConnectResponse>(SocketIOEventTypes.Connect, OnConnected); void OnConnected(ConnectResponse resp) { Debug.Log(\"Connected sid: \" + resp.sid); } Specifying a different type parameter for connect will produce an error. On the other hand, while error has a predefined Error type with a message property a new, custom error type can be created and used. For example a server side middleware might want to send additional data other than just a plain text: io.use((socket, next) => { const err = new Error(\"not authorized\"); err.data = { content: \"Please retry later\", code: 101 }; next(err); }); class ErrorData { public int code; public string content; } // Error already defines the message property class CustomError : Error { public ErrorData data; public override string ToString() { return $\"[CustomError {message}, {data?.code}, {data?.content}]\"; } } manager.Socket.On<CustomError>(SocketIOEventTypes.Error, OnError); void OnError(CustomError args) { Debug.LogError(string.Format(\"Error: {0}\", args.ToString())); } Sending Events Sending an event can be done with the Emit function: manager.Socket.Emit(\"chat message\", \"msg 1\"); Its first parameter is the name of the event, followed by any number of parameters. Volatile Events A volatile event isn't sent when the client can't send it right there. When no transport is ready to send a volatile event, instead of buffereing to send it later it's going to be discarded. An event can be marked as volatile by calling Volatile() on the socket first: manager.Socket.Volatile().Emit(\"chat message\", \"msg\"); Namespaces SocketManager 's Socket property is bound to the root ('/') namespace. Every subscription and event sent through this is sent to the root namespace. New namespaces can be accesses and connected to through the GetSocket function: manager.GetSocket(\"/customNamespace\").On(SocketIOEventTypes.Connect, OnNameSpaceConnected); Rooms Rooms are completely server-side features, no client support required! Options You can pass a SocketOptions instance to the SocketManager\u2019s constructor. You can change the following options: AdditionalQueryParams : Additional query parameters that will be passed for accessed uris. If the value is null, or an empty string it will be not appended to the query only the key. The keys and values must be escaped properly, as the plugin will not escape these. SocketOptions options = new SocketOptions(); options.AdditionalQueryParams = new PlatformSupport.Collections.ObjectModel.ObservableDictionary<string, string>(); options.AdditionalQueryParams.Add(\"token\", \"< token value >\"); var manager = new SocketManager(new Uri(\"http://localhost:3000\"), options); Reconnection : Whether to reconnect automatically after a disconnect. Its default value is true. ReconnectionAttempts : Number of attempts before giving up. Its default value is Int.MaxValue. ReconnectionDelay : How long to initially wait before attempting a new reconnection. Affected by +/- RandomizationFactor. For example the default initial delay will be between 500ms to 1500ms. Its default value is 1000ms. ReconnectionDelayMax : Maximum amount of time to wait between reconnections. Each attempt increases the reconnection delay along with a randomization as above. Its default value is 5000ms. RandomizationFactor : It can be used to control the ReconnectionDelay range. Its default value is 0.5 and can be set between the 0..1 values inclusive. Timeout : Connection timeout before a \"connect_error\" and \"connect_timeout\" events are emitted. It\u2019s not the underlying tcp socket\u2019s connection timeout, it\u2019s for the socket.io protocol. Its default value is is 20000ms. AutoConnect : By setting this false, you have to call SocketManager's Open() whenever you decide it's appropriate. ConnectWith : The SocketManager will try to connect with the transport set to this property. It can be TransportTypes.Polling or TransportTypes.WebSocket. HTTPRequestCustomizationCallback : A callback that called for every HTTPRequest the socket.io protocol sends out. It can be used to further customize (add additional headers for example) requests. This callback is called for Websocket upgrade requests too on non-WebGL platforms. Auth : Connecting to a namespace a client can send payload data. When the Auth callback function is set, the plugin going to call it when connecting to a namespace. Its return value going to be serialized by the Parser. When you create a new SocketOptions object its properties are set to theirs default values. SocketOptions options = new SocketOptions(); options.Auth = (manager, socket) => new { token = \"<token>\" }; var manager = new SocketManager(new Uri(\"http://localhost:3000\"), options); Reconnection When there's a timeout or the transport disconnects from the server unintentionally the SocketOptions' Reconnection is true, the manager tries to reconnect to the server. Reconnect logic can be modified through SocketOptions. Emitted events All light blue rounded rectangles int this flow chart can be subscribed to: As described above connect and error are special events witch means they have parameters. Other emitted events have no parameters (other than the possibility of injecting SocketManager and Socket instances): manager.Socket.On(\"connecting\", () => Debug.Log(\"connecting\")); manager.Socket.On(\"reconnect\", () => Debug.Log(\"reconnect\")); manager.Socket.On(\"reconnecting\", () => Debug.Log(\"reconnecting\")); // ... Parsers By default the SocketManager uses a JSon parser and LitJson to encode/decode objects. It's also capable to send and receive MsgPack encoded messages if the server uses socket.io-msgpack-parser . To enable and use it, follow these steps: Download and import the Json & MessagePack Serialization package Create a new Asembly Definition file under the Plugins\\GameDevWare.Serialization folder Locate the BestHTTP.asmdef file under the Best HTTP folder Reference the newly create asmdef file and press Apply: Add the BESTHTTP_SOCKETIO_ENABLE_GAMEDEVWARE_MESSAGEPACK define to the Scripting Define Symbols input under PlayerSettings/Other Settings : Use the now available MsgPackParser class: var manager = new SocketManager(new Uri(\"http://localhost:3000\")); manager.Parser = new MsgPackParser(); The MsgPackParser class can be found in the Best HTTP\\Examples\\Socket.IO3\\Parsers\\ folder.","title":"Socket.IO 3"},{"location":"3.1Socket.IO3/#socketio-3","text":"Changes made in Socket.IO v3 (and Engine.IO v4) enables a less complex parser and message sending logic. To make the plugin's Socket.IO implementation a more user-friendly API with strongly typed callbacks, keeping backward compatibility became unaccomplishable. Breaking the backward compatibility however enabled to add even more features like volatile emits and new parsers. The old implementation is still available in the package, but with Socket.IO 3, i recommend to use classes from the new BestHTTP.SocketIO3 namespace. Notice Compatible with Socket.IO 4 too as Socket.IO 4 contains no protocol related changes .","title":"Socket.IO 3"},{"location":"3.1Socket.IO3/#connecting-to-a-socketio-service","text":"First step to connect to a Socket.IO server is to create a SocketManager instance: using BestHTTP.SocketIO3; var manager = new SocketManager(new Uri(\"http://localhost:3000\")); The official Socket.IO server implementation binds to the /socket.io/ path, and the client going to append it to the uri if the uri's path part isn't present. By default SocketManager going to start to connect to the server as soon as a namespace is accessed through its Socket property or GetSocket function: using BestHTTP.SocketIO3; var manager = new SocketManager(new Uri(\"http://localhost:3000\")); // Accessing the root (\"/\") socket var root = manager.Socket; // or calling GetSocket triggers the connection procedure. var customNamespace = manager.GetSocket(\"/my_namespace\"); // At this point the manager already started to connect to the server This auto connection can be disabled through a SocketOptions instance: using BestHTTP.SocketIO3; SocketOptions options = new SocketOptions(); options.AutoConnect = false; var manager = new SocketManager(new Uri(\"http://localhost:3000\"), options); var root = manager.Socket; var customNamespace = manager.GetSocket(\"/my_namespace\"); // AutoConnect is turned off, Open must be called manager.Open(); This way the SocketManager going to start to connect to the server when its Open function is called. Open and connection to the server in general is non-blocking, the function returns immediately and messages are sent only after the connect event. Warning Don't forget that the new implementation is under the BestHTTP.SocketIO3 namespace!","title":"Connecting to a Socket.IO service"},{"location":"3.1Socket.IO3/#socket-ids","text":"As of Socket.IO 3 the connection has an ID and all namespaces (sockets) has a different one too. The connection's ID can be accessed through the SocketManager \u2019s Handshake property: var manager = new SocketManager(new Uri(\"http://localhost:3000\")); manager.Socket.On(\"connect\", () => Debug.Log(manager.Handshake.Sid)); Per-socket ID is received when the socket is connected, can be accessed through the connect event as a parameter, or later through the socket instance: manager = new SocketManager(new Uri(\"http://localhost:3000\"), options); manager.Socket.On<ConnectResponse>(SocketIOEventTypes.Connect, OnConnected); void OnConnected(ConnectResponse resp) { // Method 1: received as parameter Debug.Log(\"Sid through parameter: \" + resp.sid); // Method 2: access through the socket Debug.Log(\"Sid through socket: \" + manager.Socket.Id); } ConnectResponse 's sid and Socket 's Id is the same value. Notice ConnectResponse can be found in the BestHTTP.SocketIO3.Events namespace.","title":"Socket IDs"},{"location":"3.1Socket.IO3/#disconnecting","text":"SocketManager 's Close function closes all sockets, shuts down the transport and no more communication is done to the server. Calling Disconnect on a socket disconnects only that socket, communication through other sockets are still possible. Disconnecting the last socket closes the SocketManager too.","title":"Disconnecting"},{"location":"3.1Socket.IO3/#subscribing-to-events","text":"Subscribing to Socket.IO events can be done through the On and Once functions. There's also an ExpectAcknowledgement function that can be used to define a callbacks that going to be called when the server executes a callback function .","title":"Subscribing to events"},{"location":"3.1Socket.IO3/#parameterless-events","text":"All functions to subscribe to events support parameterless events. These events aren't expects any parameters from the servers: manager.Socket.On(\"connect\", () => Debug.Log(\"connected!\"));","title":"Parameterless events"},{"location":"3.1Socket.IO3/#strongly-typed-events","text":"Both On and Once can accept numerous type parameters and tries to parse the received event to match these types. For example the following call on the server: socket.emit('message', 0, 1); Thi event can be caught with the followin subscription on the client: manager.Socket.On<int, int>(\"message\", (arg1, arg2) => Debug.Log($\"{arg1}, {arg2}\")); Here we subscribe to the event called \"message\" , expecting two int parameters. Complex objects can be sent and subscribed to (Server): socket.emit(\"user-info\", { users: [\"User 1\", \"User 2\"], buff: Buffer.from([9, 8, 7, 6, 5, 4, 3, 2, 1]) }); (Client:) class UserInfo { public string[] users; public byte[] buff; } manager.Socket.On<UserInfo>(\"user-info\", OnUserInfo); private void OnUserInfo(UserInfo userInfo) { Debug.Log($\"user-info: {string.Join(\",\", userInfo.users)}, buff: {userInfo.buff.Length}\"); } By default any additional fields that present in the receiving type that has no corresponding field in the json going to be initialized to its default value. Binary data can be sent alone too (Server): socket.emit('binary', Buffer.from([9, 8, 7, 6, 5, 4, 3, 2, 1])); (Client:) manager.Socket.On<byte[]>(\"binary\", OnBinaryMessage); private void OnBinaryMessage(byte[] buffer) { Debug.Log(\"OnBinaryMessage: \" + buffer.Length); }","title":"Strongly typed events"},{"location":"3.1Socket.IO3/#inject-socketmanager-and-socket-as-callback-parameters","text":"While the client parse the parameters it can inject the SocketManager or the receiving Socket instance (Server) into the parameter list: socket.emit('binary', Buffer.from([9, 8, 7, 6, 5, 4, 3, 2, 1])); (Client:) manager.Socket.On<SocketManager, Socket, byte[]>(\"binary\", OnBinaryMessage); private void OnBinaryMessage(SocketManager manager, Socket socket, byte[] buffer) { Debug.Log(\"OnBinaryMessage: \" + buffer.Length); }","title":"Inject SocketManager and Socket as callback parameters"},{"location":"3.1Socket.IO3/#acknowledgements","text":"With ExpectAcknowledgement we can set a callback that's going to be called (Client): class ReturnVal { public int code; public string msg; } manager.Socket.ExpectAcknowledgement<ReturnVal>(OnAcknowledgements).Emit(\"chat message\", \"msg 1\"); private void OnAcknowledgements(ReturnVal value) { Debug.Log($\"{value.code}, '{value.msg}'\"); } (Server:) socket.on('chat message', (msg, ack_callback) => { ack_callback({ code: 102, msg: 'ok ' + msg }); });","title":"Acknowledgements"},{"location":"3.1Socket.IO3/#special-events","text":"connect and error events are special as their type parameters are already defined. connect emits a ConnectResponse object that have only one field sid : manager.Socket.On<ConnectResponse>(SocketIOEventTypes.Connect, OnConnected); void OnConnected(ConnectResponse resp) { Debug.Log(\"Connected sid: \" + resp.sid); } Specifying a different type parameter for connect will produce an error. On the other hand, while error has a predefined Error type with a message property a new, custom error type can be created and used. For example a server side middleware might want to send additional data other than just a plain text: io.use((socket, next) => { const err = new Error(\"not authorized\"); err.data = { content: \"Please retry later\", code: 101 }; next(err); }); class ErrorData { public int code; public string content; } // Error already defines the message property class CustomError : Error { public ErrorData data; public override string ToString() { return $\"[CustomError {message}, {data?.code}, {data?.content}]\"; } } manager.Socket.On<CustomError>(SocketIOEventTypes.Error, OnError); void OnError(CustomError args) { Debug.LogError(string.Format(\"Error: {0}\", args.ToString())); }","title":"Special Events"},{"location":"3.1Socket.IO3/#sending-events","text":"Sending an event can be done with the Emit function: manager.Socket.Emit(\"chat message\", \"msg 1\"); Its first parameter is the name of the event, followed by any number of parameters.","title":"Sending Events"},{"location":"3.1Socket.IO3/#volatile-events","text":"A volatile event isn't sent when the client can't send it right there. When no transport is ready to send a volatile event, instead of buffereing to send it later it's going to be discarded. An event can be marked as volatile by calling Volatile() on the socket first: manager.Socket.Volatile().Emit(\"chat message\", \"msg\");","title":"Volatile Events"},{"location":"3.1Socket.IO3/#namespaces","text":"SocketManager 's Socket property is bound to the root ('/') namespace. Every subscription and event sent through this is sent to the root namespace. New namespaces can be accesses and connected to through the GetSocket function: manager.GetSocket(\"/customNamespace\").On(SocketIOEventTypes.Connect, OnNameSpaceConnected);","title":"Namespaces"},{"location":"3.1Socket.IO3/#rooms","text":"Rooms are completely server-side features, no client support required!","title":"Rooms"},{"location":"3.1Socket.IO3/#options","text":"You can pass a SocketOptions instance to the SocketManager\u2019s constructor. You can change the following options: AdditionalQueryParams : Additional query parameters that will be passed for accessed uris. If the value is null, or an empty string it will be not appended to the query only the key. The keys and values must be escaped properly, as the plugin will not escape these. SocketOptions options = new SocketOptions(); options.AdditionalQueryParams = new PlatformSupport.Collections.ObjectModel.ObservableDictionary<string, string>(); options.AdditionalQueryParams.Add(\"token\", \"< token value >\"); var manager = new SocketManager(new Uri(\"http://localhost:3000\"), options); Reconnection : Whether to reconnect automatically after a disconnect. Its default value is true. ReconnectionAttempts : Number of attempts before giving up. Its default value is Int.MaxValue. ReconnectionDelay : How long to initially wait before attempting a new reconnection. Affected by +/- RandomizationFactor. For example the default initial delay will be between 500ms to 1500ms. Its default value is 1000ms. ReconnectionDelayMax : Maximum amount of time to wait between reconnections. Each attempt increases the reconnection delay along with a randomization as above. Its default value is 5000ms. RandomizationFactor : It can be used to control the ReconnectionDelay range. Its default value is 0.5 and can be set between the 0..1 values inclusive. Timeout : Connection timeout before a \"connect_error\" and \"connect_timeout\" events are emitted. It\u2019s not the underlying tcp socket\u2019s connection timeout, it\u2019s for the socket.io protocol. Its default value is is 20000ms. AutoConnect : By setting this false, you have to call SocketManager's Open() whenever you decide it's appropriate. ConnectWith : The SocketManager will try to connect with the transport set to this property. It can be TransportTypes.Polling or TransportTypes.WebSocket. HTTPRequestCustomizationCallback : A callback that called for every HTTPRequest the socket.io protocol sends out. It can be used to further customize (add additional headers for example) requests. This callback is called for Websocket upgrade requests too on non-WebGL platforms. Auth : Connecting to a namespace a client can send payload data. When the Auth callback function is set, the plugin going to call it when connecting to a namespace. Its return value going to be serialized by the Parser. When you create a new SocketOptions object its properties are set to theirs default values. SocketOptions options = new SocketOptions(); options.Auth = (manager, socket) => new { token = \"<token>\" }; var manager = new SocketManager(new Uri(\"http://localhost:3000\"), options);","title":"Options"},{"location":"3.1Socket.IO3/#reconnection","text":"When there's a timeout or the transport disconnects from the server unintentionally the SocketOptions' Reconnection is true, the manager tries to reconnect to the server. Reconnect logic can be modified through SocketOptions.","title":"Reconnection"},{"location":"3.1Socket.IO3/#emitted-events","text":"All light blue rounded rectangles int this flow chart can be subscribed to: As described above connect and error are special events witch means they have parameters. Other emitted events have no parameters (other than the possibility of injecting SocketManager and Socket instances): manager.Socket.On(\"connecting\", () => Debug.Log(\"connecting\")); manager.Socket.On(\"reconnect\", () => Debug.Log(\"reconnect\")); manager.Socket.On(\"reconnecting\", () => Debug.Log(\"reconnecting\")); // ...","title":"Emitted events"},{"location":"3.1Socket.IO3/#parsers","text":"By default the SocketManager uses a JSon parser and LitJson to encode/decode objects. It's also capable to send and receive MsgPack encoded messages if the server uses socket.io-msgpack-parser . To enable and use it, follow these steps: Download and import the Json & MessagePack Serialization package Create a new Asembly Definition file under the Plugins\\GameDevWare.Serialization folder Locate the BestHTTP.asmdef file under the Best HTTP folder Reference the newly create asmdef file and press Apply: Add the BESTHTTP_SOCKETIO_ENABLE_GAMEDEVWARE_MESSAGEPACK define to the Scripting Define Symbols input under PlayerSettings/Other Settings : Use the now available MsgPackParser class: var manager = new SocketManager(new Uri(\"http://localhost:3000\")); manager.Parser = new MsgPackParser(); The MsgPackParser class can be found in the Best HTTP\\Examples\\Socket.IO3\\Parsers\\ folder.","title":"Parsers"},{"location":"3.Socket.IO/","text":"SocketIO Warning With the release of the BestHTTP.SocketIO3 namespace to support Socket.IO 3 and 4 , this implementation entered into maintenance only mode receiving only bugfixes. The Socket.IO implementation uses features that the plugin already have. It will send HTTPRequest s to get the handshake data, sending and receiving packets when the polling transport is used with all of its features(cookies, connection reuse, etc.). And the WebSocket implementation is used for the WebSocket transport. Brief feature list of this Socket.IO implementation: Easy to use and familiar api Compatible with the latest Socket.IO specification Seamless upgrade from polling transport to websocket transport Automatic reconnect on disconnect Easy and efficient binary data sending and multiple ways of receiving Powerful tools to use it in an advanced mode(switch the default encoder, disable auto-decoding, etc.) If you want to connect to a Socket.IO service you can do it using the BestHTTP.SocketIO.SocketManager class. First you have to create a SocketManager instance: using System; using BestHTTP; using BestHTTP.SocketIO; var manager = new SocketManager(new Uri(\"https://socket-io-chat.now.sh/socket.io/\")); Notice The /socket.io/ path in the url is very important, by default the Socket.IO server will listen on this query. So don\u2019t forget to append it to your test url too! Socket.IO 3 and 4 support For Socket.IO 3 and up, use classes from the BestHTTP.SocketIO3 namespace!","title":"SocketIO"},{"location":"3.Socket.IO/#socketio","text":"Warning With the release of the BestHTTP.SocketIO3 namespace to support Socket.IO 3 and 4 , this implementation entered into maintenance only mode receiving only bugfixes. The Socket.IO implementation uses features that the plugin already have. It will send HTTPRequest s to get the handshake data, sending and receiving packets when the polling transport is used with all of its features(cookies, connection reuse, etc.). And the WebSocket implementation is used for the WebSocket transport. Brief feature list of this Socket.IO implementation: Easy to use and familiar api Compatible with the latest Socket.IO specification Seamless upgrade from polling transport to websocket transport Automatic reconnect on disconnect Easy and efficient binary data sending and multiple ways of receiving Powerful tools to use it in an advanced mode(switch the default encoder, disable auto-decoding, etc.) If you want to connect to a Socket.IO service you can do it using the BestHTTP.SocketIO.SocketManager class. First you have to create a SocketManager instance: using System; using BestHTTP; using BestHTTP.SocketIO; var manager = new SocketManager(new Uri(\"https://socket-io-chat.now.sh/socket.io/\")); Notice The /socket.io/ path in the url is very important, by default the Socket.IO server will listen on this query. So don\u2019t forget to append it to your test url too!","title":"SocketIO"},{"location":"3.Socket.IO/#socketio-3-and-4-support","text":"For Socket.IO 3 and up, use classes from the BestHTTP.SocketIO3 namespace!","title":"Socket.IO 3 and 4 support"},{"location":"3.Socket.IO/1.Namespaces/","text":"Connecting to namespaces By default the SocketManager will connect to the root(\"/\") namespace while connecting to the server. You can access it through the SocketManager\u2019s Socket property: Socket root = manager.Socket; Non-default namespaces can be accessed through the GetSocket(\"/nspName\") function or through the manager\u2019s indexer property: Socket nsp = manager[\"/customNamespace\"]; // the same as this method: Socket nsp = manager.GetSocket(\"/customNamespace\"); First access to a namespace will start the internal connection process.","title":"Connecting to namespaces"},{"location":"3.Socket.IO/1.Namespaces/#connecting-to-namespaces","text":"By default the SocketManager will connect to the root(\"/\") namespace while connecting to the server. You can access it through the SocketManager\u2019s Socket property: Socket root = manager.Socket; Non-default namespaces can be accessed through the GetSocket(\"/nspName\") function or through the manager\u2019s indexer property: Socket nsp = manager[\"/customNamespace\"]; // the same as this method: Socket nsp = manager.GetSocket(\"/customNamespace\"); First access to a namespace will start the internal connection process.","title":"Connecting to namespaces"},{"location":"3.Socket.IO/2.ReceivingEvents/","text":"Subscribing and receiving events You can subscribe to predefined and custom events. Predefined events are \"connect\", \"connecting\", \"event\", \"disconnect\", \"reconnect\", \"reconnecting\", \"reconnect_attempt\", \"reconnect_failed\", \"error\". Custom events are programmer defined events that your server will send to your client. You can subscribe to an event by calling a socket\u2019s On function: manager.Socket.On(\"login\", OnLogin); manager.Socket.On(\"new message\", OnNewMessage); An event handler will look like this: void OnLogin(Socket socket, Packet packet, params object[] args) { } The socket parameter will be the namespace-socket object that the server sent this event. The packet parameter contains the internal packet data of the event. The packet can be used to access binary data sent by the server, or to use a custom Json parser lib to decode the payload data. More on these later. The args parameter is a variable length array that contains the decoded objects from the packet\u2019s payload data. With the default Json encoder these parameters can be \u2018primitive\u2019 types( int, double, string ) or list of objects( List<object> ) or Dictionary <string, object> for objects. A message emitted on the server(node.js): // send a message to the client socket.emit('message', 'MyNick', 'Msg to the client'); can be caught by the client: // subscribe to the \"message\" event manager.Socket.On(\"message\", OnMessage); // event handler void OnMessage(Socket socket, Packet packet, params object[] args) { // args[0] is the nick of the sender // args[1] is the message Debug.Log(string.Format(\"Message from {0}: {1}\", args[0], args[1])); } Predefined events \"connect\": Sent when the namespace opens. \"connecting\": Sent when the SocketManager start to connect to the socket.io server. \"event\": Sent on custom (programmer defined) events. \"disconnect\": Sent when the transport disconnects, SocketManager is closed, Socket is closed or when no Pong message received from the server in the given time specified in the handshake data. \"reconnect\": Sent when the plugin successfully reconnected to the socket.io server. \"reconnecting\": Sent when the plugin will try to reconnect to the socket.io server. \"reconnect_attempt\": Sent when the plugin will try to reconnect to the socket.io server. \"reconnect_failed\": Sent when a reconnect attempt fails to connect to the server and the ReconnectAttempt reaches the options\u2019 ReconnectionAttempts\u2019 value. \"error\": Sent on server or internal plugin errors. The event\u2019s only argument will be a BestHTTP.SocketIO.Error object. Other event-related functions: Once: you can subscribe to an event that will be called only once. // The event handler will be called only once manager.Socket.Once(\"connect\", OnConnected); Off: you can remove all event subscription, or just only one. // Removes all event-handlers manager.Socket.Off(); // Removes event-handlers from the \"connect\" event manager.Socket.Off(\"connect\"); // Removes the OnConnected event-handler from the \"connect\" event manager.Socket.Off(\"connect\", OnConnected);","title":"Subscribing and receiving events"},{"location":"3.Socket.IO/2.ReceivingEvents/#subscribing-and-receiving-events","text":"You can subscribe to predefined and custom events. Predefined events are \"connect\", \"connecting\", \"event\", \"disconnect\", \"reconnect\", \"reconnecting\", \"reconnect_attempt\", \"reconnect_failed\", \"error\". Custom events are programmer defined events that your server will send to your client. You can subscribe to an event by calling a socket\u2019s On function: manager.Socket.On(\"login\", OnLogin); manager.Socket.On(\"new message\", OnNewMessage); An event handler will look like this: void OnLogin(Socket socket, Packet packet, params object[] args) { } The socket parameter will be the namespace-socket object that the server sent this event. The packet parameter contains the internal packet data of the event. The packet can be used to access binary data sent by the server, or to use a custom Json parser lib to decode the payload data. More on these later. The args parameter is a variable length array that contains the decoded objects from the packet\u2019s payload data. With the default Json encoder these parameters can be \u2018primitive\u2019 types( int, double, string ) or list of objects( List<object> ) or Dictionary <string, object> for objects. A message emitted on the server(node.js): // send a message to the client socket.emit('message', 'MyNick', 'Msg to the client'); can be caught by the client: // subscribe to the \"message\" event manager.Socket.On(\"message\", OnMessage); // event handler void OnMessage(Socket socket, Packet packet, params object[] args) { // args[0] is the nick of the sender // args[1] is the message Debug.Log(string.Format(\"Message from {0}: {1}\", args[0], args[1])); }","title":"Subscribing and receiving events"},{"location":"3.Socket.IO/2.ReceivingEvents/#predefined-events","text":"\"connect\": Sent when the namespace opens. \"connecting\": Sent when the SocketManager start to connect to the socket.io server. \"event\": Sent on custom (programmer defined) events. \"disconnect\": Sent when the transport disconnects, SocketManager is closed, Socket is closed or when no Pong message received from the server in the given time specified in the handshake data. \"reconnect\": Sent when the plugin successfully reconnected to the socket.io server. \"reconnecting\": Sent when the plugin will try to reconnect to the socket.io server. \"reconnect_attempt\": Sent when the plugin will try to reconnect to the socket.io server. \"reconnect_failed\": Sent when a reconnect attempt fails to connect to the server and the ReconnectAttempt reaches the options\u2019 ReconnectionAttempts\u2019 value. \"error\": Sent on server or internal plugin errors. The event\u2019s only argument will be a BestHTTP.SocketIO.Error object.","title":"Predefined events"},{"location":"3.Socket.IO/2.ReceivingEvents/#other-event-related-functions","text":"Once: you can subscribe to an event that will be called only once. // The event handler will be called only once manager.Socket.Once(\"connect\", OnConnected); Off: you can remove all event subscription, or just only one. // Removes all event-handlers manager.Socket.Off(); // Removes event-handlers from the \"connect\" event manager.Socket.Off(\"connect\"); // Removes the OnConnected event-handler from the \"connect\" event manager.Socket.Off(\"connect\", OnConnected);","title":"Other event-related functions:"},{"location":"3.Socket.IO/3.SendingEvents/","text":"Sending events You can send an event with the Emit function. You have to pass the event name as the first parameter and optionally other parameters. These will be encoded to json and will be sent to the server. Optionally you can set a callback function that will be called when the server processes the event(you have to set up the server code properly to be able to send back a callback function. See the Socket.IO server side documentation for more information). // Send a custom event to the server with two parameters manager.Socket.Emit(\"message\", \"userName\", \"message\"); // Send an event and define a callback function that will be called as an // acknowledgement of this event manager.Socket.Emit(\"custom event\", OnAckCallback, \"param 1\", \"param 2\"); void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(\"OnAckCallback!\"); } Sending acknowledgement to the server You can send back an acknowledgement to the server by calling the socket\u2019s EmitAck function. You have to pass the original packet and any optional data: manager[\"/customNamespace\"].On(\"customEvent\", (socket, packet, args) => { socket.EmitAck(packet, \"Event\", \"Received\", \"Successfully\"); }); You can keep a reference to the packet, and call the EmitAck from somewhere else. Sending binary data There are two ways of sending binary(byte[]) data. By passing to the Emit function the plugin will scan the parameters and if it founds one, it will convert it to a binary attachment(as introduced in Socket.IO 1.0). This is the most efficient way, because it will not convert the byte array to a Base64 encoded string on client side, and back to binary on server side. byte[] data = new byte[10]; //... manager.Socket.Emit(\"eventWithBinary\", \"textual param\", data); If the binary data is embedded in an object as a field or property the Json encoder must support the conversion. The default Json encoder can\u2019t convert the embedded binary data to Json, you have to use a more advanced Json parser library (like \"JSON .NET For Unity\" ) Receiving binary data In the Socket.IO server when binary data sent to the client it will replace the data with a Json object({'_placeholder':true,'num':xyz}) and will send the binary data in another packet. On client side these packets will be collected and will be merged into one packet. The binary data will be in the packet\u2019s Attachments property. Here you will have some options too to use this packet: In your event-handler you can access all binary data through the packet\u2019s Attachments property. Socket.On(\"frame\", OnFrame); void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } The second option is almost the same as the previous, with a little improvement: we will not decode the sent Json string to c# objects. We can do it because we know that the server sent only the binary data, no other information came with this event. So we will let the plugin know that do not decode the payload: // Subscribe to the \"frame\" event, and set the autoDecodePayload flag to false Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); void OnFrame(Socket socket, Packet packet, params object[] args) { // Use the Attachments property as before texture.LoadImage(packet.Attachments[0]); } The autoDecodePayload parameter is true by default. We can replace back the \"{'_placeholder':true,'num':xyz}\" string to the index of the attachment in the Attachments list. Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); void OnFrame(Socket socket, Packet packet, params object[] args) { // Replace the Json object with the index packet.ReconstructAttachmentAsIndex(); // now, decode the Payload to an object[] args = packet.Decode(socket.Manager.Encoder); // args now contains only an index number (probably 0) byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); } We can replace the \"{'_placeholder':true,'num':xyz}\" string with the binary data from the Attachments converted to a Base64 encoded string. Advanced Json parsers can convert it to byte arrays when they have to set it to an object\u2019s field or property. Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); void OnFrame(Socket socket, Packet packet, params object[] args) { // Replace the Json object with the Base64 encoded string packet.ReconstructAttachmentAsBase64(); // now, decode the Payload to an object[] args = packet.Decode(socket.Manager.Encoder); // args now contains a Base64 encoded string byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); }","title":"Sending events"},{"location":"3.Socket.IO/3.SendingEvents/#sending-events","text":"You can send an event with the Emit function. You have to pass the event name as the first parameter and optionally other parameters. These will be encoded to json and will be sent to the server. Optionally you can set a callback function that will be called when the server processes the event(you have to set up the server code properly to be able to send back a callback function. See the Socket.IO server side documentation for more information). // Send a custom event to the server with two parameters manager.Socket.Emit(\"message\", \"userName\", \"message\"); // Send an event and define a callback function that will be called as an // acknowledgement of this event manager.Socket.Emit(\"custom event\", OnAckCallback, \"param 1\", \"param 2\"); void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(\"OnAckCallback!\"); }","title":"Sending events"},{"location":"3.Socket.IO/3.SendingEvents/#sending-acknowledgement-to-the-server","text":"You can send back an acknowledgement to the server by calling the socket\u2019s EmitAck function. You have to pass the original packet and any optional data: manager[\"/customNamespace\"].On(\"customEvent\", (socket, packet, args) => { socket.EmitAck(packet, \"Event\", \"Received\", \"Successfully\"); }); You can keep a reference to the packet, and call the EmitAck from somewhere else.","title":"Sending acknowledgement to the server"},{"location":"3.Socket.IO/3.SendingEvents/#sending-binary-data","text":"There are two ways of sending binary(byte[]) data. By passing to the Emit function the plugin will scan the parameters and if it founds one, it will convert it to a binary attachment(as introduced in Socket.IO 1.0). This is the most efficient way, because it will not convert the byte array to a Base64 encoded string on client side, and back to binary on server side. byte[] data = new byte[10]; //... manager.Socket.Emit(\"eventWithBinary\", \"textual param\", data); If the binary data is embedded in an object as a field or property the Json encoder must support the conversion. The default Json encoder can\u2019t convert the embedded binary data to Json, you have to use a more advanced Json parser library (like \"JSON .NET For Unity\" )","title":"Sending binary data"},{"location":"3.Socket.IO/3.SendingEvents/#receiving-binary-data","text":"In the Socket.IO server when binary data sent to the client it will replace the data with a Json object({'_placeholder':true,'num':xyz}) and will send the binary data in another packet. On client side these packets will be collected and will be merged into one packet. The binary data will be in the packet\u2019s Attachments property. Here you will have some options too to use this packet: In your event-handler you can access all binary data through the packet\u2019s Attachments property. Socket.On(\"frame\", OnFrame); void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } The second option is almost the same as the previous, with a little improvement: we will not decode the sent Json string to c# objects. We can do it because we know that the server sent only the binary data, no other information came with this event. So we will let the plugin know that do not decode the payload: // Subscribe to the \"frame\" event, and set the autoDecodePayload flag to false Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); void OnFrame(Socket socket, Packet packet, params object[] args) { // Use the Attachments property as before texture.LoadImage(packet.Attachments[0]); } The autoDecodePayload parameter is true by default. We can replace back the \"{'_placeholder':true,'num':xyz}\" string to the index of the attachment in the Attachments list. Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); void OnFrame(Socket socket, Packet packet, params object[] args) { // Replace the Json object with the index packet.ReconstructAttachmentAsIndex(); // now, decode the Payload to an object[] args = packet.Decode(socket.Manager.Encoder); // args now contains only an index number (probably 0) byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); } We can replace the \"{'_placeholder':true,'num':xyz}\" string with the binary data from the Attachments converted to a Base64 encoded string. Advanced Json parsers can convert it to byte arrays when they have to set it to an object\u2019s field or property. Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); void OnFrame(Socket socket, Packet packet, params object[] args) { // Replace the Json object with the Base64 encoded string packet.ReconstructAttachmentAsBase64(); // now, decode the Payload to an object[] args = packet.Decode(socket.Manager.Encoder); // args now contains a Base64 encoded string byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); }","title":"Receiving binary data"},{"location":"3.Socket.IO/4.DefaultEncoder/","text":"Set the default Json encoder You can change the default Json encoder by setting the SocketManager\u2019s static DefaultEncoder for a new default. After this step all newly created SocketManager will use this encoder. SocketManager.DefaultEncoder = new LitJsonEncoder(); The encoder can be changed for a SocketManager instance too: var manager = new SocketManager(new Uri(\"http://.../socket.io/\"), options); manager.Encoder = new LitJsonEncoder();","title":"Set the default Json encoder"},{"location":"3.Socket.IO/4.DefaultEncoder/#set-the-default-json-encoder","text":"You can change the default Json encoder by setting the SocketManager\u2019s static DefaultEncoder for a new default. After this step all newly created SocketManager will use this encoder. SocketManager.DefaultEncoder = new LitJsonEncoder(); The encoder can be changed for a SocketManager instance too: var manager = new SocketManager(new Uri(\"http://.../socket.io/\"), options); manager.Encoder = new LitJsonEncoder();","title":"Set the default Json encoder"},{"location":"3.Socket.IO/5.CustomEncoder/","text":"Writing a custom Json encoder If you want to change the default Json encoder for various reasons, first you have to write a new one. To do so, you have to write a new class that implements the IJsonEncoder from the BestHTTP.SocketIO.JsonEncoders namespace. The stripped IJsonEncoder is very tiny, you have to implement only two functions: public interface IJsonEncoder { List<object> Decode(string json); string Encode(List<object> obj); } The Decode function must decode the given json string to a list of objects. Because of the nature of the Socket.IO protocol, the sent json is an array and the first element is the event\u2019s name. The Encode function is used to encode the data that the client wants to send to the server. The structure of this list is the same as with the Decode: the first element of the list is the event\u2019s name, and any other elements are the user sent arguments. And here comes a complete example using the LitJson library from the examples folder: using LitJson; public sealed class LitJsonEncoder : IJsonEncoder { public List<object> Decode(string json) { JsonReader reader = new JsonReader(json); return JsonMapper.ToObject<List<object>>(reader); } public string Encode(List<object> obj) { JsonWriter writer = new JsonWriter(); JsonMapper.ToJson(obj, writer); return writer.ToString(); } } This class can be found in the \\Best HTTP\\Examples\\SocketIO\\SocketIO Json Encoders\\LitJsonEncoder.cs and can be used without any preparation: // Create the Socket.IO manager Manager = new SocketManager(new Uri(address)); Manager.Encoder = new BestHTTP.SocketIO.JsonEncoders.LitJsonEncoder(); Another encoder that the plugin includes in the \\Best HTTP\\Examples\\SocketIO\\SocketIO Json Encoders\\ folder is the JsonDotNetEncoder . This encoder uses JSON .NET For Unity and before using it the comment start and end (/* */) must be removed to look like this: #if !BESTHTTP_DISABLE_SOCKETIO using System; using System.Collections.Generic; namespace BestHTTP.SocketIO.JsonEncoders { using Newtonsoft.Json; /// <summary> /// This class uses Newtonsoft's Json encoder (JSON .NET For Unity). /// </summary> public sealed class JsonDotNetEncoder : IJsonEncoder { public List<object> Decode(string json) { return JsonConvert.DeserializeObject<List<object>>(json); } public string Encode(List<object> obj) { return JsonConvert.SerializeObject(obj); } } } #endif And then can be used like this: // Create the Socket.IO manager Manager = new SocketManager(new Uri(address)); Manager.Encoder = new BestHTTP.SocketIO.JsonEncoders.JsonDotNetEncoder();","title":"Writing a custom Json encoder"},{"location":"3.Socket.IO/5.CustomEncoder/#writing-a-custom-json-encoder","text":"If you want to change the default Json encoder for various reasons, first you have to write a new one. To do so, you have to write a new class that implements the IJsonEncoder from the BestHTTP.SocketIO.JsonEncoders namespace. The stripped IJsonEncoder is very tiny, you have to implement only two functions: public interface IJsonEncoder { List<object> Decode(string json); string Encode(List<object> obj); } The Decode function must decode the given json string to a list of objects. Because of the nature of the Socket.IO protocol, the sent json is an array and the first element is the event\u2019s name. The Encode function is used to encode the data that the client wants to send to the server. The structure of this list is the same as with the Decode: the first element of the list is the event\u2019s name, and any other elements are the user sent arguments. And here comes a complete example using the LitJson library from the examples folder: using LitJson; public sealed class LitJsonEncoder : IJsonEncoder { public List<object> Decode(string json) { JsonReader reader = new JsonReader(json); return JsonMapper.ToObject<List<object>>(reader); } public string Encode(List<object> obj) { JsonWriter writer = new JsonWriter(); JsonMapper.ToJson(obj, writer); return writer.ToString(); } } This class can be found in the \\Best HTTP\\Examples\\SocketIO\\SocketIO Json Encoders\\LitJsonEncoder.cs and can be used without any preparation: // Create the Socket.IO manager Manager = new SocketManager(new Uri(address)); Manager.Encoder = new BestHTTP.SocketIO.JsonEncoders.LitJsonEncoder(); Another encoder that the plugin includes in the \\Best HTTP\\Examples\\SocketIO\\SocketIO Json Encoders\\ folder is the JsonDotNetEncoder . This encoder uses JSON .NET For Unity and before using it the comment start and end (/* */) must be removed to look like this: #if !BESTHTTP_DISABLE_SOCKETIO using System; using System.Collections.Generic; namespace BestHTTP.SocketIO.JsonEncoders { using Newtonsoft.Json; /// <summary> /// This class uses Newtonsoft's Json encoder (JSON .NET For Unity). /// </summary> public sealed class JsonDotNetEncoder : IJsonEncoder { public List<object> Decode(string json) { return JsonConvert.DeserializeObject<List<object>>(json); } public string Encode(List<object> obj) { return JsonConvert.SerializeObject(obj); } } } #endif And then can be used like this: // Create the Socket.IO manager Manager = new SocketManager(new Uri(address)); Manager.Encoder = new BestHTTP.SocketIO.JsonEncoders.JsonDotNetEncoder();","title":"Writing a custom Json encoder"},{"location":"3.Socket.IO/6.AutoDecodePayload/","text":"AutoDecodePayload Already talked about AutoDecodePayload in \"Receiving binary data\" , however you can set this value not just per-event, but per-socket too. The socket has an AutoDecodePayload property that used as the default value of event subscription. Its default value is true - all payload decoded and dispatched to the event subscriber. If you set to false no decoding will be done by the plugin, you will have to do it by yourself. You don\u2019t want to cast the args every time : Sure! You can set the AutoDecodePayload on the Socket object, and you can use your favorite Json parser to decode the Packet\u2019s Payload to a strongly typed object. However keep in mind that the payload will contain the event\u2019s name and it\u2019s a json array. A sample payload would look like this: [\u2018eventName\u2019, {\u2018field\u2019: \u2018stringValue\u2019}, {\u2018field\u2019: 1.0}] .","title":"AutoDecodePayload"},{"location":"3.Socket.IO/6.AutoDecodePayload/#autodecodepayload","text":"Already talked about AutoDecodePayload in \"Receiving binary data\" , however you can set this value not just per-event, but per-socket too. The socket has an AutoDecodePayload property that used as the default value of event subscription. Its default value is true - all payload decoded and dispatched to the event subscriber. If you set to false no decoding will be done by the plugin, you will have to do it by yourself. You don\u2019t want to cast the args every time : Sure! You can set the AutoDecodePayload on the Socket object, and you can use your favorite Json parser to decode the Packet\u2019s Payload to a strongly typed object. However keep in mind that the payload will contain the event\u2019s name and it\u2019s a json array. A sample payload would look like this: [\u2018eventName\u2019, {\u2018field\u2019: \u2018stringValue\u2019}, {\u2018field\u2019: 1.0}] .","title":"AutoDecodePayload"},{"location":"3.Socket.IO/7.ErrorHandling/","text":"Error handling An \"error\" event emitted when a server or client side error occurs. The first parameter of the event will be an Error object. It contains an error code in its Code property and a textual message in its Message property. Error overrides its ToString() so it can be used to write out its contents. Socket.On(SocketIOEventTypes.Error, OnError); void OnError(Socket socket, Packet packet, params object[] args) { Error error = args[0] as Error; switch (error.Code) { case SocketIOErrors.User: Debug.Log(\"Exception in an event handler!\"); break; case SocketIOErrors.Internal: Debug.Log(\"Internal error! Message: \" + error.Message); break; default: Debug.Log(\"Server error! Message: \" + error.Message); break; } // Or just use ToString() to print out .Code and .Message: Debug.Log(error.ToString()); }","title":"Error handling"},{"location":"3.Socket.IO/7.ErrorHandling/#error-handling","text":"An \"error\" event emitted when a server or client side error occurs. The first parameter of the event will be an Error object. It contains an error code in its Code property and a textual message in its Message property. Error overrides its ToString() so it can be used to write out its contents. Socket.On(SocketIOEventTypes.Error, OnError); void OnError(Socket socket, Packet packet, params object[] args) { Error error = args[0] as Error; switch (error.Code) { case SocketIOErrors.User: Debug.Log(\"Exception in an event handler!\"); break; case SocketIOErrors.Internal: Debug.Log(\"Internal error! Message: \" + error.Message); break; default: Debug.Log(\"Server error! Message: \" + error.Message); break; } // Or just use ToString() to print out .Code and .Message: Debug.Log(error.ToString()); }","title":"Error handling"},{"location":"3.Socket.IO/8.Options/","text":"The SocketOptions class You can pass a SocketOptions instance to the SocketManager\u2019s constructor. You can change the following options: AdditionalQueryParams : Additional query parameters that will be passed for accessed uris. If the value is null, or an empty string it will be not appended to the query only the key. The keys and values must be escaped properly, as the plugin will not escape these. Reconnection : Whether to reconnect automatically after a disconnect. Its default value is true. ReconnectionAttempts : Number of attempts before giving up. Its default value is Int.MaxValue. ReconnectionDelay : How long to initially wait before attempting a new reconnection. Affected by +/- RandomizationFactor. For example the default initial delay will be between 500ms to 1500ms. Its default value is 1000ms. ReconnectionDelayMax : Maximum amount of time to wait between reconnections. Each attempt increases the reconnection delay along with a randomization as above. Its default value is 5000ms. RandomizationFactor : It can be used to control the ReconnectionDelay range. Its default value is 0.5 and can be set between the 0..1 values inclusive. Timeout : Connection timeout before a \"connect_error\" and \"connect_timeout\" events are emitted. It\u2019s not the underlying tcp socket\u2019s connection timeout, it\u2019s for the socket.io protocol. Its default value is is 20000ms. AutoConnect : By setting this false, you have to call SocketManager's Open() whenever you decide it's appropriate. ConnectWith : The SocketManager will try to connect with the transport set to this property. It can be TransportTypes.Polling or TransportTypes.WebSocket. HTTPRequestCustomizationCallback : A callback that called for every HTTPRequest the socket.io protocol sends out. It can be used to further customize (add additional headers for example) requests. This callback is called for Websocket upgrade requests too on non-WebGL platforms. ServerVersion : Socket.IO protocol version of the server. If left as default (Unknown) the plugin tries to detect the server version when can connect with the LongPollingTransport, however when connecting straigth with the WebsocketTransport it might not be able to detect and going to fall back to V2, so it's best to set it to the known server version before connecting. Auth : Starting with Socket.IO v3, connecting to a namespace a client can send payload data. When the Auth callback function is set, the plugin going to call it when connecting to a namespace. Its return value must be a json string! When you create a new SocketOptions object its properties are set to theirs default values.","title":"The SocketOptions class"},{"location":"3.Socket.IO/8.Options/#the-socketoptions-class","text":"You can pass a SocketOptions instance to the SocketManager\u2019s constructor. You can change the following options: AdditionalQueryParams : Additional query parameters that will be passed for accessed uris. If the value is null, or an empty string it will be not appended to the query only the key. The keys and values must be escaped properly, as the plugin will not escape these. Reconnection : Whether to reconnect automatically after a disconnect. Its default value is true. ReconnectionAttempts : Number of attempts before giving up. Its default value is Int.MaxValue. ReconnectionDelay : How long to initially wait before attempting a new reconnection. Affected by +/- RandomizationFactor. For example the default initial delay will be between 500ms to 1500ms. Its default value is 1000ms. ReconnectionDelayMax : Maximum amount of time to wait between reconnections. Each attempt increases the reconnection delay along with a randomization as above. Its default value is 5000ms. RandomizationFactor : It can be used to control the ReconnectionDelay range. Its default value is 0.5 and can be set between the 0..1 values inclusive. Timeout : Connection timeout before a \"connect_error\" and \"connect_timeout\" events are emitted. It\u2019s not the underlying tcp socket\u2019s connection timeout, it\u2019s for the socket.io protocol. Its default value is is 20000ms. AutoConnect : By setting this false, you have to call SocketManager's Open() whenever you decide it's appropriate. ConnectWith : The SocketManager will try to connect with the transport set to this property. It can be TransportTypes.Polling or TransportTypes.WebSocket. HTTPRequestCustomizationCallback : A callback that called for every HTTPRequest the socket.io protocol sends out. It can be used to further customize (add additional headers for example) requests. This callback is called for Websocket upgrade requests too on non-WebGL platforms. ServerVersion : Socket.IO protocol version of the server. If left as default (Unknown) the plugin tries to detect the server version when can connect with the LongPollingTransport, however when connecting straigth with the WebsocketTransport it might not be able to detect and going to fall back to V2, so it's best to set it to the known server version before connecting. Auth : Starting with Socket.IO v3, connecting to a namespace a client can send payload data. When the Auth callback function is set, the plugin going to call it when connecting to a namespace. Its return value must be a json string! When you create a new SocketOptions object its properties are set to theirs default values.","title":"The SocketOptions class"},{"location":"4.SignalR/","text":"SignalR The SignalR implementation like the Socket.IO uses the plugin\u2019s base features. HTTPRequests and WebSockets are used to connect and communicate leveraging from connection pooling. Cookies are sent with the requests, and the logger is used to log information about the protocol and errors. Brief list of features of the SignalR implementation: Compatible with the latest SignalR server implementation Easy to use API Transport fallback Reconnect logic All Hub features are supported","title":"Index"},{"location":"4.SignalR/#signalr","text":"The SignalR implementation like the Socket.IO uses the plugin\u2019s base features. HTTPRequests and WebSockets are used to connect and communicate leveraging from connection pooling. Cookies are sent with the requests, and the logger is used to log information about the protocol and errors. Brief list of features of the SignalR implementation: Compatible with the latest SignalR server implementation Easy to use API Transport fallback Reconnect logic All Hub features are supported","title":"SignalR"},{"location":"4.SignalR/1.Connection/","text":"The Connection class The Connection class from the BestHTTP.SignalR namespace manages an abstract connection to the SignalR server. Connecting to a SignalR server start with the creation of a Connection object. This class will keep track of the current state of the protocol and will fire events. You can create a Connection object multiple ways: using BestHTTP.SignalR; Uri uri = new Uri(\"http://my-signalr-site/raw-connection/\"); Create the connection, without Hubs by passing only the server\u2019s uri to the constructor. Connection signalRConnection = new Connection(uri); Create the connection, with Hubs by passing the hub names to the constructor too. Connection signalRConnection = new Connection(uri, \"hub1\", \"hub2\", \"hubN\"); Create the connection, with Hubs by passing Hub objects to the constructor. Hub hub1 = new Hub(\"hub1\"); Hub hub2 = new Hub(\"hub2\"); Hub hubN = new Hub(\"hubN\"); Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); You can\u2019t mix options 2 and 3. After we created the Connection, we can start to connect to the server by calling the Open() function on it: signalRConnection.Open();","title":"The Connection class"},{"location":"4.SignalR/1.Connection/#the-connection-class","text":"The Connection class from the BestHTTP.SignalR namespace manages an abstract connection to the SignalR server. Connecting to a SignalR server start with the creation of a Connection object. This class will keep track of the current state of the protocol and will fire events. You can create a Connection object multiple ways: using BestHTTP.SignalR; Uri uri = new Uri(\"http://my-signalr-site/raw-connection/\"); Create the connection, without Hubs by passing only the server\u2019s uri to the constructor. Connection signalRConnection = new Connection(uri); Create the connection, with Hubs by passing the hub names to the constructor too. Connection signalRConnection = new Connection(uri, \"hub1\", \"hub2\", \"hubN\"); Create the connection, with Hubs by passing Hub objects to the constructor. Hub hub1 = new Hub(\"hub1\"); Hub hub2 = new Hub(\"hub2\"); Hub hubN = new Hub(\"hubN\"); Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); You can\u2019t mix options 2 and 3. After we created the Connection, we can start to connect to the server by calling the Open() function on it: signalRConnection.Open();","title":"The Connection class"},{"location":"4.SignalR/2.GeneralEvents/","text":"Handling general events The Connection class will allow you to subscribe to multiple events. These events are the following: OnConnected : This event is fired when the connection class successfully connected, and the SignalR protocol is up for communication. signalRConnection.OnConnected += (con) => Debug.Log(\"Connected to the SignalR server!\"); OnClosed : This event is fired when the SignalR protocol is closed, and no further messages are sent or received. signalRConnection.OnClosed += (con) => Debug.Log(\"Connection Closed\"); OnError : Called when an error occurs. If the connection is already open, the plugin will try to reconnect, otherwise the connection will be closed. signalRConnection.OnError += (conn, err) => Debug.Log(\"Error: \" + err); OnReconnecting : This event is fired, when a reconnect attempt is started. After this event an OnError or an OnReconnected event is called. Multiple OnReconnecting-OnError event pairs can be fired before an OnReconnected/OnClosed event, because the plugin will try to reconnect multiple times in a given time. signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnecting\"); OnReconnected : Fired when a reconnect attempt was successful. signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnected\"); OnStateChnaged : Fired when the connection\u2019s State changed. The event handler will receive both the old state and the new state. signalRConnection.OnStateChanged += (conn, oldState, newState) => Debug.Log(string.Format(\"State Changed {0} -> {1}\", oldState, newState)); OnNonHubMessage : Fired when the server send a non-hub message to the client. The client should know what types of messages are expected from the server, and should cast the received object accordingly. signalRConnection.OnNonHubMessage += (con, data) => Debug.Log(\"Message from server: \" + data.ToString()); RequestPreparator : This delegate is called for every HTTPRequest that made and will be sent to the server. It can be used to further customize the requests. signalRConnection.RequestPreparator = (con, req, type) => req.Timeout = TimeSpan.FromSeconds(30);","title":"Handling general events"},{"location":"4.SignalR/2.GeneralEvents/#handling-general-events","text":"The Connection class will allow you to subscribe to multiple events. These events are the following: OnConnected : This event is fired when the connection class successfully connected, and the SignalR protocol is up for communication. signalRConnection.OnConnected += (con) => Debug.Log(\"Connected to the SignalR server!\"); OnClosed : This event is fired when the SignalR protocol is closed, and no further messages are sent or received. signalRConnection.OnClosed += (con) => Debug.Log(\"Connection Closed\"); OnError : Called when an error occurs. If the connection is already open, the plugin will try to reconnect, otherwise the connection will be closed. signalRConnection.OnError += (conn, err) => Debug.Log(\"Error: \" + err); OnReconnecting : This event is fired, when a reconnect attempt is started. After this event an OnError or an OnReconnected event is called. Multiple OnReconnecting-OnError event pairs can be fired before an OnReconnected/OnClosed event, because the plugin will try to reconnect multiple times in a given time. signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnecting\"); OnReconnected : Fired when a reconnect attempt was successful. signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnected\"); OnStateChnaged : Fired when the connection\u2019s State changed. The event handler will receive both the old state and the new state. signalRConnection.OnStateChanged += (conn, oldState, newState) => Debug.Log(string.Format(\"State Changed {0} -> {1}\", oldState, newState)); OnNonHubMessage : Fired when the server send a non-hub message to the client. The client should know what types of messages are expected from the server, and should cast the received object accordingly. signalRConnection.OnNonHubMessage += (con, data) => Debug.Log(\"Message from server: \" + data.ToString()); RequestPreparator : This delegate is called for every HTTPRequest that made and will be sent to the server. It can be used to further customize the requests. signalRConnection.RequestPreparator = (con, req, type) => req.Timeout = TimeSpan.FromSeconds(30);","title":"Handling general events"},{"location":"4.SignalR/3.Sending/","text":"Sending non-Hub messages Sending non-hub messages to the server is easy as calling a function on the connection object: signalRConnection.Send(new { Type = \"Broadcast\", Value = \"Hello SignalR World!\" }); This function will encode the given object to a Json string using the Connection\u2019s JsonEncoder, and sends it to the server. Already encoded Json strings can be sent using the SendJson function: signalRConnection.SendJson(\"{ Type: \u2018Broadcast\u2019, Value: \u2018Hello SignalR World!\u2019 }\");","title":"Sending non-Hub messages"},{"location":"4.SignalR/3.Sending/#sending-non-hub-messages","text":"Sending non-hub messages to the server is easy as calling a function on the connection object: signalRConnection.Send(new { Type = \"Broadcast\", Value = \"Hello SignalR World!\" }); This function will encode the given object to a Json string using the Connection\u2019s JsonEncoder, and sends it to the server. Already encoded Json strings can be sent using the SendJson function: signalRConnection.SendJson(\"{ Type: \u2018Broadcast\u2019, Value: \u2018Hello SignalR World!\u2019 }\");","title":"Sending non-Hub messages"},{"location":"4.SignalR/4.Hubs/","text":"Hubs In order to define methods on the client that a Hub can call from the server, and to invoke methods on a Hub at the server, Hubs must be added to the Connection object. This can be done by adding the hub names or hub instances to the Connection constructor, demonstrated in the Connection Class section. Accessing hubs Hub instances can be accessed through the Connection object by index, or by name. Hub hub = signalRConnection[0]; Hub hub = signalRConnection[\"hubName\"]; Register server callable methods To handle server callable method calls, we have to call the On function of a hub: // Register method implementation signalRConnection[\"hubName\"].On(\"joined\", Joined); // \"Joined\" method implementation on the client void Joined(Hub hub, MethodCallMessage msg) { Debug.Log(string.Format(\"{0} joined at {1}\", msg.Arguments[0], msg.Arguments[1])); } The MethodCallMessage is a server sent object that contains the following properties: Hub : A string containing the hub name that the method have to call on. Method : A string that contains the method name. Arguments : An array of objects that contains the arguments of the method call. It can be an empty array. State : A dictionary containing additional custom data. The plugin will use the Hub and Method properties to route the message to the right hub and event handler. The function that handles the method call have to use only the Arguments and State properties. Call server-side methods Calling server-side methods can be done by call a Hub\u2019s Call function. The call function overloaded to be able to fulfill every needs. The Call functions are non-blocking functions, they will not block until the server sends back any message about the call. The overloads are the following: Call(string method, params object[] args) : This can be used to call a server-side function in a fire-and-forget style. We will not receive back any messages about the method call\u2019s success or failure. This function can be called without any \u2018args\u2019 arguments, to call a parameterless method. // Call a server-side function without any parameters signalRConnection[\"hubName\"].Call(\"Ping\"); // Call a server-side function with two string parameters: \"param1\" and \"param2\" signalRConnection[\"hubName\"].Call(\"Message\", \"param1\", \"param2\"); Call(string method, OnMethodResultDelegate onResult, params object[] args) : This function can be used as the previous one, but a function can be passed as the second parameter that will be called when the server-side function successfully invoked. signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone); void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(\"GetValue executed on the server. Return value of the function:\" + result.ReturnValue.ToString()); } This callback function receives the Hub that called this function, the original ClientMessage message that sent to the server and the ResultMessage instance sent by the server as a result of the method call. A ResultMessage object contains a ReturnValue and a State properties. If the method\u2019s return type is void, the ReturnValue is null. Call(string method, OnMethodResultDelegate onResult, OnMethodFailedDelegate onError, params object[] args) : This function can be used to specify a callback that will be called when the method fails to run on the server. Failures can be happen because of a non-found method, wrong parameters, or unhandled exceptions in the method call. signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed); void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) { Debug.Log(\"GetValue failed. Error message from the server: \" + error.ErrorMessage); } A FailureMessage contains the following properties: IsHubError : True if it is a Hub error. ErrorMessage : A brief message about the error itself. StackTrace : If detailed error reporting is turned on on the server then it contains the stack trace of the error. AdditionalData : If it\u2019s not null, then it contains additional information about the error. Call(string method, OnMethodResultDelegate onResult, OnMethodFailedDelegate onError, OnMethodProgressDelegate onProgress, params object[] args ): This function can be used to add an additional progress message handler to the server-side method call. For long running jobs the server can send progress messages to the client. signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed, OnGetValueProgress); void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) { Debug.Log(string.Format(\"GetValue progressed: {0}%\", progress.Progress)); } When a ResultMessage or FailureMessage received by the plugin, it will not serve the ProgressMessages that came after these messages. Using the Hub class as a base class to inherit from The Hub class can be used as a base class to encapsulate hub functionality. class SampleHub : Hub { // Default constructor. Every hubs have to have a valid name. public SampleHub() :base(\"SampleHub\") { // Register a server-callable function base.On(\"ClientFunction\", ClientFunctionImplementation); } // Private function to implement server-callable function private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) { // TODO: implement } // Wrapper function to call a server-side function. public void ServerFunction(string argument) { base.Call(\"ServerFunction\", argument); } } This SampleHub can be instantiated and passed to the Connection\u2019s constructor: SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); Authentication The Connection class has an AuthenticationProvider property that can be set to an object that implements the IAuthenticationProvider interface. The implementor has to implement the following property and functions: bool IsPreAuthRequired :Property that returns true, if the authentication must run before any request is made to the server by the Connection class. Examples: a cookie authenticator must return false, as it has to send user credentials and receive back a cookie that must sent with the requests. StartAuthentication : A function that required only if the IsPreAuthRequired is true. Otherwise it doesn\u2019t called. PrepareRequest : A function that is called with a request and a request type enum. This function can be used to prepare requests before they are sent to the server. OnAuthenticationSucceded : An event that must be called when the IsPreAuthRequired is true and the authentication process succeeded. OnAuthenticationFailed : An event that must be called when the IsPreAuthRequired is true and the authentication process failed. A very simple Header-based authenticator would look like this: class HeaderAuthenticator : IAuthenticationProvider { public string User { get; private set; } public string Roles { get; private set; } // No pre-auth step required for this type of authentication public bool IsPreAuthRequired { get { return false; } } // Not used event as IsPreAuthRequired is false public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; // Not used event as IsPreAuthRequired is false public event OnAuthenticationFailedDelegate OnAuthenticationFailed; // Constructor to initialise the authenticator with username and roles. public HeaderAuthenticator(string user, string roles) { this.User = user; this.Roles = roles; } // Not used as IsPreAuthRequired is false public void StartAuthentication() { } // Prepares the request by adding two headers to it public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) { request.SetHeader(\"username\", this.User); request.SetHeader(\"roles\", this.Roles); } } Writing custom Json encoders Like for the Socket.IO\u2019s Manager class, the SignalR\u2019s Connection class has a JsonEncoder property, and the static Connection.DefaultEncoder can be set too. A JsonEncoder must implement the IJsonEncoder interface from the BestHTTP.SignalR.JsonEncoders namespace. The package contains a sample LitJsonEncoder, that also used by some samples too.","title":"Hubs"},{"location":"4.SignalR/4.Hubs/#hubs","text":"In order to define methods on the client that a Hub can call from the server, and to invoke methods on a Hub at the server, Hubs must be added to the Connection object. This can be done by adding the hub names or hub instances to the Connection constructor, demonstrated in the Connection Class section.","title":"Hubs"},{"location":"4.SignalR/4.Hubs/#accessing-hubs","text":"Hub instances can be accessed through the Connection object by index, or by name. Hub hub = signalRConnection[0]; Hub hub = signalRConnection[\"hubName\"];","title":"Accessing hubs"},{"location":"4.SignalR/4.Hubs/#register-server-callable-methods","text":"To handle server callable method calls, we have to call the On function of a hub: // Register method implementation signalRConnection[\"hubName\"].On(\"joined\", Joined); // \"Joined\" method implementation on the client void Joined(Hub hub, MethodCallMessage msg) { Debug.Log(string.Format(\"{0} joined at {1}\", msg.Arguments[0], msg.Arguments[1])); } The MethodCallMessage is a server sent object that contains the following properties: Hub : A string containing the hub name that the method have to call on. Method : A string that contains the method name. Arguments : An array of objects that contains the arguments of the method call. It can be an empty array. State : A dictionary containing additional custom data. The plugin will use the Hub and Method properties to route the message to the right hub and event handler. The function that handles the method call have to use only the Arguments and State properties.","title":"Register server callable methods"},{"location":"4.SignalR/4.Hubs/#call-server-side-methods","text":"Calling server-side methods can be done by call a Hub\u2019s Call function. The call function overloaded to be able to fulfill every needs. The Call functions are non-blocking functions, they will not block until the server sends back any message about the call. The overloads are the following: Call(string method, params object[] args) : This can be used to call a server-side function in a fire-and-forget style. We will not receive back any messages about the method call\u2019s success or failure. This function can be called without any \u2018args\u2019 arguments, to call a parameterless method. // Call a server-side function without any parameters signalRConnection[\"hubName\"].Call(\"Ping\"); // Call a server-side function with two string parameters: \"param1\" and \"param2\" signalRConnection[\"hubName\"].Call(\"Message\", \"param1\", \"param2\"); Call(string method, OnMethodResultDelegate onResult, params object[] args) : This function can be used as the previous one, but a function can be passed as the second parameter that will be called when the server-side function successfully invoked. signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone); void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(\"GetValue executed on the server. Return value of the function:\" + result.ReturnValue.ToString()); } This callback function receives the Hub that called this function, the original ClientMessage message that sent to the server and the ResultMessage instance sent by the server as a result of the method call. A ResultMessage object contains a ReturnValue and a State properties. If the method\u2019s return type is void, the ReturnValue is null. Call(string method, OnMethodResultDelegate onResult, OnMethodFailedDelegate onError, params object[] args) : This function can be used to specify a callback that will be called when the method fails to run on the server. Failures can be happen because of a non-found method, wrong parameters, or unhandled exceptions in the method call. signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed); void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) { Debug.Log(\"GetValue failed. Error message from the server: \" + error.ErrorMessage); } A FailureMessage contains the following properties: IsHubError : True if it is a Hub error. ErrorMessage : A brief message about the error itself. StackTrace : If detailed error reporting is turned on on the server then it contains the stack trace of the error. AdditionalData : If it\u2019s not null, then it contains additional information about the error. Call(string method, OnMethodResultDelegate onResult, OnMethodFailedDelegate onError, OnMethodProgressDelegate onProgress, params object[] args ): This function can be used to add an additional progress message handler to the server-side method call. For long running jobs the server can send progress messages to the client. signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed, OnGetValueProgress); void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) { Debug.Log(string.Format(\"GetValue progressed: {0}%\", progress.Progress)); } When a ResultMessage or FailureMessage received by the plugin, it will not serve the ProgressMessages that came after these messages.","title":"Call server-side methods"},{"location":"4.SignalR/4.Hubs/#using-the-hub-class-as-a-base-class-to-inherit-from","text":"The Hub class can be used as a base class to encapsulate hub functionality. class SampleHub : Hub { // Default constructor. Every hubs have to have a valid name. public SampleHub() :base(\"SampleHub\") { // Register a server-callable function base.On(\"ClientFunction\", ClientFunctionImplementation); } // Private function to implement server-callable function private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) { // TODO: implement } // Wrapper function to call a server-side function. public void ServerFunction(string argument) { base.Call(\"ServerFunction\", argument); } } This SampleHub can be instantiated and passed to the Connection\u2019s constructor: SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub);","title":"Using the Hub class as a base class to inherit from"},{"location":"4.SignalR/4.Hubs/#authentication","text":"The Connection class has an AuthenticationProvider property that can be set to an object that implements the IAuthenticationProvider interface. The implementor has to implement the following property and functions: bool IsPreAuthRequired :Property that returns true, if the authentication must run before any request is made to the server by the Connection class. Examples: a cookie authenticator must return false, as it has to send user credentials and receive back a cookie that must sent with the requests. StartAuthentication : A function that required only if the IsPreAuthRequired is true. Otherwise it doesn\u2019t called. PrepareRequest : A function that is called with a request and a request type enum. This function can be used to prepare requests before they are sent to the server. OnAuthenticationSucceded : An event that must be called when the IsPreAuthRequired is true and the authentication process succeeded. OnAuthenticationFailed : An event that must be called when the IsPreAuthRequired is true and the authentication process failed. A very simple Header-based authenticator would look like this: class HeaderAuthenticator : IAuthenticationProvider { public string User { get; private set; } public string Roles { get; private set; } // No pre-auth step required for this type of authentication public bool IsPreAuthRequired { get { return false; } } // Not used event as IsPreAuthRequired is false public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; // Not used event as IsPreAuthRequired is false public event OnAuthenticationFailedDelegate OnAuthenticationFailed; // Constructor to initialise the authenticator with username and roles. public HeaderAuthenticator(string user, string roles) { this.User = user; this.Roles = roles; } // Not used as IsPreAuthRequired is false public void StartAuthentication() { } // Prepares the request by adding two headers to it public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) { request.SetHeader(\"username\", this.User); request.SetHeader(\"roles\", this.Roles); } }","title":"Authentication"},{"location":"4.SignalR/4.Hubs/#writing-custom-json-encoders","text":"Like for the Socket.IO\u2019s Manager class, the SignalR\u2019s Connection class has a JsonEncoder property, and the static Connection.DefaultEncoder can be set too. A JsonEncoder must implement the IJsonEncoder interface from the BestHTTP.SignalR.JsonEncoders namespace. The package contains a sample LitJsonEncoder, that also used by some samples too.","title":"Writing custom Json encoders"},{"location":"5.EventSource/","text":"Server-Sent Events (EventSource) The Server-Sent Events is a one-way string-based protocol. Data comes from the server, and there are no option to send anything to the server. It\u2019s implemented using the latest draft . While the protocol\u2019s name is Server-Sent Events, the class itself is named EventSource. When an error occurs, the plugin will try to reconnect once sending the LastEventId to let the server send any buffered message that we should receive. The EventSource class The EventSource class is located in the BestHTTP.ServerSentEvents namespace: using BestHTTP.ServerSentEvents; var sse = new EventSource(new Uri(\"http://server.com\")); Properties These are the publicly exposed properties of the EventSource class: Uri : This is the endpoint where the protocol tries to connect to. It\u2019s set through the constructor. State : The current state of the EventSource object. * ReconnectionTime : How much time to wait to try to do a reconnect attempt. It\u2019s default value is 2 sec. LastEventId : The last received event\u2019s id. It will be null, if no event id received at all. InternalRequest : The internal HTTPRequest object that will be sent out in the Open function. Events OnOpen : It\u2019s called when the protocol is successfully upgraded. eventSource.OnOpen += OnEventSourceOpened; void OnEventSourceOpened(EventSource source) { Debug.log(\"EventSource Opened!\"); } OnMessage : It\u2019s called when the client receives a new message from the server. This function will receive a Message object that contains the payload of the message in the Data property. This event is called every time the client receives a message, even when the message has a valid Event name, and we assigned an event handler to this event! eventSource.OnMessage += OnEventSourceMessage; void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(\"Message: \" + msg.Data); } OnError : Called when an error encountered while connecting to the server, or while processing the data stream. eventSource.OnError += OnEventSourceError; void OnEventSourceError(EventSource source, string error) { Debug.log(\"Error: \" + error); } OnRetry : This function is called before the plugin will try to reconnect to the server. If the function returns false, no attempt will be made and the EventSource will be closed. eventSource.OnRetry += OnEventSourceRetry; bool OnEventSourceRetry(EventSource source) { // disable retry return false; } OnClosed : This event will be called when the EventSource closed. eventSource.OnClosed += OnEventSourceClosed; void OnEventSourceClosed(EventSource source) { Debug.log(\"EventSource Closed!\"); } OnStateChanged : Called every time when the State property changes. eventSource.OnStateChanged += OnEventSourceStateChanged; void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(\"State Changed {0} => {1}\", oldState, newState))); } OnComment : This event is called for comments received from the server. eventSource.OnComment += OnEventSourceComment; void OnEventSourceComment(EventSource source, string comment) { Debug.log(string.Format(\"Comment: {0}\", comment))); } Functions These are the public functions of the EventSource object. Open : Calling this function the plugin will start to connect to the server and upgrade to the Server-Sent Events protocol. EventSource eventSource = new EventSource(new Uri(\"http://server.com\")); eventSource.Open(); On : Using this function clients can subscribe to events. eventSource.On(\"userLogon\", OnUserLoggedIn); void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); } Off : It can be used to unsubscribe from an event. eventSource.Off(\"userLogon\"); Close : This function will start to close the EventSource object. eventSource.Close(); The Message class The Message class is a logical unit that contains all the information that a server can send. Properties Id : Id of the sent event. Can be null, if no id sent. It\u2019s used by the plugin. Event : Name of the event. Can be null, if no event name sent. Data : The actual payload of the message. Retry : A server sent time that the plugin should wait before a reconnect attempt. It\u2019s used by the plugin.","title":"Server-Sent Events (EventSource)"},{"location":"5.EventSource/#server-sent-events-eventsource","text":"The Server-Sent Events is a one-way string-based protocol. Data comes from the server, and there are no option to send anything to the server. It\u2019s implemented using the latest draft . While the protocol\u2019s name is Server-Sent Events, the class itself is named EventSource. When an error occurs, the plugin will try to reconnect once sending the LastEventId to let the server send any buffered message that we should receive.","title":"Server-Sent Events (EventSource)"},{"location":"5.EventSource/#the-eventsource-class","text":"The EventSource class is located in the BestHTTP.ServerSentEvents namespace: using BestHTTP.ServerSentEvents; var sse = new EventSource(new Uri(\"http://server.com\"));","title":"The EventSource class"},{"location":"5.EventSource/#properties","text":"These are the publicly exposed properties of the EventSource class: Uri : This is the endpoint where the protocol tries to connect to. It\u2019s set through the constructor. State : The current state of the EventSource object. * ReconnectionTime : How much time to wait to try to do a reconnect attempt. It\u2019s default value is 2 sec. LastEventId : The last received event\u2019s id. It will be null, if no event id received at all. InternalRequest : The internal HTTPRequest object that will be sent out in the Open function.","title":"Properties"},{"location":"5.EventSource/#events","text":"OnOpen : It\u2019s called when the protocol is successfully upgraded. eventSource.OnOpen += OnEventSourceOpened; void OnEventSourceOpened(EventSource source) { Debug.log(\"EventSource Opened!\"); } OnMessage : It\u2019s called when the client receives a new message from the server. This function will receive a Message object that contains the payload of the message in the Data property. This event is called every time the client receives a message, even when the message has a valid Event name, and we assigned an event handler to this event! eventSource.OnMessage += OnEventSourceMessage; void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(\"Message: \" + msg.Data); } OnError : Called when an error encountered while connecting to the server, or while processing the data stream. eventSource.OnError += OnEventSourceError; void OnEventSourceError(EventSource source, string error) { Debug.log(\"Error: \" + error); } OnRetry : This function is called before the plugin will try to reconnect to the server. If the function returns false, no attempt will be made and the EventSource will be closed. eventSource.OnRetry += OnEventSourceRetry; bool OnEventSourceRetry(EventSource source) { // disable retry return false; } OnClosed : This event will be called when the EventSource closed. eventSource.OnClosed += OnEventSourceClosed; void OnEventSourceClosed(EventSource source) { Debug.log(\"EventSource Closed!\"); } OnStateChanged : Called every time when the State property changes. eventSource.OnStateChanged += OnEventSourceStateChanged; void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(\"State Changed {0} => {1}\", oldState, newState))); } OnComment : This event is called for comments received from the server. eventSource.OnComment += OnEventSourceComment; void OnEventSourceComment(EventSource source, string comment) { Debug.log(string.Format(\"Comment: {0}\", comment))); }","title":"Events"},{"location":"5.EventSource/#functions","text":"These are the public functions of the EventSource object. Open : Calling this function the plugin will start to connect to the server and upgrade to the Server-Sent Events protocol. EventSource eventSource = new EventSource(new Uri(\"http://server.com\")); eventSource.Open(); On : Using this function clients can subscribe to events. eventSource.On(\"userLogon\", OnUserLoggedIn); void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); } Off : It can be used to unsubscribe from an event. eventSource.Off(\"userLogon\"); Close : This function will start to close the EventSource object. eventSource.Close();","title":"Functions"},{"location":"5.EventSource/#the-message-class","text":"The Message class is a logical unit that contains all the information that a server can send.","title":"The Message class"},{"location":"5.EventSource/#properties_1","text":"Id : Id of the sent event. Can be null, if no id sent. It\u2019s used by the plugin. Event : Name of the event. Can be null, if no event name sent. Data : The actual payload of the message. Retry : A server sent time that the plugin should wait before a reconnect attempt. It\u2019s used by the plugin.","title":"Properties"},{"location":"6.SignalRCore/","text":"SignalR Core The new SignalR Core protocol is a new iteration for the SignalR family. It tries to keep and improve what worked and remove the bad, but this also means that it's not backward compatible. The plugin's SignalR Core implements two transports: Long-Polling and WebSockets. First it will try to connect with the prefered transort set in the HubOptions (the default value is the Websockets transport), and when connecting with the transport fails, it will try the next available (Long-Polling). To continue with SignalR Core read about the HubConnection class.","title":"SignalR Core"},{"location":"6.SignalRCore/#signalr-core","text":"The new SignalR Core protocol is a new iteration for the SignalR family. It tries to keep and improve what worked and remove the bad, but this also means that it's not backward compatible. The plugin's SignalR Core implements two transports: Long-Polling and WebSockets. First it will try to connect with the prefered transort set in the HubOptions (the default value is the Websockets transport), and when connecting with the transport fails, it will try the next available (Long-Polling). To continue with SignalR Core read about the HubConnection class.","title":"SignalR Core"},{"location":"6.SignalRCore/1.HubConnection/","text":"The HubConnection Class The HubConnection is the main entry point for a SignalR Core connection. Protocols SignalR Core supports different protocols to encode its messages like Json and MessagePack. The safest is to use json, as that's the default encoder of the server. But if possible it's recommended to use MessagePack. More can be read about this under the Encoders topic . On this page the JsonProtocol combined with the LitJsonEncoder will be used, as these work out of the box. A new HubConnection object must be initialized with the uri of the server endpoint and with the protocol that the client want to communicate with: hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new LitJsonEncoder())); HubOptions HubConnection 's constructor can accept a HubOptions instance too: HubOptions options = new HubOptions(); hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new LitJsonEncoder()), options); HubOptions contains the following properties to set: SkipNegotiation : When this is set to true, the plugin will skip the negotiation request if the PreferedTransport is WebSocket. Its default value is false. PreferedTransport : The preferred transport to choose when more than one available. Its default value is TransportTypes.WebSocket. When the plugin can't connect with the preferred transport it will try the next available (long polling). If all transport fails to connect, it will emit an OnError event. PingInterval : A ping message is only sent if the interval has elapsed without a message being sent. Its default value is 15 seconds. PingTimeoutInterval : If the client doesn't see any message in this interval, considers the connection broken. Its default value is 30 seconds. MaxRedirects : The maximum count of redirect negoitiation result that the plugin will follow. Its default value is 100. ConnectTimeout : The maximum time that the plugin allowed to spend trying to connect. Its default value is 1 minute. Events OnConnected : This event is called when successfully connected to the hub. OnError : This event is called when an unexpected error happen and the connection is closed. OnClosed : This event is called when the connection is gracefully terminated. OnMessage : This event is called for every server-sent message. When returns false, no further processing of the message is done by the plugin. OnReconnecting : Called when the HubConnection start its reconnection process after loosing its underlying connection. OnReconnected : Called after a succesfull reconnection. OnRedirected : This event is called when the connection is redirected to a new uri. OnTransportEvent : Called for transport related events: SelectedToConnect : Transport is selected to try to connect to the server FailedToConnect : Transport failed to connect to the server. This event can occur after SelectedToConnect, when already connected and an error occurs it will be a ClosedWithError one. Connected : The transport successfully connected to the server. Closed : Transport gracefully terminated. ClosedWithError : Unexpected error occured and the transport can't recover from it. Properties Uri : Uri of the Hub endpoint State : Current state of the connection. Transport : Current, active ITransport instance. Protocol : The IProtocol implementation that will parse, encode and decode messages. AuthenticationProvider : An IAuthenticationProvider implementation that will be used to authenticate the connection. Its default value is an instance of the DefaultAccessTokenAuthenticator class. NegotiationResult : Negotiation response sent by the server. Options : Options that has been used to create the HubConnection. RedirectCount : How many times this connection is redirected. ReconnectPolicy : The reconnect policy that will be used when the underlying connection is lost. Its default value is null. Connecting to the server To start the protocol's connection process the StartConnect and ConnectAsync functions can be used. Invoking server methods To invoke a method on a server that doesn't return a value, the Send and SendAsync methods can be used. Client code: hub.Send(\"Send\", \"my message\"); await hub.SendAsync(\"Send\", \"my message\"); Or with a cancellation token: using (var source = new CancellationTokenSource(TimeSpan.FromSeconds(2))) { try { await hub.SendAsync(\"Send\", source.Token, \"my message\"); } catch(TaskCanceledException) { Debug.Log(\"Timed out!\"); } } Notice It can't cancel an already sent call, the server still going to process it, but the client going to give back controll sooner. Its first parameter is the name of the method on the server, than a parameter list can be passed that will be sent to the server. Related server code: public class TestHub : Hub { public Task Send(string message) { return Clients.All.SendAsync(\"Send\", $\"{Context.ConnectionId}: {message}\"); } } Invoking server functions Invoking a server function can be done with the generic Invoke<TResult> or InvokeAsync<TResult> functions. TResult is the expected type that the server function returns with. Sample: hub.Invoke<int>(\"Add\", 10, 20) .OnSuccess(result => Debug.log(\"10+20: \" + result)) .OnError(error => Debug.log(\"Add(10, 20) failed to execute. Error: \" + error)); var addResult = await hub.InvokeAsync<int>(\"Add\", 10, 20); AddText(string.Format(\"'<color=green>Add(10, 20)</color>' returned: '<color=yellow>{0}</color>'\", addResult)).AddLeftPadding(20); Invoke returns with an IFuture<TResult> that can be used to subscribe to various Invoke related events: OnSuccess : Callback passed for OnSuccess is called when the server side function is executed and the callback's parameter will be function's return value. OnError : Callback passed to this function will be called when there's an error executing the function. The error can be a client or server error. The callback's error parameter will contain information about the error. OnComplete : Callback passed to this function will be called after an OnSuccess or OnError callback. InvokeAsync returns with Task<TResult> that can be awaited. As a second parameter a CancellationToken can be added to cancel the call on client side. using (var source = new CancellationTokenSource(TimeSpan.FromSeconds(2))) { try { var addResult = await hub.InvokeAsync<int>(\"Add\", source.Token, 10, 20); // ... } catch(TaskCanceledException) { Debug.Log(\"Timed out!\"); } } Related server code: public class TestHub : Hub { public int Add(int x, int y) { return x + y; } } Notice All Send , Invoke and theirs *Async counterparts are going to wait for a completion message from the server and their IFuture/Task completes when received it. Server callable client methods Clients can define server-callable methods using the generic and non-generic On method. The non-generic On can be used when the server-callable method has no parameter and the generic one for methods with at least one parameter. Samples: // Generic On with one string argument. hub.On(\"Send\", (string arg) => Debug.log(\"Server-sent text: \" + arg)); // Generic On, with one type: hub.On<Person>(\"Person\", (person) => Debug.log(\"Server-sent data: \" + person.ToString())); // Generic On, with two types: hub.On<Person, Person>(\"TwoPersons\", (person1, person2) => Debug.log(\"...\")); sealed class Person { public string Name { get; set; } public long Age { get; set; } public override string ToString() { return string.Format(\"[Person Name: '{0}', Age: '<color=yellow>{1}</color>']\", this.Name, this.Age.ToString()); } } Related server code: public class TestHub : Hub { public override async Task OnConnectedAsync() { await Clients.All.SendAsync(\"Send\", $\"{Context.ConnectionId} joined\"); await Clients.Client(Context.ConnectionId).SendAsync(\"Person\", new Person { Name = \"Person 007\", Age = 35 }); await Clients.Client(Context.ConnectionId).SendAsync(\"TwoPersons\", new Person { Name = \"Person 008\", Age = 36 }, new Person { Name = \"Person 009\", Age = 37 }); } } Streaming from the server When the server sends one return value at a time the client can call a callback for every item if the server function is called using the GetDownStreamController<TDown> function. Sample: hub.GetDownStreamController<Person>(\"GetRandomPersons\", 20, 2000) .OnItem(result => Debug.log(\"New item arrived: \" + result.ToString())) .OnSuccess(_ => Debug.log(\"Streaming finished!\")); GetDownStreamController 's return value is a DownStreamItemController<TDown> that implements the IFuture<TResult> interface. With DownStreamItemController's OnItem function it can be subscribed for a callback that will be called for every downloaded item. The instance of DownStreamItemController<TDown> can be used to cancel the streaming: var controller = hub.GetDownStreamController<int>(\"ChannelCounter\", 10, 1000); controller.OnItem(result => Debug.log(\"New item arrived: \" + result.ToString())) .OnSuccess(_ => Debug.log(\"Streaming finished!\")) .OnError(error => Debug.log(\"Error: \" + error)); // A stream request can be cancelled any time by calling the controller's Cancel method controller.Cancel(); Related server code: public class TestHub : Hub { public ChannelReader<Person> GetRandomPersons(int count, int delay) { var channel = Channel.CreateUnbounded<Person>(); Task.Run(async () => { Random rand = new Random(); for (var i = 0; i < count; i++) { await channel.Writer.WriteAsync(new Person { Name = \"Name_\" + rand.Next(), Age = rand.Next(20, 99) }); await Task.Delay(delay); } await Clients.Client(Context.ConnectionId).SendAsync(\"Person\", new Person { Name = \"Person 000\", Age = 0 }); channel.Writer.TryComplete(); }); return channel.Reader; } } Streaming to the server To stream one or more parameters to a server function the GetUpStreamController can be used: private IEnumerator UploadWord() { var controller = hub.GetUpStreamController<string, string>(\"UploadWord\"); controller.OnSuccess(result => { Debug.log(\"Upload finished!\"); }); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"Hello \"); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"World\"); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"!!\"); yield return new WaitForSeconds(_yieldWaitTime); controller.Finish(); } GetUpStreamController is a generic function, its first type-parameter is the return type of the function then 1-5 types can be added as parameter types. The GetUpStreamController call returns an UpStreamItemController instance that can be used to upload parameters ( UploadParam ), Finish or Cancel the uploading. It also implements the IDisposable interface so it can be used in a using statement and will call Finish when disposed. Here's the previous sample using the IDisposable pattern: using (var controller = hub.GetUpStreamController<string, string>(\"UploadWord\")) { controller.OnSuccess(_ => { Debug.log(\"Upload finished!\"); }); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"Hello \"); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"World\"); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"!!\"); yield return new WaitForSeconds(_yieldWaitTime); } The controller also implements the IFuture interface to be able to subscribe to the OnSuccess , OnError and OnComplete . Related server code: public class UploadHub : Hub { public async Task<string> UploadWord(ChannelReader<string> source) { var sb = new StringBuilder(); // receiving a StreamCompleteMessage should cause this WaitToRead to return false while (await source.WaitToReadAsync()) { while (source.TryRead(out var item)) { Debug.WriteLine($\"received: {item}\"); Console.WriteLine($\"received: {item}\"); sb.Append(item); } } // method returns, somewhere else returns a CompletionMessage with any errors return sb.ToString(); } } Streaming to and from the server After using GetDownStreamController to stream results from the server and GetUpStreamController to stream parameters to the server, there's a third one to merge these two's functionality, the GetUpAndDownStreamController function. With its help we can stream parameters to a server-side function just like with GetUpStreamController and stream down its result to the client like we can with GetDownStreamController . Here's an example usage: using (var controller = hub.GetUpAndDownStreamController<string, string>(\"StreamEcho\")) { controller.OnSuccess(_ => { Debug.log(\"Finished!\"); }); controller.OnItem(item => { Debug.log(\"On Item: \" + item); }); const int numMessages = 5; for (int i = 0; i < numMessages; i++) { yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(string.Format(\"Message from client {0}/{1}\", i + 1, numMessages)); } yield return new WaitForSeconds(_yieldWaitTime); } GetUpAndDownStreamController also returns with an UpStreamItemController instance, but in this case its OnItem can be used too. The callback passed to the OnItem call will be called for every item the server sends back to the client. Related server code: public class UploadHub : Hub { public ChannelReader<string> StreamEcho(ChannelReader<string> source) { var output = Channel.CreateUnbounded<string>(); _ = Task.Run(async () => { while (await source.WaitToReadAsync()) { while (source.TryRead(out var item)) { Debug.WriteLine($\"Echoing '{item}'.\"); await output.Writer.WriteAsync(\"echo:\" + item); } } output.Writer.Complete(); }); return output.Reader; } } Send non-streaming parameter GetUpStreamController and GetUpAndDownStreamController can send non-streaming parameters with theirs initial requests. An example of sending multiple non-streaming and a streaming parameter: public enum MyEnum { None, One, Two } public sealed class Metadata { public string strData; public int intData; public MyEnum myEnum; } using (var controller = hub.GetUpStreamController<int, Person>(\"MixedArgsTest\", /*int: */ 1, /*string: */ \"text test\", new Metadata() { strData = \"string data\", intData = 5, myEnum = MyEnum.One })) { const int numMessages = 5; for (int i = 0; i < numMessages; i++) { Person person = new Person() { Name = \"Mr. Smith\", Age = 20 + i * 2 }; controller.UploadParam(person); } } Server code: public enum MyEnum { None, One, Two } public sealed class Metadata { public string strData; public int intData; public MyEnum myEnum; } public async Task<int> MixedArgsTest(ChannelReader<Person> source, int intParam, string stringParam, Metadata metadata) { int count = 0; while (await source.WaitToReadAsync()) { while (source.TryRead(out var item)) { count++; } } return count; }","title":"The HubConnection Class"},{"location":"6.SignalRCore/1.HubConnection/#the-hubconnection-class","text":"The HubConnection is the main entry point for a SignalR Core connection.","title":"The HubConnection Class"},{"location":"6.SignalRCore/1.HubConnection/#protocols","text":"SignalR Core supports different protocols to encode its messages like Json and MessagePack. The safest is to use json, as that's the default encoder of the server. But if possible it's recommended to use MessagePack. More can be read about this under the Encoders topic . On this page the JsonProtocol combined with the LitJsonEncoder will be used, as these work out of the box. A new HubConnection object must be initialized with the uri of the server endpoint and with the protocol that the client want to communicate with: hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new LitJsonEncoder()));","title":"Protocols"},{"location":"6.SignalRCore/1.HubConnection/#huboptions","text":"HubConnection 's constructor can accept a HubOptions instance too: HubOptions options = new HubOptions(); hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new LitJsonEncoder()), options); HubOptions contains the following properties to set: SkipNegotiation : When this is set to true, the plugin will skip the negotiation request if the PreferedTransport is WebSocket. Its default value is false. PreferedTransport : The preferred transport to choose when more than one available. Its default value is TransportTypes.WebSocket. When the plugin can't connect with the preferred transport it will try the next available (long polling). If all transport fails to connect, it will emit an OnError event. PingInterval : A ping message is only sent if the interval has elapsed without a message being sent. Its default value is 15 seconds. PingTimeoutInterval : If the client doesn't see any message in this interval, considers the connection broken. Its default value is 30 seconds. MaxRedirects : The maximum count of redirect negoitiation result that the plugin will follow. Its default value is 100. ConnectTimeout : The maximum time that the plugin allowed to spend trying to connect. Its default value is 1 minute.","title":"HubOptions"},{"location":"6.SignalRCore/1.HubConnection/#events","text":"OnConnected : This event is called when successfully connected to the hub. OnError : This event is called when an unexpected error happen and the connection is closed. OnClosed : This event is called when the connection is gracefully terminated. OnMessage : This event is called for every server-sent message. When returns false, no further processing of the message is done by the plugin. OnReconnecting : Called when the HubConnection start its reconnection process after loosing its underlying connection. OnReconnected : Called after a succesfull reconnection. OnRedirected : This event is called when the connection is redirected to a new uri. OnTransportEvent : Called for transport related events: SelectedToConnect : Transport is selected to try to connect to the server FailedToConnect : Transport failed to connect to the server. This event can occur after SelectedToConnect, when already connected and an error occurs it will be a ClosedWithError one. Connected : The transport successfully connected to the server. Closed : Transport gracefully terminated. ClosedWithError : Unexpected error occured and the transport can't recover from it.","title":"Events"},{"location":"6.SignalRCore/1.HubConnection/#properties","text":"Uri : Uri of the Hub endpoint State : Current state of the connection. Transport : Current, active ITransport instance. Protocol : The IProtocol implementation that will parse, encode and decode messages. AuthenticationProvider : An IAuthenticationProvider implementation that will be used to authenticate the connection. Its default value is an instance of the DefaultAccessTokenAuthenticator class. NegotiationResult : Negotiation response sent by the server. Options : Options that has been used to create the HubConnection. RedirectCount : How many times this connection is redirected. ReconnectPolicy : The reconnect policy that will be used when the underlying connection is lost. Its default value is null.","title":"Properties"},{"location":"6.SignalRCore/1.HubConnection/#connecting-to-the-server","text":"To start the protocol's connection process the StartConnect and ConnectAsync functions can be used.","title":"Connecting to the server"},{"location":"6.SignalRCore/1.HubConnection/#invoking-server-methods","text":"To invoke a method on a server that doesn't return a value, the Send and SendAsync methods can be used. Client code: hub.Send(\"Send\", \"my message\"); await hub.SendAsync(\"Send\", \"my message\"); Or with a cancellation token: using (var source = new CancellationTokenSource(TimeSpan.FromSeconds(2))) { try { await hub.SendAsync(\"Send\", source.Token, \"my message\"); } catch(TaskCanceledException) { Debug.Log(\"Timed out!\"); } } Notice It can't cancel an already sent call, the server still going to process it, but the client going to give back controll sooner. Its first parameter is the name of the method on the server, than a parameter list can be passed that will be sent to the server. Related server code: public class TestHub : Hub { public Task Send(string message) { return Clients.All.SendAsync(\"Send\", $\"{Context.ConnectionId}: {message}\"); } }","title":"Invoking server methods"},{"location":"6.SignalRCore/1.HubConnection/#invoking-server-functions","text":"Invoking a server function can be done with the generic Invoke<TResult> or InvokeAsync<TResult> functions. TResult is the expected type that the server function returns with. Sample: hub.Invoke<int>(\"Add\", 10, 20) .OnSuccess(result => Debug.log(\"10+20: \" + result)) .OnError(error => Debug.log(\"Add(10, 20) failed to execute. Error: \" + error)); var addResult = await hub.InvokeAsync<int>(\"Add\", 10, 20); AddText(string.Format(\"'<color=green>Add(10, 20)</color>' returned: '<color=yellow>{0}</color>'\", addResult)).AddLeftPadding(20); Invoke returns with an IFuture<TResult> that can be used to subscribe to various Invoke related events: OnSuccess : Callback passed for OnSuccess is called when the server side function is executed and the callback's parameter will be function's return value. OnError : Callback passed to this function will be called when there's an error executing the function. The error can be a client or server error. The callback's error parameter will contain information about the error. OnComplete : Callback passed to this function will be called after an OnSuccess or OnError callback. InvokeAsync returns with Task<TResult> that can be awaited. As a second parameter a CancellationToken can be added to cancel the call on client side. using (var source = new CancellationTokenSource(TimeSpan.FromSeconds(2))) { try { var addResult = await hub.InvokeAsync<int>(\"Add\", source.Token, 10, 20); // ... } catch(TaskCanceledException) { Debug.Log(\"Timed out!\"); } } Related server code: public class TestHub : Hub { public int Add(int x, int y) { return x + y; } } Notice All Send , Invoke and theirs *Async counterparts are going to wait for a completion message from the server and their IFuture/Task completes when received it.","title":"Invoking server functions"},{"location":"6.SignalRCore/1.HubConnection/#server-callable-client-methods","text":"Clients can define server-callable methods using the generic and non-generic On method. The non-generic On can be used when the server-callable method has no parameter and the generic one for methods with at least one parameter. Samples: // Generic On with one string argument. hub.On(\"Send\", (string arg) => Debug.log(\"Server-sent text: \" + arg)); // Generic On, with one type: hub.On<Person>(\"Person\", (person) => Debug.log(\"Server-sent data: \" + person.ToString())); // Generic On, with two types: hub.On<Person, Person>(\"TwoPersons\", (person1, person2) => Debug.log(\"...\")); sealed class Person { public string Name { get; set; } public long Age { get; set; } public override string ToString() { return string.Format(\"[Person Name: '{0}', Age: '<color=yellow>{1}</color>']\", this.Name, this.Age.ToString()); } } Related server code: public class TestHub : Hub { public override async Task OnConnectedAsync() { await Clients.All.SendAsync(\"Send\", $\"{Context.ConnectionId} joined\"); await Clients.Client(Context.ConnectionId).SendAsync(\"Person\", new Person { Name = \"Person 007\", Age = 35 }); await Clients.Client(Context.ConnectionId).SendAsync(\"TwoPersons\", new Person { Name = \"Person 008\", Age = 36 }, new Person { Name = \"Person 009\", Age = 37 }); } }","title":"Server callable client methods"},{"location":"6.SignalRCore/1.HubConnection/#streaming-from-the-server","text":"When the server sends one return value at a time the client can call a callback for every item if the server function is called using the GetDownStreamController<TDown> function. Sample: hub.GetDownStreamController<Person>(\"GetRandomPersons\", 20, 2000) .OnItem(result => Debug.log(\"New item arrived: \" + result.ToString())) .OnSuccess(_ => Debug.log(\"Streaming finished!\")); GetDownStreamController 's return value is a DownStreamItemController<TDown> that implements the IFuture<TResult> interface. With DownStreamItemController's OnItem function it can be subscribed for a callback that will be called for every downloaded item. The instance of DownStreamItemController<TDown> can be used to cancel the streaming: var controller = hub.GetDownStreamController<int>(\"ChannelCounter\", 10, 1000); controller.OnItem(result => Debug.log(\"New item arrived: \" + result.ToString())) .OnSuccess(_ => Debug.log(\"Streaming finished!\")) .OnError(error => Debug.log(\"Error: \" + error)); // A stream request can be cancelled any time by calling the controller's Cancel method controller.Cancel(); Related server code: public class TestHub : Hub { public ChannelReader<Person> GetRandomPersons(int count, int delay) { var channel = Channel.CreateUnbounded<Person>(); Task.Run(async () => { Random rand = new Random(); for (var i = 0; i < count; i++) { await channel.Writer.WriteAsync(new Person { Name = \"Name_\" + rand.Next(), Age = rand.Next(20, 99) }); await Task.Delay(delay); } await Clients.Client(Context.ConnectionId).SendAsync(\"Person\", new Person { Name = \"Person 000\", Age = 0 }); channel.Writer.TryComplete(); }); return channel.Reader; } }","title":"Streaming from the server"},{"location":"6.SignalRCore/1.HubConnection/#streaming-to-the-server","text":"To stream one or more parameters to a server function the GetUpStreamController can be used: private IEnumerator UploadWord() { var controller = hub.GetUpStreamController<string, string>(\"UploadWord\"); controller.OnSuccess(result => { Debug.log(\"Upload finished!\"); }); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"Hello \"); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"World\"); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"!!\"); yield return new WaitForSeconds(_yieldWaitTime); controller.Finish(); } GetUpStreamController is a generic function, its first type-parameter is the return type of the function then 1-5 types can be added as parameter types. The GetUpStreamController call returns an UpStreamItemController instance that can be used to upload parameters ( UploadParam ), Finish or Cancel the uploading. It also implements the IDisposable interface so it can be used in a using statement and will call Finish when disposed. Here's the previous sample using the IDisposable pattern: using (var controller = hub.GetUpStreamController<string, string>(\"UploadWord\")) { controller.OnSuccess(_ => { Debug.log(\"Upload finished!\"); }); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"Hello \"); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"World\"); yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(\"!!\"); yield return new WaitForSeconds(_yieldWaitTime); } The controller also implements the IFuture interface to be able to subscribe to the OnSuccess , OnError and OnComplete . Related server code: public class UploadHub : Hub { public async Task<string> UploadWord(ChannelReader<string> source) { var sb = new StringBuilder(); // receiving a StreamCompleteMessage should cause this WaitToRead to return false while (await source.WaitToReadAsync()) { while (source.TryRead(out var item)) { Debug.WriteLine($\"received: {item}\"); Console.WriteLine($\"received: {item}\"); sb.Append(item); } } // method returns, somewhere else returns a CompletionMessage with any errors return sb.ToString(); } }","title":"Streaming to the server"},{"location":"6.SignalRCore/1.HubConnection/#streaming-to-and-from-the-server","text":"After using GetDownStreamController to stream results from the server and GetUpStreamController to stream parameters to the server, there's a third one to merge these two's functionality, the GetUpAndDownStreamController function. With its help we can stream parameters to a server-side function just like with GetUpStreamController and stream down its result to the client like we can with GetDownStreamController . Here's an example usage: using (var controller = hub.GetUpAndDownStreamController<string, string>(\"StreamEcho\")) { controller.OnSuccess(_ => { Debug.log(\"Finished!\"); }); controller.OnItem(item => { Debug.log(\"On Item: \" + item); }); const int numMessages = 5; for (int i = 0; i < numMessages; i++) { yield return new WaitForSeconds(_yieldWaitTime); controller.UploadParam(string.Format(\"Message from client {0}/{1}\", i + 1, numMessages)); } yield return new WaitForSeconds(_yieldWaitTime); } GetUpAndDownStreamController also returns with an UpStreamItemController instance, but in this case its OnItem can be used too. The callback passed to the OnItem call will be called for every item the server sends back to the client. Related server code: public class UploadHub : Hub { public ChannelReader<string> StreamEcho(ChannelReader<string> source) { var output = Channel.CreateUnbounded<string>(); _ = Task.Run(async () => { while (await source.WaitToReadAsync()) { while (source.TryRead(out var item)) { Debug.WriteLine($\"Echoing '{item}'.\"); await output.Writer.WriteAsync(\"echo:\" + item); } } output.Writer.Complete(); }); return output.Reader; } }","title":"Streaming to and from the server"},{"location":"6.SignalRCore/1.HubConnection/#send-non-streaming-parameter","text":"GetUpStreamController and GetUpAndDownStreamController can send non-streaming parameters with theirs initial requests. An example of sending multiple non-streaming and a streaming parameter: public enum MyEnum { None, One, Two } public sealed class Metadata { public string strData; public int intData; public MyEnum myEnum; } using (var controller = hub.GetUpStreamController<int, Person>(\"MixedArgsTest\", /*int: */ 1, /*string: */ \"text test\", new Metadata() { strData = \"string data\", intData = 5, myEnum = MyEnum.One })) { const int numMessages = 5; for (int i = 0; i < numMessages; i++) { Person person = new Person() { Name = \"Mr. Smith\", Age = 20 + i * 2 }; controller.UploadParam(person); } } Server code: public enum MyEnum { None, One, Two } public sealed class Metadata { public string strData; public int intData; public MyEnum myEnum; } public async Task<int> MixedArgsTest(ChannelReader<Person> source, int intParam, string stringParam, Metadata metadata) { int count = 0; while (await source.WaitToReadAsync()) { while (source.TryRead(out var item)) { count++; } } return count; }","title":"Send non-streaming parameter"},{"location":"6.SignalRCore/2.Authentication/","text":"The IAuthenticationProvider interface To authenticate a SignalR Core session an IAuthenticationProvider implementation can be set to the hub connection's AuthenticationProvider property. The plugin implements a DefaultAccessTokenAuthenticator and uses it as the default authenticator. The IAuthenticationProvider has the following properties and events: IsPreAuthRequired : The authentication must be run before any request made to build up the SignalR protocol if this property is true. OnAuthenticationSucceded : This event must be called when the pre-authentication succeded. When IsPreAuthRequired is false, no-one will subscribe to this event. OnAuthenticationFailed : This event must be called when the pre-authentication failed. When IsPreAuthRequired is false, no-one will subscribe to this event. StartAuthentication : This function called once, when the before the SignalR negotiation begins. If IsPreAuthRequired is false, then this step will be skipped. PrepareRequest : This function will be called for every request before sending it. PrepareUri : This function can customize the given uri. If there's no intention to modify the uri, this function should return with the parameter. Default Implementation Here's the implementation of the DefaultAccessTokenAuthenticator : using System; namespace BestHTTP.SignalRCore.Authentication { public sealed class DefaultAccessTokenAuthenticator : IAuthenticationProvider { /// <summary> /// No pre-auth step required for this type of authentication /// </summary> public bool IsPreAuthRequired { get { return false; } } #pragma warning disable 0067 /// <summary> /// Not used event as IsPreAuthRequired is false /// </summary> public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; /// <summary> /// Not used event as IsPreAuthRequired is false /// </summary> public event OnAuthenticationFailedDelegate OnAuthenticationFailed; #pragma warning restore 0067 private HubConnection _connection; public DefaultAccessTokenAuthenticator(HubConnection connection) { this._connection = connection; } /// <summary> /// Not used as IsPreAuthRequired is false /// </summary> public void StartAuthentication() { } /// <summary> /// Prepares the request by adding two headers to it /// </summary> public void PrepareRequest(BestHTTP.HTTPRequest request) { if (this._connection.NegotiationResult == null) return; // Add Authorization header to http requests, add access_token param to the uri otherwise if (BestHTTP.Connections.HTTPProtocolFactory.GetProtocolFromUri(request.CurrentUri) == BestHTTP.Connections.SupportedProtocols.HTTP) request.SetHeader(\"Authorization\", \"Bearer \" + this._connection.NegotiationResult.AccessToken); else #if !BESTHTTP_DISABLE_WEBSOCKET if (BestHTTP.Connections.HTTPProtocolFactory.GetProtocolFromUri(request.Uri) != BestHTTP.Connections.SupportedProtocols.WebSocket) request.Uri = PrepareUriImpl(request.Uri); #else ; #endif } public Uri PrepareUri(Uri uri) { if (this._connection.NegotiationResult == null) return uri; if (uri.Query.StartsWith(\"??\")) { UriBuilder builder = new UriBuilder(uri); builder.Query = builder.Query.Substring(2); return builder.Uri; } #if !BESTHTTP_DISABLE_WEBSOCKET if (BestHTTP.Connections.HTTPProtocolFactory.GetProtocolFromUri(uri) == BestHTTP.Connections.SupportedProtocols.WebSocket) uri = PrepareUriImpl(uri); #endif return uri; } private Uri PrepareUriImpl(Uri uri) { string query = string.IsNullOrEmpty(uri.Query) ? \"\" : uri.Query + \"&\"; UriBuilder uriBuilder = new UriBuilder(uri.Scheme, uri.Host, uri.Port, uri.AbsolutePath, query + \"access_token=\" + this._connection.NegotiationResult.AccessToken); return uriBuilder.Uri; } public void Cancel() { } } } Using an IAuthenticationProvider implementation An IAuthenticationProvider implementation can be used through the HubConnection 's AuthenticationProvider : hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new LitJsonEncoder())); hub.AuthenticationProvider = new BestHTTP.SignalRCore.Authentication.DefaultAccessTokenAuthenticator(hub);","title":"The IAuthenticationProvider interface"},{"location":"6.SignalRCore/2.Authentication/#the-iauthenticationprovider-interface","text":"To authenticate a SignalR Core session an IAuthenticationProvider implementation can be set to the hub connection's AuthenticationProvider property. The plugin implements a DefaultAccessTokenAuthenticator and uses it as the default authenticator. The IAuthenticationProvider has the following properties and events: IsPreAuthRequired : The authentication must be run before any request made to build up the SignalR protocol if this property is true. OnAuthenticationSucceded : This event must be called when the pre-authentication succeded. When IsPreAuthRequired is false, no-one will subscribe to this event. OnAuthenticationFailed : This event must be called when the pre-authentication failed. When IsPreAuthRequired is false, no-one will subscribe to this event. StartAuthentication : This function called once, when the before the SignalR negotiation begins. If IsPreAuthRequired is false, then this step will be skipped. PrepareRequest : This function will be called for every request before sending it. PrepareUri : This function can customize the given uri. If there's no intention to modify the uri, this function should return with the parameter.","title":"The IAuthenticationProvider interface"},{"location":"6.SignalRCore/2.Authentication/#default-implementation","text":"Here's the implementation of the DefaultAccessTokenAuthenticator : using System; namespace BestHTTP.SignalRCore.Authentication { public sealed class DefaultAccessTokenAuthenticator : IAuthenticationProvider { /// <summary> /// No pre-auth step required for this type of authentication /// </summary> public bool IsPreAuthRequired { get { return false; } } #pragma warning disable 0067 /// <summary> /// Not used event as IsPreAuthRequired is false /// </summary> public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; /// <summary> /// Not used event as IsPreAuthRequired is false /// </summary> public event OnAuthenticationFailedDelegate OnAuthenticationFailed; #pragma warning restore 0067 private HubConnection _connection; public DefaultAccessTokenAuthenticator(HubConnection connection) { this._connection = connection; } /// <summary> /// Not used as IsPreAuthRequired is false /// </summary> public void StartAuthentication() { } /// <summary> /// Prepares the request by adding two headers to it /// </summary> public void PrepareRequest(BestHTTP.HTTPRequest request) { if (this._connection.NegotiationResult == null) return; // Add Authorization header to http requests, add access_token param to the uri otherwise if (BestHTTP.Connections.HTTPProtocolFactory.GetProtocolFromUri(request.CurrentUri) == BestHTTP.Connections.SupportedProtocols.HTTP) request.SetHeader(\"Authorization\", \"Bearer \" + this._connection.NegotiationResult.AccessToken); else #if !BESTHTTP_DISABLE_WEBSOCKET if (BestHTTP.Connections.HTTPProtocolFactory.GetProtocolFromUri(request.Uri) != BestHTTP.Connections.SupportedProtocols.WebSocket) request.Uri = PrepareUriImpl(request.Uri); #else ; #endif } public Uri PrepareUri(Uri uri) { if (this._connection.NegotiationResult == null) return uri; if (uri.Query.StartsWith(\"??\")) { UriBuilder builder = new UriBuilder(uri); builder.Query = builder.Query.Substring(2); return builder.Uri; } #if !BESTHTTP_DISABLE_WEBSOCKET if (BestHTTP.Connections.HTTPProtocolFactory.GetProtocolFromUri(uri) == BestHTTP.Connections.SupportedProtocols.WebSocket) uri = PrepareUriImpl(uri); #endif return uri; } private Uri PrepareUriImpl(Uri uri) { string query = string.IsNullOrEmpty(uri.Query) ? \"\" : uri.Query + \"&\"; UriBuilder uriBuilder = new UriBuilder(uri.Scheme, uri.Host, uri.Port, uri.AbsolutePath, query + \"access_token=\" + this._connection.NegotiationResult.AccessToken); return uriBuilder.Uri; } public void Cancel() { } } }","title":"Default Implementation"},{"location":"6.SignalRCore/2.Authentication/#using-an-iauthenticationprovider-implementation","text":"An IAuthenticationProvider implementation can be used through the HubConnection 's AuthenticationProvider : hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new LitJsonEncoder())); hub.AuthenticationProvider = new BestHTTP.SignalRCore.Authentication.DefaultAccessTokenAuthenticator(hub);","title":"Using an IAuthenticationProvider implementation"},{"location":"6.SignalRCore/3.Encoders/","text":"Encoders SignalR Core can use different encodings to send and receive messages. Current encodings are JSon and MessagePack. Using these are not automatic, as most of these implementations require 3rd plugins and/or changes to the server. Advice: If possible use MessagePack as it's more efficient memory and cpu wise too! JSon For the plugin, the JSon encoder is available without any additional steps. The JsonProtocol class is a generic implementation that can work with different encoders that can use concreate JSON parsers. The one that comes with the plugin is the LitJsonEncoder . hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new LitJsonEncoder())); How to Enable and Use Newtonsoft's JSON .NET For Unity Encoder There's an encoder implementation that uses the Newtonsoft's JSON .NET For Unity package. Steps to enable it and use it: Download and import the Newtonsoft's JSON .NET For Unity package Add the BESTHTTP_SIGNALR_CORE_ENABLE_NEWTONSOFT_JSON_DOTNET_ENCODER define to the Scripting Define Symbols input under PlayerSettings/Other Settings : Use the now-available JsonDotNetEncoder class: hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new JsonDotNetEncoder())); The JsonDotNetEncoder and the LitJsonEncoder classes can be found in the Best HTTP\\Examples\\SignalRCore\\Encoders\\ folder. MessagePack By default the server has support for the JSon encoding but by adding new packages and a few lines of code the MessagePack encoding can be enabled too. There's a MessagePack encoding implementation for the plugin, but it's disabled by default. To enable and use it, follow these steps: Download and import the Json & MessagePack Serialization package Create a new Asembly Definition file under the Plugins\\GameDevWare.Serialization folder Locate the BestHTTP.asmdef file under the Best HTTP folder Reference the newly create asmdef file and press Apply: Add the BESTHTTP_SIGNALR_CORE_ENABLE_GAMEDEVWARE_MESSAGEPACK define to the Scripting Define Symbols input under PlayerSettings/Other Settings : Use the now available MessagePackProtocol class: hub = new HubConnection(new Uri(\"https://server/hub\"), new MessagePackProtocol()); As you can see, the MessagePackProtocol uses only one class there's no MessagePackEncoder as it's very specific and uses directly the Json & MessagePack Serialization classes. The MessagePackProtocol class can be found in the Best HTTP\\Examples\\SignalRCore\\Encoders\\ folder.","title":"Encoders"},{"location":"6.SignalRCore/3.Encoders/#encoders","text":"SignalR Core can use different encodings to send and receive messages. Current encodings are JSon and MessagePack. Using these are not automatic, as most of these implementations require 3rd plugins and/or changes to the server. Advice: If possible use MessagePack as it's more efficient memory and cpu wise too!","title":"Encoders"},{"location":"6.SignalRCore/3.Encoders/#json","text":"For the plugin, the JSon encoder is available without any additional steps. The JsonProtocol class is a generic implementation that can work with different encoders that can use concreate JSON parsers. The one that comes with the plugin is the LitJsonEncoder . hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new LitJsonEncoder()));","title":"JSon"},{"location":"6.SignalRCore/3.Encoders/#how-to-enable-and-use-newtonsofts-json-net-for-unity-encoder","text":"There's an encoder implementation that uses the Newtonsoft's JSON .NET For Unity package. Steps to enable it and use it: Download and import the Newtonsoft's JSON .NET For Unity package Add the BESTHTTP_SIGNALR_CORE_ENABLE_NEWTONSOFT_JSON_DOTNET_ENCODER define to the Scripting Define Symbols input under PlayerSettings/Other Settings : Use the now-available JsonDotNetEncoder class: hub = new HubConnection(new Uri(\"https://server/hub\"), new JsonProtocol(new JsonDotNetEncoder())); The JsonDotNetEncoder and the LitJsonEncoder classes can be found in the Best HTTP\\Examples\\SignalRCore\\Encoders\\ folder.","title":"How to Enable and Use Newtonsoft's JSON .NET For Unity Encoder"},{"location":"6.SignalRCore/3.Encoders/#messagepack","text":"By default the server has support for the JSon encoding but by adding new packages and a few lines of code the MessagePack encoding can be enabled too. There's a MessagePack encoding implementation for the plugin, but it's disabled by default. To enable and use it, follow these steps: Download and import the Json & MessagePack Serialization package Create a new Asembly Definition file under the Plugins\\GameDevWare.Serialization folder Locate the BestHTTP.asmdef file under the Best HTTP folder Reference the newly create asmdef file and press Apply: Add the BESTHTTP_SIGNALR_CORE_ENABLE_GAMEDEVWARE_MESSAGEPACK define to the Scripting Define Symbols input under PlayerSettings/Other Settings : Use the now available MessagePackProtocol class: hub = new HubConnection(new Uri(\"https://server/hub\"), new MessagePackProtocol()); As you can see, the MessagePackProtocol uses only one class there's no MessagePackEncoder as it's very specific and uses directly the Json & MessagePack Serialization classes. The MessagePackProtocol class can be found in the Best HTTP\\Examples\\SignalRCore\\Encoders\\ folder.","title":"MessagePack"},{"location":"6.SignalRCore/4.IRetryPolicy/","text":"Automatic reconnection and the IRetryPolicy interface With ASP.net Core 3 SignalR Core supports automatic reconnection through the IRetryPolicy interface: public interface IRetryPolicy { /// <summary> /// This function must return with a delay time to wait until a new connection attempt, or null to do not do another one. /// </summary> TimeSpan? GetNextRetryDelay(RetryContext context); } GetNextRetryDelay receives a RetryContext object as a parameter and must return a TimeSpan indicating a delay between the next reconnect attempt, or null to do not try to do further attempts and report the connection broken. RetryContext RetryContext has the following fields: PreviousRetryCount : Previous reconnect attempts. A successful connection sets it back to zero. ElapsedTime : Elapsed time since the original connection error. RetryReason : String representation of the connection error. When called, GetNextRetryDelay always receives an up to date RetryContext . Default implementation The default IRetryPolicy implementation that the plugin uses by default looks like this: public sealed class DefaultRetryPolicy : IRetryPolicy { private static TimeSpan?[] DefaultBackoffTimes = new TimeSpan?[] { TimeSpan.Zero, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30), null }; TimeSpan?[] backoffTimes; public DefaultRetryPolicy() { this.backoffTimes = DefaultBackoffTimes; } public DefaultRetryPolicy(TimeSpan?[] customBackoffTimes) { this.backoffTimes = customBackoffTimes; } public TimeSpan? GetNextRetryDelay(RetryContext context) { if (context.PreviousRetryCount >= this.backoffTimes.Length) return null; return this.backoffTimes[context.PreviousRetryCount]; } } To use it an instance must be set to the HubConnection's ReconnectPolicy property: hub = new HubConnection(new Uri(\"...\"), new JsonProtocol(new LitJsonEncoder()), options); hub.ReconnectPolicy = new DefaultRetryPolicy(); Or with custom backoff times: hub = new HubConnection(new Uri(base.sampleSelector.BaseURL + this._path), new JsonProtocol(new LitJsonEncoder()), options); hub.ReconnectPolicy = new DefaultRetryPolicy(new TimeSpan?[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(15), TimeSpan.FromSeconds(45), TimeSpan.FromSeconds(90), null });","title":"Automatic reconnection and the IRetryPolicy interface"},{"location":"6.SignalRCore/4.IRetryPolicy/#automatic-reconnection-and-the-iretrypolicy-interface","text":"With ASP.net Core 3 SignalR Core supports automatic reconnection through the IRetryPolicy interface: public interface IRetryPolicy { /// <summary> /// This function must return with a delay time to wait until a new connection attempt, or null to do not do another one. /// </summary> TimeSpan? GetNextRetryDelay(RetryContext context); } GetNextRetryDelay receives a RetryContext object as a parameter and must return a TimeSpan indicating a delay between the next reconnect attempt, or null to do not try to do further attempts and report the connection broken.","title":"Automatic reconnection and the IRetryPolicy interface"},{"location":"6.SignalRCore/4.IRetryPolicy/#retrycontext","text":"RetryContext has the following fields: PreviousRetryCount : Previous reconnect attempts. A successful connection sets it back to zero. ElapsedTime : Elapsed time since the original connection error. RetryReason : String representation of the connection error. When called, GetNextRetryDelay always receives an up to date RetryContext .","title":"RetryContext"},{"location":"6.SignalRCore/4.IRetryPolicy/#default-implementation","text":"The default IRetryPolicy implementation that the plugin uses by default looks like this: public sealed class DefaultRetryPolicy : IRetryPolicy { private static TimeSpan?[] DefaultBackoffTimes = new TimeSpan?[] { TimeSpan.Zero, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30), null }; TimeSpan?[] backoffTimes; public DefaultRetryPolicy() { this.backoffTimes = DefaultBackoffTimes; } public DefaultRetryPolicy(TimeSpan?[] customBackoffTimes) { this.backoffTimes = customBackoffTimes; } public TimeSpan? GetNextRetryDelay(RetryContext context) { if (context.PreviousRetryCount >= this.backoffTimes.Length) return null; return this.backoffTimes[context.PreviousRetryCount]; } } To use it an instance must be set to the HubConnection's ReconnectPolicy property: hub = new HubConnection(new Uri(\"...\"), new JsonProtocol(new LitJsonEncoder()), options); hub.ReconnectPolicy = new DefaultRetryPolicy(); Or with custom backoff times: hub = new HubConnection(new Uri(base.sampleSelector.BaseURL + this._path), new JsonProtocol(new LitJsonEncoder()), options); hub.ReconnectPolicy = new DefaultRetryPolicy(new TimeSpan?[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(15), TimeSpan.FromSeconds(45), TimeSpan.FromSeconds(90), null });","title":"Default implementation"},{"location":"6.SignalRCore/5.AzureSignalRService/","text":"How to connect to an Azure SignalR Service Here's a sample implementation to connect to an Azure SignalR Serverice: using System.Collections; using System.Collections.Generic; using UnityEngine; using BestHTTP.SignalRCore; using System; using BestHTTP; public class SignalRService : MonoBehaviour { // Use this for initialization void Start () { var conn = new HubConnection(new Uri(\"http://localhost:5000/chat\"), new JsonProtocol(new BestHTTP.SignalRCore.Encoders.LitJsonEncoder())); conn.AuthenticationProvider = new AzureSignalRServiceAuthenticator(conn); conn.OnConnected += OnConnected; conn.On<string, string>(\"BroadcastMessage\", OnBroadcastMessage); conn.StartConnect(); } private void OnBroadcastMessage(string name, string message) { Debug.LogFormat(\"[{0}]: {1}\", name, message); } private void OnConnected(HubConnection hub) { hub.Send(\"BroadcastMessage\", \"Best HTTP Client\", \"Hello World!\"); } } public sealed class AzureSignalRServiceAuthenticator : IAuthenticationProvider { /// <summary> /// No pre-auth step required for this type of authentication /// </summary> public bool IsPreAuthRequired { get { return false; } } #pragma warning disable 0067 /// <summary> /// Not used event as IsPreAuthRequired is false /// </summary> public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; /// <summary> /// Not used event as IsPreAuthRequired is false /// </summary> public event OnAuthenticationFailedDelegate OnAuthenticationFailed; #pragma warning restore 0067 private HubConnection _connection; public AzureSignalRServiceAuthenticator(HubConnection connection) { this._connection = connection; } /// <summary> /// Not used as IsPreAuthRequired is false /// </summary> public void StartAuthentication() { } /// <summary> /// Prepares the request by adding two headers to it /// </summary> public void PrepareRequest(BestHTTP.HTTPRequest request) { if (this._connection.NegotiationResult == null) return; // Add Authorization header to http requests, add access_token param to the uri otherwise if (BestHTTP.Connections.HTTPProtocolFactory.GetProtocolFromUri(request.CurrentUri) == BestHTTP.Connections.SupportedProtocols.HTTP) request.SetHeader(\"Authorization\", \"Bearer \" + this._connection.NegotiationResult.AccessToken); else request.Uri = PrepareUriImpl(request.Uri); } public Uri PrepareUri(Uri uri) { if (uri.Query.StartsWith(\"??\")) { UriBuilder builder = new UriBuilder(uri); builder.Query = builder.Query.Substring(2); return builder.Uri; } return uri; } private Uri PrepareUriImpl(Uri uri) { string query = string.IsNullOrEmpty(uri.Query) ? \"\" : uri.Query + \"&\"; UriBuilder uriBuilder = new UriBuilder(uri.Scheme, uri.Host, uri.Port, uri.AbsolutePath, query + \"access_token=\" + this._connection.NegotiationResult.AccessToken); return uriBuilder.Uri; } } Warning When used with Azure Functions Invoke and other client to server messaging can be done through Azure Functions (HTTP requests). See https://docs.microsoft.com/en-us/azure/azure-signalr/signalr-concept-serverless-development-config#sending-messages-from-a-client-to-the-service","title":"How to connect to an Azure SignalR Service"},{"location":"6.SignalRCore/5.AzureSignalRService/#how-to-connect-to-an-azure-signalr-service","text":"Here's a sample implementation to connect to an Azure SignalR Serverice: using System.Collections; using System.Collections.Generic; using UnityEngine; using BestHTTP.SignalRCore; using System; using BestHTTP; public class SignalRService : MonoBehaviour { // Use this for initialization void Start () { var conn = new HubConnection(new Uri(\"http://localhost:5000/chat\"), new JsonProtocol(new BestHTTP.SignalRCore.Encoders.LitJsonEncoder())); conn.AuthenticationProvider = new AzureSignalRServiceAuthenticator(conn); conn.OnConnected += OnConnected; conn.On<string, string>(\"BroadcastMessage\", OnBroadcastMessage); conn.StartConnect(); } private void OnBroadcastMessage(string name, string message) { Debug.LogFormat(\"[{0}]: {1}\", name, message); } private void OnConnected(HubConnection hub) { hub.Send(\"BroadcastMessage\", \"Best HTTP Client\", \"Hello World!\"); } } public sealed class AzureSignalRServiceAuthenticator : IAuthenticationProvider { /// <summary> /// No pre-auth step required for this type of authentication /// </summary> public bool IsPreAuthRequired { get { return false; } } #pragma warning disable 0067 /// <summary> /// Not used event as IsPreAuthRequired is false /// </summary> public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; /// <summary> /// Not used event as IsPreAuthRequired is false /// </summary> public event OnAuthenticationFailedDelegate OnAuthenticationFailed; #pragma warning restore 0067 private HubConnection _connection; public AzureSignalRServiceAuthenticator(HubConnection connection) { this._connection = connection; } /// <summary> /// Not used as IsPreAuthRequired is false /// </summary> public void StartAuthentication() { } /// <summary> /// Prepares the request by adding two headers to it /// </summary> public void PrepareRequest(BestHTTP.HTTPRequest request) { if (this._connection.NegotiationResult == null) return; // Add Authorization header to http requests, add access_token param to the uri otherwise if (BestHTTP.Connections.HTTPProtocolFactory.GetProtocolFromUri(request.CurrentUri) == BestHTTP.Connections.SupportedProtocols.HTTP) request.SetHeader(\"Authorization\", \"Bearer \" + this._connection.NegotiationResult.AccessToken); else request.Uri = PrepareUriImpl(request.Uri); } public Uri PrepareUri(Uri uri) { if (uri.Query.StartsWith(\"??\")) { UriBuilder builder = new UriBuilder(uri); builder.Query = builder.Query.Substring(2); return builder.Uri; } return uri; } private Uri PrepareUriImpl(Uri uri) { string query = string.IsNullOrEmpty(uri.Query) ? \"\" : uri.Query + \"&\"; UriBuilder uriBuilder = new UriBuilder(uri.Scheme, uri.Host, uri.Port, uri.AbsolutePath, query + \"access_token=\" + this._connection.NegotiationResult.AccessToken); return uriBuilder.Uri; } } Warning When used with Azure Functions Invoke and other client to server messaging can be done through Azure Functions (HTTP requests). See https://docs.microsoft.com/en-us/azure/azure-signalr/signalr-concept-serverless-development-config#sending-messages-from-a-client-to-the-service","title":"How to connect to an Azure SignalR Service"},{"location":"7.GlobalTopics/BufferPool/","text":"Buffer Pool To reduce memory garbage production the plugin reuses as much memory as it can. To support this, the plugin implements and uses a byte array pooling mechanism through the BufferPool static class. The plugin uses this class to allocate and release byte[] s back to the pool. To avoid keeping reference to too much memory the plugin requests buffers with a minimum size. This way if the BufferPool has no buffer for the requested size, it can return a larger buffer. Also, buffers stored in the pool can time out, releasing back to the runtime for garbage collection. Pooling mechanism can be disabled, configured and used by outside of the plugin. Configurable fields are the following: IsEnabled : Setting this field to false the pooling mechanism can be disabled. Its default value is true . RemoveOlderThan : Buffer entries that released back to the pool and older than this value are removed from the pool (so the GC can collect them) when next maintenance is triggered. Its default value is 30 seconds. RunMaintenanceEvery : How often pool maintenance must run. Its default value is 10 seconds. MinBufferSize : Minimum buffer size that the plugin will allocate when the requested size is smaller than this value, and canBeLarger is set to true. Its default value 256 bytes. MaxBufferSize : Maximum size of a buffer that the plugin will store. Its default value is long.MaxValue . MaxPoolSize : Maximum accumulated size of the stored buffers. Its default value is 10 Mb. RemoveEmptyLists : Whether to remove empty buffer stores from the free list. Its default value is true . IsDoubleReleaseCheckEnabled : If it set to true and a byte[] is released more than once it will log out an error. Its default value is true when run in the editor, false otherwise. So to disable pooling the following line can be added: BestHTTP.PlatformSupport.Memory.BufferPool.IsEnabled = false; The following functions are available to use the pool: byte[] Get(long size, bool canBeLarger) : Get a byte array from the pool. If canBeLarge is true , the returned buffer might be larger than the requested size. void Release(byte[] buffer) : Release back a byte array to the pool. byte[] Resize(ref byte[] buffer, int newSize, bool canBeLarger) : Resize a byte array. It will release the old one to the pool and get a new one from the pool. void Clear() : Remove all stored entries instantly.","title":"Buffer Pool"},{"location":"7.GlobalTopics/BufferPool/#buffer-pool","text":"To reduce memory garbage production the plugin reuses as much memory as it can. To support this, the plugin implements and uses a byte array pooling mechanism through the BufferPool static class. The plugin uses this class to allocate and release byte[] s back to the pool. To avoid keeping reference to too much memory the plugin requests buffers with a minimum size. This way if the BufferPool has no buffer for the requested size, it can return a larger buffer. Also, buffers stored in the pool can time out, releasing back to the runtime for garbage collection. Pooling mechanism can be disabled, configured and used by outside of the plugin. Configurable fields are the following: IsEnabled : Setting this field to false the pooling mechanism can be disabled. Its default value is true . RemoveOlderThan : Buffer entries that released back to the pool and older than this value are removed from the pool (so the GC can collect them) when next maintenance is triggered. Its default value is 30 seconds. RunMaintenanceEvery : How often pool maintenance must run. Its default value is 10 seconds. MinBufferSize : Minimum buffer size that the plugin will allocate when the requested size is smaller than this value, and canBeLarger is set to true. Its default value 256 bytes. MaxBufferSize : Maximum size of a buffer that the plugin will store. Its default value is long.MaxValue . MaxPoolSize : Maximum accumulated size of the stored buffers. Its default value is 10 Mb. RemoveEmptyLists : Whether to remove empty buffer stores from the free list. Its default value is true . IsDoubleReleaseCheckEnabled : If it set to true and a byte[] is released more than once it will log out an error. Its default value is true when run in the editor, false otherwise. So to disable pooling the following line can be added: BestHTTP.PlatformSupport.Memory.BufferPool.IsEnabled = false; The following functions are available to use the pool: byte[] Get(long size, bool canBeLarger) : Get a byte array from the pool. If canBeLarge is true , the returned buffer might be larger than the requested size. void Release(byte[] buffer) : Release back a byte array to the pool. byte[] Resize(ref byte[] buffer, int newSize, bool canBeLarger) : Resize a byte array. It will release the old one to the pool and get a new one from the pool. void Clear() : Remove all stored entries instantly.","title":"Buffer Pool"},{"location":"7.GlobalTopics/ConnectionPool/","text":"Connection Pooling This topic applies to connections for HTTP/1.1 requests only. HTTP/2 has proper messaging to communicate state changes between the client and server. Building up a TCP connection and negotiating TLS for HTTPS are slow that we can avoid if we reuse the connections for future requests. The plugin informs the server that it want to keep the connection alive for future use by sending a \" Connection: Keep-Alive \" header. While the server could inform the client by sending back a Keep-Alive header about how much time it\u2019s going to wait for a new request before get bored and closing the connection, servers are rarely use and send this Keep-Alive header. So, both the server and clients are blind to each other's setting and there\u2019s no other way other than the keep-alive header to let the other side know when the connection is going to be closed. In a case where the server closes an idle connection after 5 seconds and the client goes with its default 20 seconds, the client going to try to (re)use the connection way behind 5 seconds, resulting in a failed request. One option to fix it to set either the server\u2019s or the client\u2019s setting to the same as the other. Another one is to disable connection reuse completely (set HTTPManager.KeepAliveDefaultValue to false). While this is the safest way, and in some cases can be beneficial (for example when you know that you going to send out requests sparingly, outside of the idle time), it\u2019s better to try to keep the server and client setting in sync to reuse a TCP connection as much as possible. So, it worked because with the new setting, both the client and server closed the connection about the same time. Setting the client to the same value still can result in failed connections however, because the server starts to count down when it finished writing the response to the wire, and the client starts to count down when it finished receiving it. With a slow network (== high network latency), this can be large enough to increase the chance that the client is trying to use a server-closed connection. If you want to use connection pooling but want a safer value, I would recommend to set the client\u2019s setting one seconds lower than the server has. To set the idle time for the client the MaxConnectionIdleTime property can be used: HTTPManager.MaxConnectionIdleTime = TimeSpan.FromSeconds(4); Disable connection pooling: HTTPManager.KeepAliveDefaultValue = false;","title":"Connection Pooling"},{"location":"7.GlobalTopics/ConnectionPool/#connection-pooling","text":"This topic applies to connections for HTTP/1.1 requests only. HTTP/2 has proper messaging to communicate state changes between the client and server. Building up a TCP connection and negotiating TLS for HTTPS are slow that we can avoid if we reuse the connections for future requests. The plugin informs the server that it want to keep the connection alive for future use by sending a \" Connection: Keep-Alive \" header. While the server could inform the client by sending back a Keep-Alive header about how much time it\u2019s going to wait for a new request before get bored and closing the connection, servers are rarely use and send this Keep-Alive header. So, both the server and clients are blind to each other's setting and there\u2019s no other way other than the keep-alive header to let the other side know when the connection is going to be closed. In a case where the server closes an idle connection after 5 seconds and the client goes with its default 20 seconds, the client going to try to (re)use the connection way behind 5 seconds, resulting in a failed request. One option to fix it to set either the server\u2019s or the client\u2019s setting to the same as the other. Another one is to disable connection reuse completely (set HTTPManager.KeepAliveDefaultValue to false). While this is the safest way, and in some cases can be beneficial (for example when you know that you going to send out requests sparingly, outside of the idle time), it\u2019s better to try to keep the server and client setting in sync to reuse a TCP connection as much as possible. So, it worked because with the new setting, both the client and server closed the connection about the same time. Setting the client to the same value still can result in failed connections however, because the server starts to count down when it finished writing the response to the wire, and the client starts to count down when it finished receiving it. With a slow network (== high network latency), this can be large enough to increase the chance that the client is trying to use a server-closed connection. If you want to use connection pooling but want a safer value, I would recommend to set the client\u2019s setting one seconds lower than the server has. To set the idle time for the client the MaxConnectionIdleTime property can be used: HTTPManager.MaxConnectionIdleTime = TimeSpan.FromSeconds(4); Disable connection pooling: HTTPManager.KeepAliveDefaultValue = false;","title":"Connection Pooling"},{"location":"7.GlobalTopics/GlobalSettings/","text":"Global Settings With the following properties we can change some defaults that otherwise should be specified in the HTTPRequest's constructor. So most of these properties are time saving shortcuts, however, because higher level protocols use the HTTPRequest class too, these settings affect all protocols too. These changes will affect all request that created after their values changed. Changing the defaults can be made through the static properties of the HTTPManager class. Current settings are the following: MaxConnectionPerServer Number of TCP connections allowed to a unique host. http://example.org and https://example.org are counted as two separate servers. Its default value is 6 . HTTPManager.MaxConnectionPerServer = 10; Notice HTTP/2 uses one TCP connection, it has different setting for stream concurrency. KeepAliveDefaultValue The default value of the HTTPRequest's IsKeepAlive property. If IsKeepAlive is false , the tcp connections to the server will be set up before every request and closed right after it. It should be changed to false if consecutive requests are rare. Values given to the HTTPRequest's constructor will override this value for this request. Its default value is true . HTTPManager.KeepAliveDefaultValue = false; IsCachingDisabled With this property we can globally disable or enable the caching service. Values given to the HTTPRequest's constructor will override this value for this request. Its default value is false . HTTPManager.IsCachingDisabled = true; MaxConnectionIdleTime Specifies the idle time BestHTTP should wait before it destroys the connection after it's finished the last request. Its default value is 20 seconds. HTTPManager.MaxConnectionIdleTime = TimeSpan.FromSeconds(60); IsCookiesEnabled With this option all Cookie operation can be enabled or disabled. Its default value is true. HTTPManager.IsCookiesEnabled = false; CookieJarSize With this option the size of the Cookie store can be controlled. Its default value is 10485760 ( 10 MB ). HTTPManager.CookieJarSize = 1048576; EnablePrivateBrowsing If this option is enabled no Cookie will be written to the disk. Its default value is false. HTTPManager.EnablePrivateBrowsing = true; ConnectTimeout With this option you can set the HTTPRequests' default ConnectTimeout value. Its default value is 20 seconds. HTTPManager.ConnectTimeout = TimeSpan.FromSeconds(60); RequestTimeout With this option you can set the HTTPRequests' default Timeout value. Its default value is 60 seconds. HTTPManager.RequestTimeout = TimeSpan.FromSeconds(60); RootCacheFolderProvider By default the plugin will save all cache and cookie data under the path returned by Application.persistentDataPath . You can assign a function to this delegate to return a custom root path to define a new path. This delegate will be called on a non Unity thread! HTTPManager.RootCacheFolderProvider = () => Application.temporaryCachePath; Proxy The global, default proxy for all HTTPRequests. The HTTPRequest's Proxy still can be changed per-request. Default value is null . More information can be found about proxies in the Proxy topic. HTTPManager.Proxy = new HTTPProxy(new Uri(\"http://localhost:8888\"), null, true); Logger An ILogger implementation to be able to control what information will be logged about the plugin's internals, and how these will be logged. HTTPManager.Logger = new ThreadedLogger(); DefaultCertificateVerifyer An ICertificateVerifyer implementation can be set to this property. All new requests created after this will use this verifier when a secure protocol is used and the request's UseAlternateSSL is true . An ICertificateVerifyer implementation can be used to implement server certificate validation. HTTPManager.DefaultCertificateVerifyer = new AlwaysValidVerifyer(); UseAlternateSSLDefaultValue The default value of HTTPRequest's UseAlternateSSL can be changed through this property. Its default value is true . HTTPManager.UseAlternateSSLDefaultValue = false; HTTP2Settings Through this property, HTTP/2 related settings can be changed. See the HTTP/2 topic for more information . HTTPManager.HTTP2Settings.MaxConcurrentStreams = 256; IsQuitting It's true if the application is quitting and the plugin is shutting down itself. UserAgent User-agent string that will be sent with each requests. It's default value contains the version of the plugin ( \"BestHTTP/2 v2.2.1\" for example). HTTPManager.UserAgent = string.Empty;","title":"Global Settings"},{"location":"7.GlobalTopics/GlobalSettings/#global-settings","text":"With the following properties we can change some defaults that otherwise should be specified in the HTTPRequest's constructor. So most of these properties are time saving shortcuts, however, because higher level protocols use the HTTPRequest class too, these settings affect all protocols too. These changes will affect all request that created after their values changed. Changing the defaults can be made through the static properties of the HTTPManager class. Current settings are the following:","title":"Global Settings"},{"location":"7.GlobalTopics/GlobalSettings/#maxconnectionperserver","text":"Number of TCP connections allowed to a unique host. http://example.org and https://example.org are counted as two separate servers. Its default value is 6 . HTTPManager.MaxConnectionPerServer = 10; Notice HTTP/2 uses one TCP connection, it has different setting for stream concurrency.","title":"MaxConnectionPerServer"},{"location":"7.GlobalTopics/GlobalSettings/#keepalivedefaultvalue","text":"The default value of the HTTPRequest's IsKeepAlive property. If IsKeepAlive is false , the tcp connections to the server will be set up before every request and closed right after it. It should be changed to false if consecutive requests are rare. Values given to the HTTPRequest's constructor will override this value for this request. Its default value is true . HTTPManager.KeepAliveDefaultValue = false;","title":"KeepAliveDefaultValue"},{"location":"7.GlobalTopics/GlobalSettings/#iscachingdisabled","text":"With this property we can globally disable or enable the caching service. Values given to the HTTPRequest's constructor will override this value for this request. Its default value is false . HTTPManager.IsCachingDisabled = true;","title":"IsCachingDisabled"},{"location":"7.GlobalTopics/GlobalSettings/#maxconnectionidletime","text":"Specifies the idle time BestHTTP should wait before it destroys the connection after it's finished the last request. Its default value is 20 seconds. HTTPManager.MaxConnectionIdleTime = TimeSpan.FromSeconds(60);","title":"MaxConnectionIdleTime"},{"location":"7.GlobalTopics/GlobalSettings/#iscookiesenabled","text":"With this option all Cookie operation can be enabled or disabled. Its default value is true. HTTPManager.IsCookiesEnabled = false;","title":"IsCookiesEnabled"},{"location":"7.GlobalTopics/GlobalSettings/#cookiejarsize","text":"With this option the size of the Cookie store can be controlled. Its default value is 10485760 ( 10 MB ). HTTPManager.CookieJarSize = 1048576;","title":"CookieJarSize"},{"location":"7.GlobalTopics/GlobalSettings/#enableprivatebrowsing","text":"If this option is enabled no Cookie will be written to the disk. Its default value is false. HTTPManager.EnablePrivateBrowsing = true;","title":"EnablePrivateBrowsing"},{"location":"7.GlobalTopics/GlobalSettings/#connecttimeout","text":"With this option you can set the HTTPRequests' default ConnectTimeout value. Its default value is 20 seconds. HTTPManager.ConnectTimeout = TimeSpan.FromSeconds(60);","title":"ConnectTimeout"},{"location":"7.GlobalTopics/GlobalSettings/#requesttimeout","text":"With this option you can set the HTTPRequests' default Timeout value. Its default value is 60 seconds. HTTPManager.RequestTimeout = TimeSpan.FromSeconds(60);","title":"RequestTimeout"},{"location":"7.GlobalTopics/GlobalSettings/#rootcachefolderprovider","text":"By default the plugin will save all cache and cookie data under the path returned by Application.persistentDataPath . You can assign a function to this delegate to return a custom root path to define a new path. This delegate will be called on a non Unity thread! HTTPManager.RootCacheFolderProvider = () => Application.temporaryCachePath;","title":"RootCacheFolderProvider"},{"location":"7.GlobalTopics/GlobalSettings/#proxy","text":"The global, default proxy for all HTTPRequests. The HTTPRequest's Proxy still can be changed per-request. Default value is null . More information can be found about proxies in the Proxy topic. HTTPManager.Proxy = new HTTPProxy(new Uri(\"http://localhost:8888\"), null, true);","title":"Proxy"},{"location":"7.GlobalTopics/GlobalSettings/#logger","text":"An ILogger implementation to be able to control what information will be logged about the plugin's internals, and how these will be logged. HTTPManager.Logger = new ThreadedLogger();","title":"Logger"},{"location":"7.GlobalTopics/GlobalSettings/#defaultcertificateverifyer","text":"An ICertificateVerifyer implementation can be set to this property. All new requests created after this will use this verifier when a secure protocol is used and the request's UseAlternateSSL is true . An ICertificateVerifyer implementation can be used to implement server certificate validation. HTTPManager.DefaultCertificateVerifyer = new AlwaysValidVerifyer();","title":"DefaultCertificateVerifyer"},{"location":"7.GlobalTopics/GlobalSettings/#usealternatessldefaultvalue","text":"The default value of HTTPRequest's UseAlternateSSL can be changed through this property. Its default value is true . HTTPManager.UseAlternateSSLDefaultValue = false;","title":"UseAlternateSSLDefaultValue"},{"location":"7.GlobalTopics/GlobalSettings/#http2settings","text":"Through this property, HTTP/2 related settings can be changed. See the HTTP/2 topic for more information . HTTPManager.HTTP2Settings.MaxConcurrentStreams = 256;","title":"HTTP2Settings"},{"location":"7.GlobalTopics/GlobalSettings/#isquitting","text":"It's true if the application is quitting and the plugin is shutting down itself.","title":"IsQuitting"},{"location":"7.GlobalTopics/GlobalSettings/#useragent","text":"User-agent string that will be sent with each requests. It's default value contains the version of the plugin ( \"BestHTTP/2 v2.2.1\" for example). HTTPManager.UserAgent = string.Empty;","title":"UserAgent"},{"location":"7.GlobalTopics/HTTP2/","text":"HTTP/2 How it works BestHTTP implements HTTP/2 over TLS. Using the TLS negotiation and its ALPN extension the plugin let the server know that it's ready to upgrade to the HTTP/2 protocol. If the server has support for HTTP/2 and sends back the proper answer the plugin upgrades the connection and will communicate with the server using the HTTP/2 protocol. Using the TLS' ALPN extension upgrading to HTTP/2 is faster. However, when multiple requests are made to the same server and the plugin don't know whether the server capable to upgrade to HTTP/2, it will create only one connection to test against http/2. If the server reports no HTTP/2/2 support, the plugin will open new connections depending on the value of HTTPManager.MaxConnectionPerServer . if the server supports HTTP/2, the plugin will use that connection only. This mechanism prevents the plugin to open multiple connections that will be used only for one request. The plugin also stores what servers are supporting HTTP/2, so next time it can decide whether it should open multiple connections or not. Using HTTP/2 is seemless and requires no prior knowledge whether any target servers has support for it or not. The plugin hides differencies HTTP1.1 and HTTP/2 from the user, but will take advantage of the new protocol every time it has a chance. Notice With HTTP/2 the HTTPRequest 's IsKeepAlive setting is ignored. Settings As most of the global settings, HTTP/2 settings can be accessed through the HTTPManager class: using BestHTTP; HTTPManager.HTTP2Settings.InitialStreamWindowSize = 5 * 1024 * 1024; MaxConcurrentStreams Maximum concurrent http2 stream on http2 connection will allow. Its default value is 128; HTTPManager.HTTP2Settings.MaxConcurrentStreams = 256; InitialStreamWindowSize Initial window size of a http2 stream. Its default value is 10 MiB (10 * 1024 * 1024). HTTPManager.HTTP2Settings.InitialStreamWindowSize = 1 * 1024 * 1024; InitialConnectionWindowSize Global window size of a http/2 connection. Its default value is the maximum possible value on 31 bits. HTTPManager.HTTP2Settings.InitialConnectionWindowSize = HTTPManager.HTTP2Settings.MaxConcurrentStreams * 1024 * 1024; MaxFrameSize Maximum payload size of a http2 frame. Its default value is 16384. It must be between 16_384 and 16_777_215. HTTPManager.HTTP2Settings.MaxFrameSize = 1 * 1024 * 1024; MaxIdleTime With HTTP/2 only one connection will be open so we can can keep it open longer as we hope it will be resued more. Its default value is 120 seconds. HTTPManager.HTTP2Settings.MaxIdleTime = TimeSpan.FromSeconds(30); WebSocket Over HTTP/2 Settings Through these options the WebSocket Over HTTP/2 implementation can be customized. EnableWebSocketOverHTTP2 Set it to false to disable Websocket Over HTTP/2 (RFC 8441). It's true by default. HTTPManager.HTTP2Settings.WebSocketOverHTTP2Settings.EnableWebSocketOverHTTP2 = false; EnableImplementationFallback Set it to disable fallback logic from the Websocket Over HTTP/2 implementation to the 'old' HTTP/1 implementation when it fails to connect. HTTPManager.HTTP2Settings.WebSocketOverHTTP2Settings.EnableImplementationFallback = false;","title":"HTTP/2"},{"location":"7.GlobalTopics/HTTP2/#http2","text":"","title":"HTTP/2"},{"location":"7.GlobalTopics/HTTP2/#how-it-works","text":"BestHTTP implements HTTP/2 over TLS. Using the TLS negotiation and its ALPN extension the plugin let the server know that it's ready to upgrade to the HTTP/2 protocol. If the server has support for HTTP/2 and sends back the proper answer the plugin upgrades the connection and will communicate with the server using the HTTP/2 protocol. Using the TLS' ALPN extension upgrading to HTTP/2 is faster. However, when multiple requests are made to the same server and the plugin don't know whether the server capable to upgrade to HTTP/2, it will create only one connection to test against http/2. If the server reports no HTTP/2/2 support, the plugin will open new connections depending on the value of HTTPManager.MaxConnectionPerServer . if the server supports HTTP/2, the plugin will use that connection only. This mechanism prevents the plugin to open multiple connections that will be used only for one request. The plugin also stores what servers are supporting HTTP/2, so next time it can decide whether it should open multiple connections or not. Using HTTP/2 is seemless and requires no prior knowledge whether any target servers has support for it or not. The plugin hides differencies HTTP1.1 and HTTP/2 from the user, but will take advantage of the new protocol every time it has a chance. Notice With HTTP/2 the HTTPRequest 's IsKeepAlive setting is ignored.","title":"How it works"},{"location":"7.GlobalTopics/HTTP2/#settings","text":"As most of the global settings, HTTP/2 settings can be accessed through the HTTPManager class: using BestHTTP; HTTPManager.HTTP2Settings.InitialStreamWindowSize = 5 * 1024 * 1024;","title":"Settings"},{"location":"7.GlobalTopics/HTTP2/#maxconcurrentstreams","text":"Maximum concurrent http2 stream on http2 connection will allow. Its default value is 128; HTTPManager.HTTP2Settings.MaxConcurrentStreams = 256;","title":"MaxConcurrentStreams"},{"location":"7.GlobalTopics/HTTP2/#initialstreamwindowsize","text":"Initial window size of a http2 stream. Its default value is 10 MiB (10 * 1024 * 1024). HTTPManager.HTTP2Settings.InitialStreamWindowSize = 1 * 1024 * 1024;","title":"InitialStreamWindowSize"},{"location":"7.GlobalTopics/HTTP2/#initialconnectionwindowsize","text":"Global window size of a http/2 connection. Its default value is the maximum possible value on 31 bits. HTTPManager.HTTP2Settings.InitialConnectionWindowSize = HTTPManager.HTTP2Settings.MaxConcurrentStreams * 1024 * 1024;","title":"InitialConnectionWindowSize"},{"location":"7.GlobalTopics/HTTP2/#maxframesize","text":"Maximum payload size of a http2 frame. Its default value is 16384. It must be between 16_384 and 16_777_215. HTTPManager.HTTP2Settings.MaxFrameSize = 1 * 1024 * 1024;","title":"MaxFrameSize"},{"location":"7.GlobalTopics/HTTP2/#maxidletime","text":"With HTTP/2 only one connection will be open so we can can keep it open longer as we hope it will be resued more. Its default value is 120 seconds. HTTPManager.HTTP2Settings.MaxIdleTime = TimeSpan.FromSeconds(30);","title":"MaxIdleTime"},{"location":"7.GlobalTopics/HTTP2/#websocket-over-http2-settings","text":"Through these options the WebSocket Over HTTP/2 implementation can be customized.","title":"WebSocket Over HTTP/2 Settings"},{"location":"7.GlobalTopics/HTTP2/#enablewebsocketoverhttp2","text":"Set it to false to disable Websocket Over HTTP/2 (RFC 8441). It's true by default. HTTPManager.HTTP2Settings.WebSocketOverHTTP2Settings.EnableWebSocketOverHTTP2 = false;","title":"EnableWebSocketOverHTTP2"},{"location":"7.GlobalTopics/HTTP2/#enableimplementationfallback","text":"Set it to disable fallback logic from the Websocket Over HTTP/2 implementation to the 'old' HTTP/1 implementation when it fails to connect. HTTPManager.HTTP2Settings.WebSocketOverHTTP2Settings.EnableImplementationFallback = false;","title":"EnableImplementationFallback"},{"location":"7.GlobalTopics/HTTPS/","text":"HTTPS To support modern TLS/SSL version on as much platforms as the plugin just can, it comes bundled with Bouncy Castle . Bouncy Castle is the default TLS/SSL provider, and while it's a good replacement in general, sometime it can fail too for newer algorithms. Because of this, its usage can be disabled and the default SslStream implementation will be used instead. To disable the use of Bouncy Castle globally, the following line can be added somewhere in a startup code: BestHTTP.HTTPManager.UseAlternateSSLDefaultValue = false; HTTPRequest also has an UseAlternateSSL property, but because of connection pooling, the first request's value determines what TLS/SSL handler will be used. Notice HTTP/2 (because it depends on TLS' ALPN feature) and Server Name Indication works only with Bouncy Castle. Other HTTPS related topcis are Server Certificate Validation and Hostname verification . How to debug HTTPS requests The plugin doesn't verify server certificate so it's easy to set up a proxy and route the intersting requests through it. Charles Proxy is one of the easiest proxy to set up and use. The plugin also supports the NSS Key Log Format . In the editor when the SSLKEYLOGFILE environment variable is present, the plugin will write the client random of the SSL session to the file. 3rd party programs like Wireshark can use this file to decrypt packets sent by the plugin. Certication Verification The plugin by default doesn't do any certication verification, accepts all -including self signed- certificates. To add a global verifier HTTPManager.DefaultCertificateVerifyer can be used: using System; using BestHTTP.SecureProtocol.Org.BouncyCastle.Crypto.Tls; using BestHTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509; class CustomVerifier : ICertificateVerifyer { public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) { // TODO: Return false, if validation fails return true; } } HTTPManager.DefaultCertificateVerifyer = new CustomVerifier(); This implementation is the same as the one that the plugin uses by default: returns true for all https connection.","title":"HTTPS"},{"location":"7.GlobalTopics/HTTPS/#https","text":"To support modern TLS/SSL version on as much platforms as the plugin just can, it comes bundled with Bouncy Castle . Bouncy Castle is the default TLS/SSL provider, and while it's a good replacement in general, sometime it can fail too for newer algorithms. Because of this, its usage can be disabled and the default SslStream implementation will be used instead. To disable the use of Bouncy Castle globally, the following line can be added somewhere in a startup code: BestHTTP.HTTPManager.UseAlternateSSLDefaultValue = false; HTTPRequest also has an UseAlternateSSL property, but because of connection pooling, the first request's value determines what TLS/SSL handler will be used. Notice HTTP/2 (because it depends on TLS' ALPN feature) and Server Name Indication works only with Bouncy Castle. Other HTTPS related topcis are Server Certificate Validation and Hostname verification .","title":"HTTPS"},{"location":"7.GlobalTopics/HTTPS/#how-to-debug-https-requests","text":"The plugin doesn't verify server certificate so it's easy to set up a proxy and route the intersting requests through it. Charles Proxy is one of the easiest proxy to set up and use. The plugin also supports the NSS Key Log Format . In the editor when the SSLKEYLOGFILE environment variable is present, the plugin will write the client random of the SSL session to the file. 3rd party programs like Wireshark can use this file to decrypt packets sent by the plugin.","title":"How to debug HTTPS requests"},{"location":"7.GlobalTopics/HTTPS/#certication-verification","text":"The plugin by default doesn't do any certication verification, accepts all -including self signed- certificates. To add a global verifier HTTPManager.DefaultCertificateVerifyer can be used: using System; using BestHTTP.SecureProtocol.Org.BouncyCastle.Crypto.Tls; using BestHTTP.SecureProtocol.Org.BouncyCastle.Asn1.X509; class CustomVerifier : ICertificateVerifyer { public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) { // TODO: Return false, if validation fails return true; } } HTTPManager.DefaultCertificateVerifyer = new CustomVerifier(); This implementation is the same as the one that the plugin uses by default: returns true for all https connection.","title":"Certication Verification"},{"location":"7.GlobalTopics/HowToDisableFeatures/","text":"How to disable features There are many defines that can be used to disable various features. These defines can be combined, even all can be set. Disabled features will not compile, so build size can be reduced by disabling unused features. Check the Unity manual how you can set these defines: http://docs.unity3d.com/Manual/PlatformDependentCompilation.html Available defines These are the defines that has an effect on the plugin: BESTHTTP_DISABLE_COOKIES : With this define all cookie related code can be disabled. No cookie parsing, saving and sending will occur. BESTHTTP_DISABLE_COOKIE_SAVE : With this define cookies remain enabled, only persisting them going to be disabled. BESTHTTP_DISABLE_CACHING : With this define all cache related code can be disabled. No caching, or cache validation will be done. BESTHTTP_DISABLE_SERVERSENT_EVENTS : Server-Sent Events can be disabled with this. SignalR will not fallback to this. BESTHTTP_DISABLE_WEBSOCKET : Websocket can be disabled with this. SignalR and Socket.IO will not use this protocol. BESTHTTP_DISABLE_SIGNALR : The entire SignalR implementation will be disabled. BESTHTTP_DISABLE_SIGNALR_CORE : The SignalR Core implementation will be disabled. BESTHTTP_DISABLE_SOCKETIO : The entire Socket.IO implementation will be disabled. BESTHTTP_DISABLE_ALTERNATE_SSL : If you are not using HTTPS(or WSS for WebSocket) and HTTP/2, you can disable the alternate ssl handler. BESTHTTP_DISABLE_GZIP : If set, the plugin going to ask for non-compressed data from the server. BESTHTTP_DISABLE_HTTP2 : To disable the HTTP/2 protocol. Protocol related defines SignalR Core BESTHTTP_SIGNALR_CORE_ENABLE_GAMEDEVWARE_MESSAGEPACK BESTHTTP_SIGNALR_CORE_ENABLE_NEWTONSOFT_JSON_DOTNET_ENCODER More can be read about these under the SignalR Core Encoders topic. Socket.IO 3 BESTHTTP_SOCKETIO_ENABLE_GAMEDEVWARE_MESSAGEPACK More can be read about these under the Socket.IO 3 Parsers topic.","title":"How to disable features"},{"location":"7.GlobalTopics/HowToDisableFeatures/#how-to-disable-features","text":"There are many defines that can be used to disable various features. These defines can be combined, even all can be set. Disabled features will not compile, so build size can be reduced by disabling unused features. Check the Unity manual how you can set these defines: http://docs.unity3d.com/Manual/PlatformDependentCompilation.html","title":"How to disable features"},{"location":"7.GlobalTopics/HowToDisableFeatures/#available-defines","text":"These are the defines that has an effect on the plugin: BESTHTTP_DISABLE_COOKIES : With this define all cookie related code can be disabled. No cookie parsing, saving and sending will occur. BESTHTTP_DISABLE_COOKIE_SAVE : With this define cookies remain enabled, only persisting them going to be disabled. BESTHTTP_DISABLE_CACHING : With this define all cache related code can be disabled. No caching, or cache validation will be done. BESTHTTP_DISABLE_SERVERSENT_EVENTS : Server-Sent Events can be disabled with this. SignalR will not fallback to this. BESTHTTP_DISABLE_WEBSOCKET : Websocket can be disabled with this. SignalR and Socket.IO will not use this protocol. BESTHTTP_DISABLE_SIGNALR : The entire SignalR implementation will be disabled. BESTHTTP_DISABLE_SIGNALR_CORE : The SignalR Core implementation will be disabled. BESTHTTP_DISABLE_SOCKETIO : The entire Socket.IO implementation will be disabled. BESTHTTP_DISABLE_ALTERNATE_SSL : If you are not using HTTPS(or WSS for WebSocket) and HTTP/2, you can disable the alternate ssl handler. BESTHTTP_DISABLE_GZIP : If set, the plugin going to ask for non-compressed data from the server. BESTHTTP_DISABLE_HTTP2 : To disable the HTTP/2 protocol.","title":"Available defines"},{"location":"7.GlobalTopics/HowToDisableFeatures/#protocol-related-defines","text":"SignalR Core BESTHTTP_SIGNALR_CORE_ENABLE_GAMEDEVWARE_MESSAGEPACK BESTHTTP_SIGNALR_CORE_ENABLE_NEWTONSOFT_JSON_DOTNET_ENCODER More can be read about these under the SignalR Core Encoders topic. Socket.IO 3 BESTHTTP_SOCKETIO_ENABLE_GAMEDEVWARE_MESSAGEPACK More can be read about these under the Socket.IO 3 Parsers topic.","title":"Protocol related defines"},{"location":"7.GlobalTopics/Logging/","text":"Logging To be able to dump out some important information about the plugin, it has its own logging mechanism. The default logger can be accessed through the HTTPManager.Logger property. The default loglevel is Warning for debug builds and Error for others. This implementation uses Unity\u2019s Debug.Log / LogWarning / LogError functions. A new logger can be written by implementing the ILogger interface from the BestHTTP.Logger namespace. The plugin, to minimise latency added by logging, uses a new threaded logger. As its name suggests, the actual logging happens on a separate thread. Changing verbosity It can be done by setting the logger's LogLevel: using BestHTTP; HTTPManager.Logger.Level = Logger.Loglevels.All; Setting the log level to Loglevels.All can be handful when you tring to find bugs or want to send over for inspection. Unity log file locations are listed here: LogFiles . ILogOutput and the default UnityOutput implementation All ILogger implementation has an Output field so writing logs to a file instead of the Unity Console requires a new output instead of a new ILogger implementation. The ILogOutput interface is very slim: public interface ILogOutput : IDisposable { void Write(Loglevels level, string logEntry); } And the default implementation is small too: using System; namespace BestHTTP.Logger { public sealed class UnityOutput : ILogOutput { public void Write(Loglevels level, string logEntry) { switch (level) { case Loglevels.All: case Loglevels.Information: UnityEngine.Debug.Log(logEntry); break; case Loglevels.Warning: UnityEngine.Debug.LogWarning(logEntry); break; case Loglevels.Error: case Loglevels.Exception: UnityEngine.Debug.LogError(logEntry); break; } } public void Dispose() { GC.SuppressFinalize(this); } } } Logging into a file In this case, there's no need to make different cases based on the level of the log entries, so Write only going to convert the string into a byte[] and tries to write it to the stream: using System; using BestHTTP.Extensions; using BestHTTP.PlatformSupport.Memory; namespace BestHTTP.Logger { public sealed class FileOutput : ILogOutput { private System.IO.Stream fileStream; public FileOutput(string fileName) { this.fileStream = HTTPManager.IOService.CreateFileStream(fileName, PlatformSupport.FileSystem.FileStreamModes.Create); } public void Write(Loglevels level, string logEntry) { if (this.fileStream != null && !string.IsNullOrEmpty(logEntry)) { int count = System.Text.Encoding.UTF8.GetByteCount(logEntry); var buffer = BufferPool.Get(count, true); try { System.Text.Encoding.UTF8.GetBytes(logEntry, 0, logEntry.Length, buffer, 0); this.fileStream.Write(buffer, 0, count); this.fileStream.WriteLine(); } finally { BufferPool.Release(buffer); } this.fileStream.Flush(); } } public void Dispose() { if (this.fileStream != null) { this.fileStream.Close(); this.fileStream = null; } GC.SuppressFinalize(this); } } } And setting the new output for the logger can be done like this: HTTPManager.Logger.Output = new FileOutput(\"besthttp.log\"); LoggingContext To help indentify and track protocols, they have a LoggingContext instance that gets passed to the logger. Because a high level protocol usually uses other protocol(s), the hight level protocol adds own logging context to the lower one and going to get logged too.","title":"Logging"},{"location":"7.GlobalTopics/Logging/#logging","text":"To be able to dump out some important information about the plugin, it has its own logging mechanism. The default logger can be accessed through the HTTPManager.Logger property. The default loglevel is Warning for debug builds and Error for others. This implementation uses Unity\u2019s Debug.Log / LogWarning / LogError functions. A new logger can be written by implementing the ILogger interface from the BestHTTP.Logger namespace. The plugin, to minimise latency added by logging, uses a new threaded logger. As its name suggests, the actual logging happens on a separate thread.","title":"Logging"},{"location":"7.GlobalTopics/Logging/#changing-verbosity","text":"It can be done by setting the logger's LogLevel: using BestHTTP; HTTPManager.Logger.Level = Logger.Loglevels.All; Setting the log level to Loglevels.All can be handful when you tring to find bugs or want to send over for inspection. Unity log file locations are listed here: LogFiles .","title":"Changing verbosity"},{"location":"7.GlobalTopics/Logging/#ilogoutput-and-the-default-unityoutput-implementation","text":"All ILogger implementation has an Output field so writing logs to a file instead of the Unity Console requires a new output instead of a new ILogger implementation. The ILogOutput interface is very slim: public interface ILogOutput : IDisposable { void Write(Loglevels level, string logEntry); } And the default implementation is small too: using System; namespace BestHTTP.Logger { public sealed class UnityOutput : ILogOutput { public void Write(Loglevels level, string logEntry) { switch (level) { case Loglevels.All: case Loglevels.Information: UnityEngine.Debug.Log(logEntry); break; case Loglevels.Warning: UnityEngine.Debug.LogWarning(logEntry); break; case Loglevels.Error: case Loglevels.Exception: UnityEngine.Debug.LogError(logEntry); break; } } public void Dispose() { GC.SuppressFinalize(this); } } }","title":"ILogOutput and the default UnityOutput implementation"},{"location":"7.GlobalTopics/Logging/#logging-into-a-file","text":"In this case, there's no need to make different cases based on the level of the log entries, so Write only going to convert the string into a byte[] and tries to write it to the stream: using System; using BestHTTP.Extensions; using BestHTTP.PlatformSupport.Memory; namespace BestHTTP.Logger { public sealed class FileOutput : ILogOutput { private System.IO.Stream fileStream; public FileOutput(string fileName) { this.fileStream = HTTPManager.IOService.CreateFileStream(fileName, PlatformSupport.FileSystem.FileStreamModes.Create); } public void Write(Loglevels level, string logEntry) { if (this.fileStream != null && !string.IsNullOrEmpty(logEntry)) { int count = System.Text.Encoding.UTF8.GetByteCount(logEntry); var buffer = BufferPool.Get(count, true); try { System.Text.Encoding.UTF8.GetBytes(logEntry, 0, logEntry.Length, buffer, 0); this.fileStream.Write(buffer, 0, count); this.fileStream.WriteLine(); } finally { BufferPool.Release(buffer); } this.fileStream.Flush(); } } public void Dispose() { if (this.fileStream != null) { this.fileStream.Close(); this.fileStream = null; } GC.SuppressFinalize(this); } } } And setting the new output for the logger can be done like this: HTTPManager.Logger.Output = new FileOutput(\"besthttp.log\");","title":"Logging into a file"},{"location":"7.GlobalTopics/Logging/#loggingcontext","text":"To help indentify and track protocols, they have a LoggingContext instance that gets passed to the logger. Because a high level protocol usually uses other protocol(s), the hight level protocol adds own logging context to the lower one and going to get logged too.","title":"LoggingContext"},{"location":"7.GlobalTopics/Proxy/","text":"Proxies There are two types of proxies the plugin supports: HTTP ( HTTPProxy ) and SOCKS ( SOCKSProxy ). A proxy object can be set to a HTTPRequest\u2019s Proxy property. This way the request will be go through the given proxy. // HTTP Proxy: request.Proxy = new HTTPProxy(new Uri(\"http://localhost:3128\")); // SOCKS Proxy: request.Proxy = new SOCKSProxy(new System.Uri(\"socks://localhost:3129\"), /*credentials: */ null); You can set a global proxy too, so you don\u2019t have to set it to all request manually or to drive higher level protocols through it: // Global HTTP Proxy: HTTPManager.Proxy = new HTTPProxy(new Uri(\"http://localhost:3128\")); // Global SOCKS Proxy: HTTPManager.Proxy = new SOCKSProxy(new System.Uri(\"socks://localhost:3129\"), /*credentials: */ null); See the Global Settings chapter for more settings. HTTPProxy The HTTPProxy implementation supports proxy authentication, explicit, transparent and non-transparent proxies. It supports sending the whole URL to the proxy because some non-transparent proxies expecting it. SOCKSProxy Supports only the username/password authentication. Add Exceptions To do not route one or more requests through a globally set proxy the proxy's Exceptions list can be used: HTTPManager.Proxy = new HTTPProxy(new Uri(\"http://localhost:8888\"), null, true); // Add exceptions HTTPManager.Proxy.Exceptions = new List<string>(); HTTPManager.Proxy.Exceptions.Add(\"httpbin\"); // This request not going through the proxy var request = new HTTPRequest(new Uri(\"https://httpbin.org\")); request.Send(); Any request that's CurrentUri .Host's beginning matches a string from the proxy's Exceptions will not going trhough the proxy.","title":"Proxies"},{"location":"7.GlobalTopics/Proxy/#proxies","text":"There are two types of proxies the plugin supports: HTTP ( HTTPProxy ) and SOCKS ( SOCKSProxy ). A proxy object can be set to a HTTPRequest\u2019s Proxy property. This way the request will be go through the given proxy. // HTTP Proxy: request.Proxy = new HTTPProxy(new Uri(\"http://localhost:3128\")); // SOCKS Proxy: request.Proxy = new SOCKSProxy(new System.Uri(\"socks://localhost:3129\"), /*credentials: */ null); You can set a global proxy too, so you don\u2019t have to set it to all request manually or to drive higher level protocols through it: // Global HTTP Proxy: HTTPManager.Proxy = new HTTPProxy(new Uri(\"http://localhost:3128\")); // Global SOCKS Proxy: HTTPManager.Proxy = new SOCKSProxy(new System.Uri(\"socks://localhost:3129\"), /*credentials: */ null); See the Global Settings chapter for more settings.","title":"Proxies"},{"location":"7.GlobalTopics/Proxy/#httpproxy","text":"The HTTPProxy implementation supports proxy authentication, explicit, transparent and non-transparent proxies. It supports sending the whole URL to the proxy because some non-transparent proxies expecting it.","title":"HTTPProxy"},{"location":"7.GlobalTopics/Proxy/#socksproxy","text":"Supports only the username/password authentication.","title":"SOCKSProxy"},{"location":"7.GlobalTopics/Proxy/#add-exceptions","text":"To do not route one or more requests through a globally set proxy the proxy's Exceptions list can be used: HTTPManager.Proxy = new HTTPProxy(new Uri(\"http://localhost:8888\"), null, true); // Add exceptions HTTPManager.Proxy.Exceptions = new List<string>(); HTTPManager.Proxy.Exceptions.Add(\"httpbin\"); // This request not going through the proxy var request = new HTTPRequest(new Uri(\"https://httpbin.org\")); request.Send(); Any request that's CurrentUri .Host's beginning matches a string from the proxy's Exceptions will not going trhough the proxy.","title":"Add Exceptions"},{"location":"7.GlobalTopics/ThreadSafety/","text":"Thread Safety Because the plugin internally uses threads to process all requests parallelly, all shared resources(cache, cookies, etc) are designed and implemented with thread safety in mind. By deafult, calling the requests\u2019 callback functions, and all other callbacks (like the WebSocket\u2019s callbacks) are made on Unity\u2019s main thread(like Unity\u2019s events: awake, start, update, etc) so you don\u2019t have to do any thread synchronization. Creating, sending requests on more than one thread are safe too, but you should call the BestHTTP.HTTPManager.Setup() ; function before sending any request from one of Unity\u2019s events (eg. awake, start).","title":"ThreadSafety"},{"location":"7.GlobalTopics/ThreadSafety/#thread-safety","text":"Because the plugin internally uses threads to process all requests parallelly, all shared resources(cache, cookies, etc) are designed and implemented with thread safety in mind. By deafult, calling the requests\u2019 callback functions, and all other callbacks (like the WebSocket\u2019s callbacks) are made on Unity\u2019s main thread(like Unity\u2019s events: awake, start, update, etc) so you don\u2019t have to do any thread synchronization. Creating, sending requests on more than one thread are safe too, but you should call the BestHTTP.HTTPManager.Setup() ; function before sending any request from one of Unity\u2019s events (eg. awake, start).","title":"Thread Safety"},{"location":"8.Addons/TLSSecurity/","text":"About Implementing a good certification validation isn't an easy task, but this addon aims even higher. It implements the same steps a browser does to ensure the communication over the negotiated connection is safe and secure. Additionally, provides a management window to easily manage trusted certificates, update and test them. This addon implements all certification verification steps a browser normally do and additionally provides a management window to easily manage trusted certificates, update and test them. Take a step further to improve the security of all protocols connecting through a TLS connection with a one line setup. Works with all protocols Best HTTP/2 supports. All source code included. Requires the latest version of Best HTTP/2 . Link to the addon's store page: https://assetstore.unity.com/packages/tools/network/best-http-2-tls-security-addon-184441 . Features Certificate Chain Verification as described in RFC 3280 Revocation checking of leaf certificates using OCSP with optional soft and hard fail Caching OCSP responses Support for OCSP Must-Staple Trusted Root CA, Trusted Intermediate and Client Credentials management through an easy to use Certification Manager Window to Update all certificates from a trusted source Add custom certificates Delete non-needed certificates Domain Name Matching Client Authentication Wide variety of options to configure almost every bits of the addon Setup Guide This addon doesn't require any installation steps, but it's recommended to import after the Best HTTP/2 package. After importing the package just must call one function on application startup: #if !UNITY_WEBGL || UNITY_EDITOR using BestHTTP.Addons.TLSSecurity; TLSSecurity.Setup(); #endif Calling TLSSecurity.Setup() going to set up the addon and installs itself as sets its TlsClient factory as the default one. One part of the setup phase is to load the databases into memory and write it to the application's persistent data path (with default settings) and unload the resource. This step needed as the databases going to open those files and read into memory only the required chunks. While it has some disk overhead, more complexity and can work on platforms and devices where it can create and write into a new file, it greatly reduces runtime memory requirements. This step also done only once, when the files are there no resources going to be loaded and written. To make updating certification databases possible, a hash file is generated and compared in the Setup call, so even if the files are there but the hashes are different a new file going to be written. Notice Under WebGL BestHTTP/2 must use the underlying browser's XmlHTTPRequest implementation, all tls verification is done by the browser. How To Detect TLS Certification Verification Failures If certification verification fails, the connection going to be terminated the HTTPReqest's State going to be HTTPRequestStates.Error. The request's Exception property is a reference to an exception containing more information about the issue: void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { switch (req.State) { // The request finished without any problem. case HTTPRequestStates.Finished: if (resp.IsSuccess) { Debug.Log(\"Done!\"); } else { Debug.LogWarning(string.Format(\"Request finished Successfully, but the server sent an error. Status Code: {0}-{1} Message: {2}\", resp.StatusCode, resp.Message, resp.DataAsText)); } break; // The request finished with an unexpected error. The request's Exception property may contain more info about the error. case HTTPRequestStates.Error: Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); TlsFatalAlert tlsException = req.Exception as TlsFatalAlert; if (tlsException != null) { Debug.LogException(tlsException); } break; // The request aborted, initiated by the user. case HTTPRequestStates.Aborted: Debug.LogWarning(\"Request Aborted!\"); break; // Connecting to the server is timed out. case HTTPRequestStates.ConnectionTimedOut: Debug.LogError(\"Connection Timed Out!\"); break; // The request didn't finished in the given time. case HTTPRequestStates.TimedOut: Debug.LogError(\"Processing the request Timed Out!\"); break; } } For a failed TLS verification, it should produce two log lines, something like this:","title":"About"},{"location":"8.Addons/TLSSecurity/#about","text":"Implementing a good certification validation isn't an easy task, but this addon aims even higher. It implements the same steps a browser does to ensure the communication over the negotiated connection is safe and secure. Additionally, provides a management window to easily manage trusted certificates, update and test them. This addon implements all certification verification steps a browser normally do and additionally provides a management window to easily manage trusted certificates, update and test them. Take a step further to improve the security of all protocols connecting through a TLS connection with a one line setup. Works with all protocols Best HTTP/2 supports. All source code included. Requires the latest version of Best HTTP/2 . Link to the addon's store page: https://assetstore.unity.com/packages/tools/network/best-http-2-tls-security-addon-184441 .","title":"About"},{"location":"8.Addons/TLSSecurity/#features","text":"Certificate Chain Verification as described in RFC 3280 Revocation checking of leaf certificates using OCSP with optional soft and hard fail Caching OCSP responses Support for OCSP Must-Staple Trusted Root CA, Trusted Intermediate and Client Credentials management through an easy to use Certification Manager Window to Update all certificates from a trusted source Add custom certificates Delete non-needed certificates Domain Name Matching Client Authentication Wide variety of options to configure almost every bits of the addon","title":"Features"},{"location":"8.Addons/TLSSecurity/#setup-guide","text":"This addon doesn't require any installation steps, but it's recommended to import after the Best HTTP/2 package. After importing the package just must call one function on application startup: #if !UNITY_WEBGL || UNITY_EDITOR using BestHTTP.Addons.TLSSecurity; TLSSecurity.Setup(); #endif Calling TLSSecurity.Setup() going to set up the addon and installs itself as sets its TlsClient factory as the default one. One part of the setup phase is to load the databases into memory and write it to the application's persistent data path (with default settings) and unload the resource. This step needed as the databases going to open those files and read into memory only the required chunks. While it has some disk overhead, more complexity and can work on platforms and devices where it can create and write into a new file, it greatly reduces runtime memory requirements. This step also done only once, when the files are there no resources going to be loaded and written. To make updating certification databases possible, a hash file is generated and compared in the Setup call, so even if the files are there but the hashes are different a new file going to be written. Notice Under WebGL BestHTTP/2 must use the underlying browser's XmlHTTPRequest implementation, all tls verification is done by the browser.","title":"Setup Guide"},{"location":"8.Addons/TLSSecurity/#how-to-detect-tls-certification-verification-failures","text":"If certification verification fails, the connection going to be terminated the HTTPReqest's State going to be HTTPRequestStates.Error. The request's Exception property is a reference to an exception containing more information about the issue: void OnRequestFinished(HTTPRequest req, HTTPResponse resp) { switch (req.State) { // The request finished without any problem. case HTTPRequestStates.Finished: if (resp.IsSuccess) { Debug.Log(\"Done!\"); } else { Debug.LogWarning(string.Format(\"Request finished Successfully, but the server sent an error. Status Code: {0}-{1} Message: {2}\", resp.StatusCode, resp.Message, resp.DataAsText)); } break; // The request finished with an unexpected error. The request's Exception property may contain more info about the error. case HTTPRequestStates.Error: Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); TlsFatalAlert tlsException = req.Exception as TlsFatalAlert; if (tlsException != null) { Debug.LogException(tlsException); } break; // The request aborted, initiated by the user. case HTTPRequestStates.Aborted: Debug.LogWarning(\"Request Aborted!\"); break; // Connecting to the server is timed out. case HTTPRequestStates.ConnectionTimedOut: Debug.LogError(\"Connection Timed Out!\"); break; // The request didn't finished in the given time. case HTTPRequestStates.TimedOut: Debug.LogError(\"Processing the request Timed Out!\"); break; } } For a failed TLS verification, it should produce two log lines, something like this:","title":"How To Detect TLS Certification Verification Failures"},{"location":"8.Addons/TLSSecurity/CertificationManagerWindow/","text":"Certification Manager Window The Window/Best HTTP/Addons/TLS Security/Certification Window menu item (or CTRL+ALT+E shortcut) opens the addon's Certification Manager. Using this window certificates can be added, updated and deleted. 1 2 3 4 5 Trusted Root CAs These are the basis of the trust chain, servers doesn't send root certificates the client must include the roots certificates of the accessed endpoints. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Reset URL : Reset the URL input back to its addon supplied url. URL Input : The URL that the addon going to download the certifications. The addon expects CSV formatted data, but the URL can point to a local file using the file:// protocol. The default URLs are pointing to Mozilla repositories. Download : Clicking on this button start the downloading, content parsing and loading process. Downloading the certificates already uses all verification implemented in the addon. Clear Before Download : Check to remove all non-locked and non-user added (if Keep Custom is checked) certificates before download. Clear : Remove all non-locked and non-user added (if Keep Custom is checked) certificates. Keep Custom : If set Clear buttons doesn't remove user added certificates. Add Custom : Add certificates from .cer, .pem and .p7b files. Delete Selected : Delete selected certificates. Locked certificates can't be deleted! Search Input : It can be used to search certificates by their Subject name. Minimum 3 characters needed. Help (?) Button : Opens a browser window to this manual. # Column : Index of the certificate. User Column : It has a \u2714, if it's a user-added certificate. Lock Column : It has a \u2714, if it's locked and can't be deleted. Currently only certificates needed to update from the default URL are locked. Subject Column : Subject field of the certificate. Issuer Column : Issuer field of the certificate. Certifications : Number of certifications displayed. Certificate Size Stats : Min, max, sum and average size of certificate data in bytes. This can help adjusting cache sizes. Status : Status of the last operation. Notice Double clicking on a row or hitting Enter while at least one row is selected dumps out certification information to the console. Trusted Intermediate Certificates Because servers can choose to not send intermediate certificates it's a good practice to bundle them too. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Reset URL : Reset the URL input back to its addon supplied url. URL Input : The URL that the addon going to download the certifications. The addon expects CSV formatted data, but the URL can point to a local file using the file:// protocol. The default URLs are pointing to Mozilla repositories. Download : Clicking on this button start the downloading, content parsing and loading process. Downloading the certificates already uses all verification implemented in the addon. Clear Before Download : Check to remove all non-locked and non-user added (if Keep Custom is checked) certificates before download. Clear : Remove all non-locked and non-user added (if Keep Custom is checked) certificates. Keep Custom : If set Clear buttons doesn't remove user added certificates. Add Custom : Add certificates from .cer, .pem and .p7b files. Delete Selected : Delete selected certificates. Locked certificates can't be deleted! Search Input : It can be used to search certificates by their Subject name. Minimum 3 characters needed. Help (?) Button : Opens a browser window to this manual. # Column : Index of the certificate. User Column : It has a \u2714, if it's a user-added certificate. Lock Column : It has a \u2714, if it's locked and can't be deleted. Currently only certificates needed to update from the default URL are locked. Subject Column : Subject field of the certificate. Issuer Column : Issuer field of the certificate. Certifications : Number of certifications displayed. Certificate Size Stats : Min, max, sum and average size of certificate data in bytes. This can help adjusting cache sizes. Status : Status of the last operation. Notice Double clicking on a row or hitting Enter while at least one row is selected dumps out certification information to the console. Client Certificates A client certificate can be associated with a domain. If the server asks for a client certificate during the TLS handshake, the client going to send it back. 1 2 3 4 5 6 7 8 Add for domain : Clicking on it a Domain and File Selector window is shown. If the domain is filled and the certification file is selected clicking on the Ok button going to add the certification for the domain. Delete Selected : Delete selected domain-certificate associations. Help (?) Button : Opens a browser window to this manual. # Column : Index of the certificate Target Domain Column : The certificate sent only if it's requested for the target domain. Authority Column : Common Name or Organizational Unit Name from the certificate's Issuer field. Certifications : Number of certifications displayed. Certificate Size Stats : Min, max, sum and average size of certificate data in bytes. This can help adjusting cache sizes. Clicking on the Add for domain button a new window opens to select the certification file and domain: Then, clicking on the Ok button depending on the type of certificate file a window to input the file's password might open: Testing HTTP Requests A basic GET request can be sent out for the given domain to test the current setup. 1 2 3 Input field for the domain to test Send button Result of the request Warning Because of Connection Pooling a request that otherwise would fail can succeed if there's an already open connection to the domain! Bottom Toolbar 1 2 Name and version number of this addon Support e-mail","title":"CertificationManagerWindow"},{"location":"8.Addons/TLSSecurity/CertificationManagerWindow/#certification-manager-window","text":"The Window/Best HTTP/Addons/TLS Security/Certification Window menu item (or CTRL+ALT+E shortcut) opens the addon's Certification Manager. Using this window certificates can be added, updated and deleted. 1 2 3 4 5","title":"Certification Manager Window"},{"location":"8.Addons/TLSSecurity/CertificationManagerWindow/#trusted-root-cas","text":"These are the basis of the trust chain, servers doesn't send root certificates the client must include the roots certificates of the accessed endpoints. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Reset URL : Reset the URL input back to its addon supplied url. URL Input : The URL that the addon going to download the certifications. The addon expects CSV formatted data, but the URL can point to a local file using the file:// protocol. The default URLs are pointing to Mozilla repositories. Download : Clicking on this button start the downloading, content parsing and loading process. Downloading the certificates already uses all verification implemented in the addon. Clear Before Download : Check to remove all non-locked and non-user added (if Keep Custom is checked) certificates before download. Clear : Remove all non-locked and non-user added (if Keep Custom is checked) certificates. Keep Custom : If set Clear buttons doesn't remove user added certificates. Add Custom : Add certificates from .cer, .pem and .p7b files. Delete Selected : Delete selected certificates. Locked certificates can't be deleted! Search Input : It can be used to search certificates by their Subject name. Minimum 3 characters needed. Help (?) Button : Opens a browser window to this manual. # Column : Index of the certificate. User Column : It has a \u2714, if it's a user-added certificate. Lock Column : It has a \u2714, if it's locked and can't be deleted. Currently only certificates needed to update from the default URL are locked. Subject Column : Subject field of the certificate. Issuer Column : Issuer field of the certificate. Certifications : Number of certifications displayed. Certificate Size Stats : Min, max, sum and average size of certificate data in bytes. This can help adjusting cache sizes. Status : Status of the last operation. Notice Double clicking on a row or hitting Enter while at least one row is selected dumps out certification information to the console.","title":"Trusted Root CAs"},{"location":"8.Addons/TLSSecurity/CertificationManagerWindow/#trusted-intermediate-certificates","text":"Because servers can choose to not send intermediate certificates it's a good practice to bundle them too. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Reset URL : Reset the URL input back to its addon supplied url. URL Input : The URL that the addon going to download the certifications. The addon expects CSV formatted data, but the URL can point to a local file using the file:// protocol. The default URLs are pointing to Mozilla repositories. Download : Clicking on this button start the downloading, content parsing and loading process. Downloading the certificates already uses all verification implemented in the addon. Clear Before Download : Check to remove all non-locked and non-user added (if Keep Custom is checked) certificates before download. Clear : Remove all non-locked and non-user added (if Keep Custom is checked) certificates. Keep Custom : If set Clear buttons doesn't remove user added certificates. Add Custom : Add certificates from .cer, .pem and .p7b files. Delete Selected : Delete selected certificates. Locked certificates can't be deleted! Search Input : It can be used to search certificates by their Subject name. Minimum 3 characters needed. Help (?) Button : Opens a browser window to this manual. # Column : Index of the certificate. User Column : It has a \u2714, if it's a user-added certificate. Lock Column : It has a \u2714, if it's locked and can't be deleted. Currently only certificates needed to update from the default URL are locked. Subject Column : Subject field of the certificate. Issuer Column : Issuer field of the certificate. Certifications : Number of certifications displayed. Certificate Size Stats : Min, max, sum and average size of certificate data in bytes. This can help adjusting cache sizes. Status : Status of the last operation. Notice Double clicking on a row or hitting Enter while at least one row is selected dumps out certification information to the console.","title":"Trusted Intermediate Certificates"},{"location":"8.Addons/TLSSecurity/CertificationManagerWindow/#client-certificates","text":"A client certificate can be associated with a domain. If the server asks for a client certificate during the TLS handshake, the client going to send it back. 1 2 3 4 5 6 7 8 Add for domain : Clicking on it a Domain and File Selector window is shown. If the domain is filled and the certification file is selected clicking on the Ok button going to add the certification for the domain. Delete Selected : Delete selected domain-certificate associations. Help (?) Button : Opens a browser window to this manual. # Column : Index of the certificate Target Domain Column : The certificate sent only if it's requested for the target domain. Authority Column : Common Name or Organizational Unit Name from the certificate's Issuer field. Certifications : Number of certifications displayed. Certificate Size Stats : Min, max, sum and average size of certificate data in bytes. This can help adjusting cache sizes. Clicking on the Add for domain button a new window opens to select the certification file and domain: Then, clicking on the Ok button depending on the type of certificate file a window to input the file's password might open:","title":"Client Certificates"},{"location":"8.Addons/TLSSecurity/CertificationManagerWindow/#testing-http-requests","text":"A basic GET request can be sent out for the given domain to test the current setup. 1 2 3 Input field for the domain to test Send button Result of the request Warning Because of Connection Pooling a request that otherwise would fail can succeed if there's an already open connection to the domain!","title":"Testing HTTP Requests"},{"location":"8.Addons/TLSSecurity/CertificationManagerWindow/#bottom-toolbar","text":"1 2 Name and version number of this addon Support e-mail","title":"Bottom Toolbar"},{"location":"8.Addons/TLSSecurity/Options/","text":"SecurityOptions Options of the addon can be accessed through the static SecurityOptions class: UseServerSentIntermediateCertificates : If false, only certificates stored in the trusted intermediates database are used to reconstruct the certificate chain. When set to true (default), it improves compatibility but the addon going to use/accept certificates that not stored in its trusted database. FolderAndFileOptions : Folder, file and extension options. OCSP : OCSP and OCSP cache options. TrustedRootsOptions : Database options of the Trusted CAs database. TrustedIntermediatesOptions : Database options of the Trusted Intermediate Certifications database Database options of the Client Credentials database : Database options of the Client Credentials database OCSP Options ShortLifeSpanThreshold : The addon not going to check revocation status for short lifespan certificates. EnableOCSPQueries : Enable or disable sending out OCSP requests for revocation checking. FailHard : Treat unknown revocation statuses (unknown OCSP status or unreachable servers) as revoked and abort the TLS negotiation. FailOnMissingCertStatusWhenMustStaplePresent : Treat the TLS connection failed if the leaf certificate has the must-staple flag, but the server doesn't send certificate status. OCSPCache : OCSP Cache Options as detailed below OCSP Cache Options OCSP request caching related options. MaxWaitTime : Maximum wait time to receive an OCSP response. Depending on the OCSP Options' FailHard value if no response is received in the given time the TLS negotiation might fail. RetryUnknownAfter : Wait time to retry to get a new OCSP response when the previous response's status is unknown. FolderName : OCSP cache's folder name. DatabaseOptions : Options for the OCSP cache database. HTTPRequestOptions : Customization options for the OCSP requests. OCSP Cache's HTTPRequest Options OCSP requests are plain old HTTPRequest s and every BestHTTP/2 global settings affecting them, but through this options OCSP requests can be further customized. DataLengthThreshold : A threshold in bytes to switch to a POST request instead of GET. Setting it to 0 all requests are sent as POST. UseKeepAlive : Whether to try to keep the connection alive to the OCSP server. UseCache : Whether to cache responses if possible. ConnectTimeout : Time limit to establish a connection to the server. Timeout : Time limit to send and receive an OCSP response from the server. Database Options Name : Name of the database. This name is used to create the database files. UseHashFile Whether to calculate a hash from the database and write it to a file. It has a useage only if the file is created 'offline' and bundled with the application. DiskManager : Options for the database's DiskManager instance. DiskManager Options MaxCacheSizeInBytes : This limits the maximum database rows kept in memory. HashDigest : Hash digest algorithm name to generate the database's hash. Examples #if !UNITY_WEBGL || UNITY_EDITOR using BestHTTP.Addons.TLSSecurity; // To disable the OCSP cache's memory cache: SecurityOptions.OCSP.OCSPCache.DatabaseOptions.DiskManager.MaxCacheSizeInBytes = 0; TLSSecurity.Setup(); #endif","title":"SecurityOptions"},{"location":"8.Addons/TLSSecurity/Options/#securityoptions","text":"Options of the addon can be accessed through the static SecurityOptions class: UseServerSentIntermediateCertificates : If false, only certificates stored in the trusted intermediates database are used to reconstruct the certificate chain. When set to true (default), it improves compatibility but the addon going to use/accept certificates that not stored in its trusted database. FolderAndFileOptions : Folder, file and extension options. OCSP : OCSP and OCSP cache options. TrustedRootsOptions : Database options of the Trusted CAs database. TrustedIntermediatesOptions : Database options of the Trusted Intermediate Certifications database Database options of the Client Credentials database : Database options of the Client Credentials database","title":"SecurityOptions"},{"location":"8.Addons/TLSSecurity/Options/#ocsp-options","text":"ShortLifeSpanThreshold : The addon not going to check revocation status for short lifespan certificates. EnableOCSPQueries : Enable or disable sending out OCSP requests for revocation checking. FailHard : Treat unknown revocation statuses (unknown OCSP status or unreachable servers) as revoked and abort the TLS negotiation. FailOnMissingCertStatusWhenMustStaplePresent : Treat the TLS connection failed if the leaf certificate has the must-staple flag, but the server doesn't send certificate status. OCSPCache : OCSP Cache Options as detailed below","title":"OCSP Options"},{"location":"8.Addons/TLSSecurity/Options/#ocsp-cache-options","text":"OCSP request caching related options. MaxWaitTime : Maximum wait time to receive an OCSP response. Depending on the OCSP Options' FailHard value if no response is received in the given time the TLS negotiation might fail. RetryUnknownAfter : Wait time to retry to get a new OCSP response when the previous response's status is unknown. FolderName : OCSP cache's folder name. DatabaseOptions : Options for the OCSP cache database. HTTPRequestOptions : Customization options for the OCSP requests.","title":"OCSP Cache Options"},{"location":"8.Addons/TLSSecurity/Options/#ocsp-caches-httprequest-options","text":"OCSP requests are plain old HTTPRequest s and every BestHTTP/2 global settings affecting them, but through this options OCSP requests can be further customized. DataLengthThreshold : A threshold in bytes to switch to a POST request instead of GET. Setting it to 0 all requests are sent as POST. UseKeepAlive : Whether to try to keep the connection alive to the OCSP server. UseCache : Whether to cache responses if possible. ConnectTimeout : Time limit to establish a connection to the server. Timeout : Time limit to send and receive an OCSP response from the server.","title":"OCSP Cache's HTTPRequest Options"},{"location":"8.Addons/TLSSecurity/Options/#database-options","text":"Name : Name of the database. This name is used to create the database files. UseHashFile Whether to calculate a hash from the database and write it to a file. It has a useage only if the file is created 'offline' and bundled with the application. DiskManager : Options for the database's DiskManager instance.","title":"Database Options"},{"location":"8.Addons/TLSSecurity/Options/#diskmanager-options","text":"MaxCacheSizeInBytes : This limits the maximum database rows kept in memory. HashDigest : Hash digest algorithm name to generate the database's hash.","title":"DiskManager Options"},{"location":"8.Addons/TLSSecurity/Options/#examples","text":"#if !UNITY_WEBGL || UNITY_EDITOR using BestHTTP.Addons.TLSSecurity; // To disable the OCSP cache's memory cache: SecurityOptions.OCSP.OCSPCache.DatabaseOptions.DiskManager.MaxCacheSizeInBytes = 0; TLSSecurity.Setup(); #endif","title":"Examples"},{"location":"8.Addons/TLSSecurity/changelog/","text":"Changelog 1.0.2 (2021-12-27) General - [ Bugfix ] ResetSetup() - [ Bugfix ] Fixed bug in AVL tree implementation where RemoveNode not set the new root node's Parent - [ Improvement ] Updated to recent trusted root and intermediate certificates. Certificate Window - [ Bugfix ] Close PasswordInputPopup when cancel button pressed. - [ Improvement ] Skip certificates that fail to load. 1.0.1 (2021-10-18) General [ Bugfix ] Fixed blocking password popup when requested for client certificate [ Improvement ] Updated help urls [ Improvement ] Fresh trusted root and intermediates 1.0.0 (2020-12-21) Initial release","title":"Changelog"},{"location":"8.Addons/TLSSecurity/changelog/#changelog","text":"","title":"Changelog"},{"location":"8.Addons/TLSSecurity/changelog/#102-2021-12-27","text":"General - [ Bugfix ] ResetSetup() - [ Bugfix ] Fixed bug in AVL tree implementation where RemoveNode not set the new root node's Parent - [ Improvement ] Updated to recent trusted root and intermediate certificates. Certificate Window - [ Bugfix ] Close PasswordInputPopup when cancel button pressed. - [ Improvement ] Skip certificates that fail to load.","title":"1.0.2 (2021-12-27)"},{"location":"8.Addons/TLSSecurity/changelog/#101-2021-10-18","text":"General [ Bugfix ] Fixed blocking password popup when requested for client certificate [ Improvement ] Updated help urls [ Improvement ] Fresh trusted root and intermediates","title":"1.0.1 (2021-10-18)"},{"location":"8.Addons/TLSSecurity/changelog/#100-2020-12-21","text":"Initial release","title":"1.0.0 (2020-12-21)"},{"location":"8.Addons/cURLParser/","text":"About cURLParser is a tool to help translate cURL commands into Best HTTP/2 code. Link to the Unity Asset Store page: https://assetstore.unity.com/packages/tools/network/best-http-2-curl-parser-addon-187305 Setup Guide This addon doesn't require any installation steps, but it's recommended to import after the Best HTTP/2 package. After importing both packages the cURLParser window can be opened through the Window/Best HTTP/Addons/cURL Parser/Parser Window menu item or with the Ctrl+Alt+R keyboard shortcut. The cURL Parser Window 1 2 3 4 5 cURL Command : Paste your cURL command here. Request Usage : How and where you want to use the generated code. It can generate code to call a callback upon finishing the request, generate a coroutine or an awaitable async function. Parse Button : Press this button to parse the command and generate the plugin code. Generated Code : This is where the generated code shows up. Note that the generated code is just a snippet, it wouldn't compile pasting it into an empty file and you still have to make edits on the code. Copy to Clipboard Button : Clicking on this going to copy the generated code to the clipboard. Notice Not all cURL features and flags have an equivalent one with Best HTTP/2. Not all cURL features are parsed and implemented. One example is the file content operator (@) that cURL uses to read a field or other content from a file instead of treating it as a plain textual data. Example The picture above uses a cURL command copied from the OneSignal REST API documentation : curl --include \\ --request POST \\ --header \"Content-Type: application/json; charset=utf-8\" \\ --header \"Authorization: Basic YOUR_REST_API_KEY\" \\ --data-binary \"{\\\"app_id\\\": \\\"YOUR_APP_ID\\\", \\\"contents\\\": {\\\"en\\\": \\\"English Message\\\"}, \\\"headings\\\": {\\\"en\\\": \\\"English Title\\\"}, \\\"included_segments\\\": [\\\"Subscribed Users\\\"]}\" \\ https://onesignal.com/api/v1/notifications And the addon generates the following code: async Task SendRequest_onesignalcom_api_v1_notifications() { var request = new HTTPRequest(new Uri(\"https://onesignal.com/api/v1/notifications\"), HTTPMethods.Post); request.AddHeader(\"Content-Type\", \"application/json; charset=utf-8\"); request.AddHeader(\"Authorization\", \"Basic YOUR_REST_API_KEY\"); string data = @\"{\"\"app_id\"\": \"\"YOUR_APP_ID\"\", \"\"contents\"\": {\"\"en\"\": \"\"English Message\"\"}, \"\"headings\"\": {\"\"en\"\": \"\"English Title\"\"}, \"\"included_segments\"\": [\"\"Subscribed Users\"\"]}\"; request.RawData = System.Text.Encoding.UTF8.GetBytes(data); CancellationTokenSource cancellationTokenSource = new CancellationTokenSource(); try { var response = await request.GetHTTPResponseAsync(cancellationTokenSource.Token); } catch (AsyncHTTPException ex) { Debug.Log(\"Status Code: \" + ex.StatusCode); Debug.Log(\"Message: \" + ex.Message); Debug.Log(\"Content: \" + ex.Content); } catch (TaskCanceledException) { Debug.LogWarning(\"Request Canceled!\"); } catch (Exception ex) { Debug.LogException(ex); } finally { cancellationTokenSource.Dispose(); } }","title":"Index"},{"location":"8.Addons/cURLParser/#about","text":"cURLParser is a tool to help translate cURL commands into Best HTTP/2 code. Link to the Unity Asset Store page: https://assetstore.unity.com/packages/tools/network/best-http-2-curl-parser-addon-187305","title":"About"},{"location":"8.Addons/cURLParser/#setup-guide","text":"This addon doesn't require any installation steps, but it's recommended to import after the Best HTTP/2 package. After importing both packages the cURLParser window can be opened through the Window/Best HTTP/Addons/cURL Parser/Parser Window menu item or with the Ctrl+Alt+R keyboard shortcut.","title":"Setup Guide"},{"location":"8.Addons/cURLParser/#the-curl-parser-window","text":"1 2 3 4 5 cURL Command : Paste your cURL command here. Request Usage : How and where you want to use the generated code. It can generate code to call a callback upon finishing the request, generate a coroutine or an awaitable async function. Parse Button : Press this button to parse the command and generate the plugin code. Generated Code : This is where the generated code shows up. Note that the generated code is just a snippet, it wouldn't compile pasting it into an empty file and you still have to make edits on the code. Copy to Clipboard Button : Clicking on this going to copy the generated code to the clipboard. Notice Not all cURL features and flags have an equivalent one with Best HTTP/2. Not all cURL features are parsed and implemented. One example is the file content operator (@) that cURL uses to read a field or other content from a file instead of treating it as a plain textual data.","title":"The cURL Parser Window"},{"location":"8.Addons/cURLParser/#example","text":"The picture above uses a cURL command copied from the OneSignal REST API documentation : curl --include \\ --request POST \\ --header \"Content-Type: application/json; charset=utf-8\" \\ --header \"Authorization: Basic YOUR_REST_API_KEY\" \\ --data-binary \"{\\\"app_id\\\": \\\"YOUR_APP_ID\\\", \\\"contents\\\": {\\\"en\\\": \\\"English Message\\\"}, \\\"headings\\\": {\\\"en\\\": \\\"English Title\\\"}, \\\"included_segments\\\": [\\\"Subscribed Users\\\"]}\" \\ https://onesignal.com/api/v1/notifications And the addon generates the following code: async Task SendRequest_onesignalcom_api_v1_notifications() { var request = new HTTPRequest(new Uri(\"https://onesignal.com/api/v1/notifications\"), HTTPMethods.Post); request.AddHeader(\"Content-Type\", \"application/json; charset=utf-8\"); request.AddHeader(\"Authorization\", \"Basic YOUR_REST_API_KEY\"); string data = @\"{\"\"app_id\"\": \"\"YOUR_APP_ID\"\", \"\"contents\"\": {\"\"en\"\": \"\"English Message\"\"}, \"\"headings\"\": {\"\"en\"\": \"\"English Title\"\"}, \"\"included_segments\"\": [\"\"Subscribed Users\"\"]}\"; request.RawData = System.Text.Encoding.UTF8.GetBytes(data); CancellationTokenSource cancellationTokenSource = new CancellationTokenSource(); try { var response = await request.GetHTTPResponseAsync(cancellationTokenSource.Token); } catch (AsyncHTTPException ex) { Debug.Log(\"Status Code: \" + ex.StatusCode); Debug.Log(\"Message: \" + ex.Message); Debug.Log(\"Content: \" + ex.Content); } catch (TaskCanceledException) { Debug.LogWarning(\"Request Canceled!\"); } catch (Exception ex) { Debug.LogException(ex); } finally { cancellationTokenSource.Dispose(); } }","title":"Example"},{"location":"8.Addons/cURLParser/changelog/","text":"Changelog 1.0.2 (2021-10-18) General [ Improvement ] Updated help url 1.0.1 (2021-02-05) General [ Bugfix ] Generated code for Content-Type had a compile error [ Improvement ] To genereate smaller code GET requests will use the default HTTPRequest constructor [ Improvement ] Replace more characters to generate a valid function name 1.0.0 (2021-01-28) Initial release","title":"Changelog"},{"location":"8.Addons/cURLParser/changelog/#changelog","text":"","title":"Changelog"},{"location":"8.Addons/cURLParser/changelog/#102-2021-10-18","text":"General [ Improvement ] Updated help url","title":"1.0.2 (2021-10-18)"},{"location":"8.Addons/cURLParser/changelog/#101-2021-02-05","text":"General [ Bugfix ] Generated code for Content-Type had a compile error [ Improvement ] To genereate smaller code GET requests will use the default HTTPRequest constructor [ Improvement ] Replace more characters to generate a valid function name","title":"1.0.1 (2021-02-05)"},{"location":"8.Addons/cURLParser/changelog/#100-2021-01-28","text":"Initial release","title":"1.0.0 (2021-01-28)"}]}